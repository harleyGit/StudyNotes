- [**æ—¥å¿—**](#æ—¥å¿—)
	- [æ—¥å¿—æ ¼å¼](#æ—¥å¿—æ ¼å¼)
- [æ–‡ä»¶](#æ–‡ä»¶)
	- [æ–‡ä»¶é”](#æ–‡ä»¶é”)







<br/><br/><br/>

***
<br/>

> <h1 id="æ—¥å¿—">æ—¥å¿—</h1>


***
<br/><br/><br/>
> <h2 id="æ—¥å¿—æ ¼å¼">æ—¥å¿—æ ¼å¼</h2>

```go
// åˆ›å»ºä¸€ä¸ªå¸¦å‰ç¼€å’Œå¾®ç§’æ—¶é—´æˆ³çš„ Logger
logger := log.New(os.Stderr, "[MyApp] ", log.Ldate|log.Ltime|log.Lmicroseconds)

// æ‰“å°å‡ æ¡æ—¥å¿—çœ‹çœ‹æ•ˆæœ
logger.Println("å¯åŠ¨æœåŠ¡ä¸­...")
logger.Println("è¿æ¥æ•°æ®åº“æˆåŠŸ")
logger.Println("ç›‘å¬ç«¯å£ 8080")
```

**logï¼š**

```sh
[MyApp] 2025/07/28 20:43:14.219516 å¯åŠ¨æœåŠ¡ä¸­...
[MyApp] 2025/07/28 20:43:14.220162 è¿æ¥æ•°æ®åº“æˆåŠŸ
[MyApp] 2025/07/28 20:43:14.220168 ç›‘å¬ç«¯å£ 8080
```

<br/>

```go
log.New(output io.Writer, prefix string, flag int)
```

ä½ çš„ä»£ç ä¸­ä¼ çš„æ˜¯ï¼š

* `os.Stderr`ï¼šè¾“å‡ºä½ç½®ä¸ºæ ‡å‡†é”™è¯¯ï¼ˆä¹Ÿå¯ä»¥æ˜¯æ–‡ä»¶ï¼Œæ¯”å¦‚ `os.Stdout` æˆ–æ—¥å¿—æ–‡ä»¶ï¼‰
* `opts.LogPrefix`ï¼šæ—¥å¿—å‰ç¼€ï¼Œæ¯”å¦‚å¯ä»¥è®¾ç½®ä¸º `"[NSQ] "`ï¼Œæ¯æ¡æ—¥å¿—å‰é¢ä¼šè‡ªåŠ¨åŠ ä¸Šå®ƒ
* `log.Ldate | log.Ltime | log.Lmicroseconds`ï¼šæ—¥å¿—æ ¼å¼æ ‡å¿—ï¼Œè¡¨ç¤ºï¼š

  * `log.Ldate`ï¼šæ—¥å¿—ä¸­åŠ æ—¥æœŸï¼Œå¦‚ `2025/07/28`
  * `log.Ltime`ï¼šæ—¥å¿—ä¸­åŠ æ—¶é—´ï¼Œå¦‚ `10:15:45`
  * `log.Lmicroseconds`ï¼šåŠ å¾®ç§’ï¼Œæ¯”å¦‚ `10:15:45.123456`


<br/>

**ğŸ’¡ è¿™ä¸ª Logger æœ‰å•¥ç”¨ï¼Ÿ**

* ç»Ÿä¸€æ ¼å¼æ‰“å°æ—¥å¿—ï¼ˆå¸¦æ—¥æœŸã€æ—¶é—´ã€å¾®ç§’ï¼‰
* è®¾ç½®å‰ç¼€åŒºåˆ†ä¸åŒæ¨¡å—ï¼ˆå¦‚ `[NSQD]`, `[NSQLookupd]`ï¼‰
* æ§åˆ¶è¾“å‡ºä½ç½®ï¼ˆç»ˆç«¯æˆ–æ–‡ä»¶ï¼‰
* æ”¯æŒå¤šç§æ—¥å¿—çº§åˆ«ï¼ˆé€šè¿‡è‡ªå·±å°è£…ï¼‰

<br/>

**æ‹“å±•ï¼šå†™å…¥åˆ°æ–‡ä»¶ç¤ºä¾‹**

```go
f, _ := os.Create("/Users/ganghuang/HGFiles/GitHub/GoProject/src/MLC_GO/app.log")
logger01 := log.New(f, "[MyApp] ", log.Ldate|log.Ltime|log.Lmicroseconds)
logger01.Println("å†™å…¥æ—¥å¿—æ–‡ä»¶---------å®æ‰“å®çš„å‘é€å“ˆ")
```


è‹¥æ˜¯æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ™ä¼šæ ¹æ®æ–‡ä»¶è·¯å¾„ï¼Œè‡ªåŠ¨åˆ›å»ºã€‚

**app.log**

```txt
[MyApp] 2025/07/28 20:43:14.220676 å†™å…¥æ—¥å¿—æ–‡ä»¶---------å®æ‰“å®çš„å‘é€å“ˆ
```

ä¸è¿‡è¿™ä¸ªæ–‡ä»¶æœ‰ç‚¹é—®é¢˜ï¼Œå®ƒä¼šè¦†ç›–ä¸Šä¸€ä¸ªæ‰“å°çš„æ—¥å¿—ã€‚


***
<br/><br/><br/>
> <h2 id="é”™è¯¯æ ¼å¼é€‰æ‹©">é”™è¯¯æ ¼å¼é€‰æ‹©</h2>

* `errors.New("...")`ï¼šç”Ÿæˆä¸€ä¸ª**å›ºå®šæ–‡æœ¬**çš„é”™è¯¯ï¼ˆå¸¸ç”¨äºâ€œå“¨å…µé”™è¯¯ / sentinel errorâ€ï¼‰ã€‚
* `fmt.Errorf("...")`ï¼šåƒ `Sprintf` ä¸€æ ·**æ ¼å¼åŒ–**é”™è¯¯ä¿¡æ¯ï¼›è‹¥ç”¨ **`%w`** åŒ…å«å¦ä¸€ä¸ªé”™è¯¯ï¼Œå°±å˜æˆ**åŒ…è£…ï¼ˆwrappingï¼‰**ï¼Œä¾¿äºåç»­ç”¨ `errors.Is/As` åˆ¤æ–­åŸå› ã€‚

<br/>

| åœºæ™¯                  | ç”¨æ³•                                                            | è¯´æ˜                                                 |
| ------------------- | ------------------------------------------------------------- | -------------------------------------------------- |
| å›ºå®šè¯­ä¹‰çš„å¯åˆ¤å®šé”™è¯¯ï¼ˆåŒ…çº§å¸¸é‡/å˜é‡ï¼‰ | `var ErrNodeIDRange = errors.New("node-id must be [0,1024)")` | ä½œä¸ºâ€œå“¨å…µé”™è¯¯â€åœ¨åŒ…å¤–å¯è¢«åˆ¤å®šï¼ˆ`errors.Is(err, ErrNodeIDRange)`ï¼‰ã€‚ |
| ç»™é”™è¯¯å¢åŠ ä¸Šä¸‹æ–‡ï¼ˆä¸å…³å¿ƒåº•å±‚ç±»å‹ï¼‰   | `fmt.Errorf("failed to lock %q", path)`                       | åªç”Ÿæˆä¸€æ¡æè¿°ä¿¡æ¯ï¼Œä¸ä¿ç•™â€œå› æœé“¾â€ã€‚                                |
| ç»™é”™è¯¯å¢åŠ ä¸Šä¸‹æ–‡ä¸”**ä¿ç•™å› æœé“¾**  | `fmt.Errorf("failed to lock %q: %w", path, err)`              | ç”¨ **`%w`** åŒ…è£…åº•å±‚é”™è¯¯ï¼Œä¹‹åå¯ç”¨ `errors.Is/As/Unwrap` è¿½æº¯ã€‚   |
| åŠ¨æ€ä¿¡æ¯ä½†ä»æƒ³å¯åˆ¤å®š          | `fmt.Errorf("%w: got %d", ErrNodeIDRange, id)`                | åœ¨å“¨å…µé”™è¯¯å¤–å†é™„åŠ ç»†èŠ‚ã€‚                                       |

> `fmt.Errorf("failed to lock data-path: %v", err)` **åªæ‹¼æ–‡æ¡ˆ**ï¼Œä¸ä¼šå»ºç«‹å¯åˆ¤å®šçš„â€œå› æœé“¾â€ã€‚è‹¥è¦åç»­åˆ¤æ–­åº•å±‚é”™è¯¯ï¼Œè¯·æ”¹ä¸º **`%w`**ï¼š
> `fmt.Errorf("failed to lock data-path: %w", err)`ã€‚

<br/>

**ç¤ºä¾‹**

**1)æ ¡éªŒ IDï¼šå“¨å…µé”™è¯¯ + å¯åˆ¤å®š**

```go
package node

import (
	"errors"
	"fmt"
)

var ErrNodeIDRange = errors.New("node-id must be [0,1024)")

func ValidateNodeID(id int) error {
	if id < 0 || id >= 1024 {
		// ä¿ç•™å¯åˆ¤å®šçš„è¯­ä¹‰ï¼ˆErrNodeIDRangeï¼‰ï¼ŒåŒæ—¶æºå¸¦ç»†èŠ‚
		return fmt.Errorf("%w: got %d", ErrNodeIDRange, id)
	}
	return nil
}
```

<br/>

è°ƒç”¨æ–¹ï¼š

```go
if err := node.ValidateNodeID(2048); err != nil {
	if errors.Is(err, node.ErrNodeIDRange) {
		// æ˜ç¡®çŸ¥é“æ˜¯â€œèŒƒå›´é”™è¯¯â€
		// å¯ä»¥è¿”å› 400ã€æç¤ºç”¨æˆ·ã€æˆ–èµ°ç‰¹å®šåˆ†æ”¯
	}
	// è®°å½•æ—¥å¿—æ—¶æ‰“å°å®Œæ•´æ–‡æœ¬
	// log.Printf("validate failed: %v", err) // node-id must be [0,1024): got 2048
}
```

<br/> 

**2) åŠ é”å¤±è´¥ï¼šä¿ç•™æ ¹å› ï¼ˆç”¨ `%w` åŒ…è£…ï¼‰**

```go
package locker

import (
	"fmt"
	"os"
)

func Lock(path string) error {
	// å‡è®¾åº•å±‚è¿”å›çš„æ˜¯æŸä¸ªå…·ä½“é”™è¯¯ï¼ˆä¾‹å¦‚ os.ErrExistï¼‰
	if err := doLock(path); err != nil {
		return fmt.Errorf("lock %q: %w", path, err) // ç”¨ %w æ‰èƒ½è¢« Is/As åˆ¤æ–­
	}
	return nil
}

func doLock(path string) error {
	// ä»…ç¤ºæ„ï¼šè¿”å›ä¸€ä¸ªå…·ä½“æ ¹å› 
	return os.ErrExist
}
```

<br/>

è°ƒç”¨æ–¹å¯ç²¾ç¡®åˆ†æ”¯ï¼š

```go
err := locker.Lock("/data/nsqd")
if err != nil {
	switch {
	case errors.Is(err, os.ErrExist):
		// ç›®å½•/é”å·²å­˜åœ¨ï¼ˆæ¯”å¦‚å·²æœ‰è¿›ç¨‹å ç”¨ï¼‰
	case errors.Is(err, os.ErrPermission):
		// æƒé™é—®é¢˜
	default:
		// å…¶ä»–æœªçŸ¥é—®é¢˜
	}
}
```

> å¦‚æœè¿™é‡Œç”¨äº† `%v`ï¼š`fmt.Errorf("lock %q: %v", path, err)`ï¼Œ**`errors.Is(err, os.ErrExist)` å°†ä¼šå¤±è´¥**ï¼Œå› ä¸ºæ²¡æœ‰å»ºç«‹â€œåŒ…è£…é“¾â€ã€‚

<br/> 

**3) `errors.As`ï¼šæå–å…·ä½“é”™è¯¯ç±»å‹**

æœ‰æ—¶ä½ å…³å¿ƒ**ç±»å‹**è€Œä¸æ˜¯ç­‰å€¼ï¼š

```go
type ErrRemote struct {
	Code int
	Msg  string
}
func (e *ErrRemote) Error() string { return fmt.Sprintf("remote: %d %s", e.Code, e.Msg) }

func call() error {
	return fmt.Errorf("rpc failed: %w", &ErrRemote{Code: 502, Msg: "bad gateway"})
}

if err := call(); err != nil {
	var r *ErrRemote
	if errors.As(err, &r) {
		// æ‹¿åˆ°ç»“æ„åŒ–ä¿¡æ¯ r.Code / r.Msg
	}
}
```

<br/> 

**4) å¤šä¸ªæ ¹å› ï¼ˆGo 1.20+ï¼‰ï¼š`errors.Join`**

```go
if e1 != nil && e2 != nil {
	return errors.Join(e1, e2) // ä¸¤ä¸ªéƒ½æ˜¯çœŸæ ¹å› 
}
```

`errors.Is/As` ä¼šå¯¹ join åçš„é”™è¯¯é€ä¸ªåŒ¹é…ã€‚
<br/>

**è§„åˆ™/ç»†èŠ‚ä½ å¯èƒ½ä¼šç”¨åˆ°**

* **åªåœ¨éœ€è¦â€œå¯åˆ¤å®šæ ¹å› â€æ—¶ç”¨ `%w`**ï¼›å¦åˆ™ `%v` å°±å¤Ÿï¼ˆä¾‹å¦‚ä»…æ—¥å¿—ç”¨ï¼‰ã€‚
* **ä¸€ä¸ª `fmt.Errorf` æ ¼å¼ä¸²é‡Œåªèƒ½æœ‰ä¸€ä¸ª `%w`**ã€‚
* `errors.New` é€‚åˆåš**åŒ…çº§**å“¨å…µé”™è¯¯ï¼ˆ`var ErrXxx = errors.New("...")`ï¼‰ã€‚ä¸è¦åœ¨æ¯æ¬¡è¿”å›æ—¶éƒ½æ–°å»ºä¸€ä¸ª `errors.New("...")` å†æ‹¿æ¥æ¯”è¾ƒï¼Œ**é‚£æ ·æ¯”è¾ƒä¼šå¤±è´¥**ï¼›è¦å’ŒåŒä¸€ä¸ªåŒ…çº§å˜é‡æ¯”æˆ–ç”¨ `errors.Is`ã€‚
* é”™è¯¯ä¿¡æ¯éµå¾ª Go æƒ¯ä¾‹ï¼š**ä¸ç”¨é¦–å­—æ¯å¤§å†™**ã€**ä¸ä»¥å¥å·ç»“å°¾**ï¼ˆæ—¥å¿—è¡Œä¼šæ‹¼æ¥æ›´å¤šä¸Šä¸‹æ–‡ï¼‰ã€‚

<br/>

**ä½ ç»™çš„ä¸¤è¡Œå¯¹æ¯”ï¼ˆæ¨èå†™æ³•ï¼‰**

```go
// âœ… æ¨èï¼šä¿ç•™æ ¹å› 
return fmt.Errorf("failed to lock data-path %q: %w", dataPath, err)

// âœ… ä½œä¸ºå“¨å…µï¼ˆåŒ…çº§å˜é‡ï¼‰
var ErrNodeIDRange = errors.New("node-id must be [0,1024)")
// è¿”å›æ—¶å¸¦ç»†èŠ‚ä½†ä¿æŒå¯åˆ¤å®šæ€§
return fmt.Errorf("%w: got %d", ErrNodeIDRange, id)
```




<br/><br/><br/>

***
<br/>

> <h1 id="æ–‡ä»¶">æ–‡ä»¶</h1>


***
<br/><br/><br/>
> <h2 id="æ–‡ä»¶é”">æ–‡ä»¶é”</h2>


```go
dl:= dirlock.New(dataPath),
```

æ˜¯åœ¨åˆ›å»ºä¸€ä¸ª **ç›®å½•é”ï¼ˆdir lockï¼‰** çš„å®ä¾‹ï¼Œé˜²æ­¢**å¤šä¸ªè¿›ç¨‹åŒæ—¶è®¿é—®æˆ–å†™å…¥åŒä¸€ä¸ªç›®å½•**ï¼Œæ˜¯ NSQ æˆ–ç±»ä¼¼ç³»ç»Ÿä¸­å¸¸è§çš„ **å¹¶å‘å®‰å…¨æœºåˆ¶**ã€‚

br/>

 **`dirlock.New(dataPath)` æ˜¯å¹²å˜›çš„ï¼Ÿ**

å®ƒè°ƒç”¨ `dirlock` åŒ…ä¸­çš„ `New()` æ–¹æ³•ï¼Œç”¨æ¥åˆ›å»ºä¸€ä¸ª **é’ˆå¯¹æŒ‡å®šç›®å½•çš„é”**ã€‚

* `dataPath` æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºæŸä¸ªç›®å½•è·¯å¾„ï¼ˆæ¯”å¦‚ `./data`ï¼‰ã€‚
* `dirlock.New(dataPath)` è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼ˆæˆ–ç»“æ„ä½“ï¼‰ï¼Œè¡¨ç¤ºâ€œæˆ‘ç°åœ¨æƒ³è¦é”å®šè¿™ä¸ªç›®å½•â€ã€‚

é”å®šé€šå¸¸æ˜¯é€šè¿‡åœ¨è¯¥ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ª `.lock` æ–‡ä»¶å®ç°çš„ã€‚

br/> 

**âœ… `dl: dirlock.New(dataPath),` æ˜¯å¹²å˜›çš„ï¼Ÿ**

è¿™æ˜¯ Go ä¸­ç»“æ„ä½“èµ‹å€¼çš„è¯­æ³•ï¼ˆä»¥ map/struct é£æ ¼å†™æ³•ï¼‰ï¼Œæ¯”å¦‚ä½ å®šä¹‰ä¸€ä¸ªç»“æ„ä½“ï¼š

```go
type NSQD struct {
	dl *dirlock.DirLock
}
```

ç„¶åä½ åˆ›å»ºè¿™ä¸ªç»“æ„ä½“å®ä¾‹æ—¶è¿™æ ·å†™ï¼š

```go
nsqd := &NSQD{
	dl: dirlock.New(dataPath),
}
```

ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸€è¡Œæ˜¯åœ¨åˆå§‹åŒ–æŸä¸ªç»„ä»¶ï¼ˆå¦‚ NSQD æˆ– NSQLookupdï¼‰ï¼Œå¹¶å°†ç›®å½•é”ç»‘å®šè¿›å»ï¼Œä¿å­˜åœ¨ `dl` å­—æ®µä¸­ã€‚

<br/>

**å‡è®¾ä½ æœ‰ä¸€ä¸ª `dirlock` åŒ…ï¼Œæˆ‘ä»¬è‡ªå·±æ¨¡æ‹Ÿå®ƒï¼š**

```go
package dirlock

import (
	"fmt"
)

type DirLock struct {
	Path string
}

func New(path string) *DirLock {
	fmt.Println("ğŸ” åˆå§‹åŒ–ç›®å½•é”:", path)
	return &DirLock{Path: path}
}
```

ç„¶åä¸»ç¨‹åºï¼š

```go
package main

import (
	"./dirlock"
)

type App struct {
	dl *dirlock.DirLock
}

func main() {
	app := &App{
		dl: dirlock.New("./data"),
	}

	fmt.Println("ç›®å½•é”è·¯å¾„ä¸ºï¼š", app.dl.Path)
}
```

<br/> 

**ç”¨é€”æ€»ç»“ï¼š**

| åœºæ™¯                  | ç›®çš„                               |
| ------------------- | -------------------------------- |
| å¤šä¸ª NSQD å®ä¾‹æŒ‡å‘åŒä¸€ä¸ªæ•°æ®ç›®å½• | é˜²æ­¢æ•°æ®ç«äº‰æˆ–æ–‡ä»¶å†²çªï¼ˆä¸¤ä¸ªè¿›ç¨‹å†™ä¸€ä¸ªæ–‡ä»¶ä¼šå¯¼è‡´å´©æºƒæˆ–æ•°æ®ä¸¢å¤±ï¼‰ |
| æ£€æŸ¥ç›®å½•æ˜¯å¦å·²è¢«å…¶ä»–è¿›ç¨‹å ç”¨      | `.lock` æ–‡ä»¶ + æ–‡ä»¶é”ï¼ˆfcntl/flockï¼‰æœºåˆ¶  |
| å¯åŠ¨æ—¶å…ˆåŠ é”ï¼Œé€€å‡ºæ—¶é‡Šæ”¾        | ç¡®ä¿ç›®å½•ç”Ÿå‘½å‘¨æœŸæ˜¯ç‹¬å çš„                     |


