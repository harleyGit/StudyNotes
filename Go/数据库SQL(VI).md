> <h1 id=""></h1>
- [**索引数据结构**](#索引数据结构)
	- [聚簇索引(InnoDB用的)](#聚簇索引)
	- [二级索引(辅助索引、非聚簇索引)](#二级索引(辅助索引、非聚簇索引))
	- [联合索引](#联合索引)
	- [MyISAM索引的原理](#MyISAM索引的原理)
	- [MyISAM与InnoDB对比](#MyISAM与InnoDB对比)
	- [B+树和其他数据结构查找比较](#B+树和其他数据结构查找比较)
		- [为了减少IO，索引树会一次性加载吗？](#为了减少IO，索引树会一次性加载吗？)	
		- [B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO	](#B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO)
		- [为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？](#为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？) 
		- [Hash索引与B+树索引是在建索引的时候手动指定的吗？](#Hash索引与B+树索引是在建索引的时候手动指定的吗？)
- [**InnoDB数据存储结构**](#InnoDB数据存储结构)



<br/><br/><br/>

***
<br/>

> <h1 id="索引数据结构">索引数据结构</h1>
**表的行格式**

`行格式`指的是存储在表中的每一行数据的物理存储格式

```mysql
CREATE TABLE index_demo(
    c1 INT,
    c2 INT,
    c3 CHAR(1),
    PRIMARY KEY(c1)
) ROW_FORMAT = Compact;
```

这个新建的`index_demo`表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了**`c1列为主键`**，这个表使用`Compact`行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：

![go.0.0.150.jpg](./../Pictures/go.0.0.150.jpg)

- `record_type`：记录头信息的一项属性，表示记录的类型，**`0`表示普通记录、`1`表示目录项记录、`2`表示最小记录、`3`表示最大记录。**
- `next_record`：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。
- `各个列的值`：这里只记录在`index_demo`表中的三个列，分别是`c1`、`c2`和`c3`。 
- `其他信息`：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

<br/>

将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：

![go.0.0.151.jpg](./../Pictures/go.0.0.151.jpg)


***
<br/><br/><br/>
> <h2 id="聚簇索引">聚簇索引</h2>

最终生成的这个数据结构，它的名称是B+树。

![go.0.0.148.jpg](./../Pictures/go.0.0.148.jpg)

叶子结点,比如**页10**其中**黄色的放入的是主键**,它们放入的是一条记录,即:索引即数据,所以查找比较快.

在InnoDB数据引擎中,数据、索引是放在一块的,这点和MyISAM引擎不太一样,它们是分开放的.

<br/>

![go.0.0.149.png](./../Pictures/go.0.0.149.png)

一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第0层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：

如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。
如果B+树有2层，最多能存放1000×100=10,0000条记录。
如果B+树有3层，最多能存放1000×1000×100=1,0000,0000条记录。
如果B+树有4层，最多能存放1000×1000×1000×100=1000,0000,0000条记录。相当多的记录！！！
你的表里能存放100000000000条记录吗？所以一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的Page Directory（页目录），所以在页面内也可以通过二分法实现快速定位记录。

<br/>

**聚簇索引**不仅是一种索引类型，也是**一种数据存储方式**（所有的用户记录都存储在了叶子结点），也就是所谓的`索引即数据，数据即索引(因为它的索引,直接对应一条数据,找到了索引,也就找到了数据)`。

> 聚簇索引中的“聚簇”指的是索引中存储数据行的方式。
>
> 索引键和实际数据行存储在同一个结构中，这种结构称为聚簇

<br/>

**特点：**

<b>1）使用记录主键值的大小进行记录和页的排序</b>，这包括三个方面的含义：

- `页内`的记录是按照主键的大小顺序排成一个`单向链表`。

- 各个存放`用户记录的页`也是根据页中用户记录的主键大小顺序排成一个`双向链表`。
- 存放`目录项记录的页`分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个`双向链表`。 

<b>2）B+树的`叶子节点`存储的是完整的用户记录。</b>

  所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个`聚簇索引`的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用`INDEX`语句去创建，`InnoDB`存储引擎会`自动`的为我们创建聚簇索引。

<br/>

**优点：**

- `数据访问更快`，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
- 聚簇索引对于主键的`排序查找`和`范围查找`速度非常快
- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以`节省了大量的io操作`。

<br/>

**缺点：**

- `插入速度严重依赖于插入顺序`，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个**自增ID列为主键**
- `更新主键的代价很高`，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义**主键为不可更新**
- `二级索引访问需要两次索引查找`，第一次找到主键值，第二次根据主键值找到行数据

<br/>

**限制：**

* 对于MySQL数据库，目前只有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。
* 由于数据物理存储排序方式只能有一种，所以每个MySQL的`表只能有一个聚簇索引`。一般情况下就是该表的主键。
* 如果没有定义主键，Innodb会选择`非空的唯一索引`代替。如果没有这样的索引，Innodb会隐式的定义一个主键
  来作为聚簇索引。
* 为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量`选用有序的顺序id`，而不建议用无序的id,
  比如UUID, MD5, HASH, 字符串列作为主键无法保证数据的顺序增长。


***
<br/><br/><br/>
> <h2 id="二级索引(辅助索引、非聚簇索引)">二级索引(辅助索引、非聚簇索引)</h2>

因为每个MySQL的**`表只能有一个聚簇索引`**，一般情况下就是该表的主键

* 以表中的非主键列或者列组合建立的索引即为`二级索引`

  当非主键列作为查询或者连表、排序等操作的条件时，为了提高效率，就可以以非主键列建立二级索引

* 二级索引不存储完整的行数据，只包含索引列及主键信息

  因为每建立一颗B+树都把所有的用户记录再拷贝一遍，太浪费存储空间了。

* 因为数据和索引分开存储，所以二级索引属于**非聚簇索引**

<br/>

* **概念：回表** 根据二级索引的B+树只能确定要查找记录的主键值，如果想查找到完整的用户记录的话，仍然需要到`聚簇索引`中再查一遍，这个过程称为`回表`。查询一条完整的用户记录需要使用到`2`棵B+树！

* **二级索引的目录项**，包含主键值，索引列，页号，**从而保证目录项的唯一性**

  因为二级索引列的值是可以重复的，而主键是唯一的。
  
<br/><br/>

![go.0.0.151.png](./../Pictures/go.0.0.151.png)

- **如上图:** 
	- 在子节点中,黄色是主键,蓝色对应的是二级索引,这个要分清;
	- 蓝色可能相同,但是对应的主键不同;
		- 比如: 找**c2:4**的数据,我们通过二分法先找到**页44**下的`(2, 42)`记录,因为**c2:4**的`4比2大,比9小`,要知道`(2, 42)`存放的**2是其记录中最小的**;
			- 然后通过`(2, 42)`找到页记录**页42**,我们可以发现比**c2:4**中的**4**`小于和等于`的有**`‌(2,4)、(4,35)`**才符合,这个是为什么呢?
				- 因为**`‌(2,4)、(4,35)`**的记录中, **(2,4)** 后面的数据记录可能有**4**,因为它的最小值是**2, 它是递增的**. 而**‌(4,35)** 包含了**4**,它肯定有了.
				- 通过查找,我们在其子节点中找到了.
		- 比如: **`select  from index_demo where c2 = 4`** 这个SQL语句中, `*`表示`c1, c2, c3`的数据,从其子节点中,我们可以可以找到**`c2, c1(c1是主键)`**,但是**c3怎么查找呢?**
			- 这就谈到了**回表**这个概念了,我们在其**🍃叶子结点(4,1)、(4,4)、(4,10)** 找到主键**`4、10、1`**,然后通过**聚簇索引**找到**c3**数据.这个过程就是**回表.**

<br/><br/>
> <h3 id="为什么需要一次回表操作?">为什么需要一次回表操作?</h3>

若是把完整的用户记录放到叶子结点是可以不用回表.但是**太占内存空间了**.相当于每建立一棵B+树都需要把所有的用户记录再拷贝一遍,太浪费存储空间了.

回表好处: 按照这种**非主键列**建立的B+树需要一次回表操作才可以定位到完整的用户记录,所以这种B+树也被称为**二级索引**,或者**辅助索引**.由于我们使用的是c2列的大小作为B+树的排序规则,所以我们也称这个B+树是为c2列建立的索引.


***
<br/><br/><br/>
> <h2 id="联合索引">联合索引</h2>
`联合索引`同时以多个列的大小作为排序规则，也就是同时以多个列建立索引

- 例如B+树按照`c2和c3列`的大小进行排序，这个包含两层含义：
	- 先把各个记录和页按照c2列进行排序。
	- 在记录的c2列相同的情况下，采用c3列进行排序

以c2和c3列的大小为排序规则建立的B+树称为`联合索引`

联合索引可以是聚簇索引也可以是非聚簇索引，当联合索引包含主键列时，就会建立聚簇索引

<br/>

![go.0.0.152.png](./../Pictures/go.0.0.152.png)

- **如图所示:**
	- 每条目录记录都是由c2、c3、页号3个部分组成,每条记录先按照c2列的值进行排序,如果记录的c2列值相同,则按照c3列的值进行排序;
	- 每条叶子🍃结点都是由**c2 (蓝色)、c3(紫色)、c1主键(橙黄色)[c2、c3组成联合索引]** 组成;

***
<br/><br/><br/>
> <h2 id="MyISAM索引的原理">MyISAM索引的原理</h2>
- MyISAM引擎文件结构:
	- xxx_387.sdi: 存储表的数据结构;
	- xxx.MYD: 存储表数据;
	- xxx.MYI: 存储表索引

InnoDB中索引即数据，也就是聚簇索引的那棵B+树的叶子节点包含所有完整的用户记录，而MyISAM的索引方案虽然也使用树形结构，但是却将`索引和数据分开存储`：

- 将表中的记录`按照记录的插入顺序`单独存储在一个文件中，称之为`数据文件`。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录。由于在插入数据的时候并**没有刻意按照主键大小排序**，所以并不能在这些数据上使用二分法进行查找。
- 使用`MyISAM`存储引擎的表会把索引信息另外存储到一个称为`索引文件`的另一个文件中。MyISAM会单独为表的主键创建一个索引，索引的叶子节点中存储的不是完整的用户记录，而是**主键值 + 数据记录地址**的组合。

![go.0.0.154.jpg](./../Pictures/go.0.0.154.jpg)

这里表一共有三列，假设我们以Col1为主键，上图是一个MyISAM表的主索引（Primary key）示意。可以看出
**MyISAM的索引文件仅仅保存数据记录的地址**。在MyISAM中，主键索引和二级索引（Secondary key）在结构上没有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在Col2上建立一个二级索
引，则此索引的结构如下图所示：

![go.0.0.153.jpg](./../Pictures/go.0.0.153.jpg)


***
<br/><br/><br/>
> <h2 id="MyISAM与InnoDB对比">MyISAM与InnoDB对比</h2>
**MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。**

**小结两种引擎中索引的区别：**

① 在InnoDB存储引擎中，我们只需要根据主键值对`聚簇索引`进行一次查找就能找到对应的记录，而在`MyISAM`中却需要进行一次`回表`操作，意味着MyISAM中建立的索引相当于全部都是`二级索引`。 

② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是`分离的`，索引文件仅保存数据记录的地址。

③ InnoDB的非聚簇索引data域存储相应记录**`主键的值`**，而MyISAM索引记录的是**`地址`**。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。

④ MyISAM的回表操作是十分`快速`的，**因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录**，虽然说也不慢，但还是比不上直接用地址去访问。

⑤ InnoDB要求表`必须有主键`（`MyISAM可以没有`）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。

<br/><br/>

**小结：**

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如：

举例1：知道了InnoDB的索引实现后，就很容易明白`为什么不建议使用过长的字段作为主键`，因为所有二级索引都
引用主键索引，过长的主键索引会令二级索引变得过大。数据页大小固定，数据项越大，单页存储的记录数越少，B+数的层级越多。

举例2：用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree，非单调的
主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而`使用自增字段作
为主键则是一个很好的选择`。

![go.0.0.155.jpg](./../Pictures/go.0.0.155.jpg)

***
<br/><br/><br/>
> <h2 id="B+树和其他数据结构查找比较">B+树和其他数据结构查找比较</h2>

<br/><br/>
> <h3 id="为了减少IO，索引树会一次性加载吗？">为了减少IO，索引树会一次性加载吗？</h3>

- 1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。

- 2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。

<br/><br/>
> <h3 id="B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO">B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</h3>

- InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值，因为是估算，为了方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿条记录。（这里假定一个数据页也存储10^3条行记录数据了）

- 实际情况中每个节点可能不能填充满，因此在数据库中，`B+Tree的高度一般都在2~4层`。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作

<br/><br/>
> <h3 id="为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？">为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</h3>

- 1.B+树的磁盘读写代价更低
	- B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对于B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

- 2、B+树的查询效率更加稳定
	- 由于非终结点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所有任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

<br/><br/>
> <h3 id="Hash索引与B+树索引的区别">Hash索引与B+树索引的区别</h3>
- 1、Hash索引`不能进行范围查询`，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。

- 2、Hash索引`不支持联合索引的最左侧原则`（即联合索引的部分索引无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。

- 3、Hash索引`不支持 ORDER BY 排序`，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY排序优化的作用。同理，我们也无法用Hash索引进行`模糊查询`，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。

- 4、`InnoDB不支持哈希索引`

<br/><br/>
> <h3 id="Hash索引与B+树索引是在建索引的时候手动指定的吗？">Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</h3>

针对InnoDB和MyISAM存储引擎，都会默认采用B+树索引，而非使用Hash索引。InnoDB提供的自适应Hash是不需要手动指定的。如果是Memory/Heap和NDB存储引擎，则可以选择使用Hash索引。


<br/><br/><br/>

***
<br/>

> <h1 id="InnoDB数据存储结构">InnoDB数据存储结构</h1>


<br/>

```sql

```

<br/>

```sql

```

<br/>

```sql

```

<br/>

```sql

```

