> # 高级语法
- [sql.NullString使用](#sql.NullString使用)
- [函数式选项模式](#函数式选项模式)






<br/><br/><br/>

***
<br/>

> <h1 id="sql.NullString使用">sql.NullString使用</h1>
> **`sql.NullString` 是用来正确表示「数据库字段允许为 NULL」的。**
> 如果字段在数据库中可能为 `NULL`，**直接用 `string` 是不严谨、甚至是错误的**。

下面我从**原理 → 对比 → 何时必须用 → 推荐实践**四个层次说明。

---
<br/>

**数据库中的三种状态**

在数据库里，一个字段可以是：

| 状态      | 含义   |
| ------- | ---- |
| `NULL`  | 没有值  |
| `''`    | 空字符串 |
| `'abc'` | 有值   |

而在 Go 中：

```go
string
```

**只有两种状态：**

* 空字符串 `""`
* 非空字符串 `"abc"`

👉 **Go 的 `string` 无法表达 “NULL”**

---
<br/> 

**`sql.NullString` 是什么？**

源码（简化）：

```go
type NullString struct {
    String string
    Valid  bool
}
```

含义：

| 字段       | 说明        |
| -------- | --------- |
| `String` | 实际字符串值    |
| `Valid`  | 是否为非 NULL |

<br/>

- **行为示例**

| 数据库字段值  | Go 结构体                                     |
| ------- | ------------------------------------------ |
| `NULL`  | `sql.NullString{String:"", Valid:false}`   |
| `''`    | `sql.NullString{String:"", Valid:true}`    |
| `'abc'` | `sql.NullString{String:"abc", Valid:true}` |

👉 **NULL 和空字符串被严格区分开了**

---
<br/>

**如果用 `string` 会发生什么？**

- 1️⃣ 查询时的隐性错误

假设数据库：

```sql
email VARCHAR(255) NULL
```

你用：

```go
Email string
```

查询 `NULL` 时：

```go
Email == ""
```

问题来了：

* 你 **不知道**：
	* 是用户真的填了 `""`
	* 还是数据库是 `NULL`


<br/>

- **2️⃣ 扫描时可能直接报错（视驱动而定）**

某些 driver 在扫描 `NULL` 到 `string` 时会报：

```text
sql: Scan error on column index X: converting NULL to string is unsupported
```

---
<br/>

**什么时候必须用 `sql.NullString`？**

| 场景                    | 原因          |
| --------------------- | ----------- |
| 数据库字段允许 `NULL`        | Go 需要能表达    |
| 业务上区分「未填写」与「空值」       | `NULL ≠ ""` |
| 通用 DAO / Repository 层 | 数据语义必须准确    |

你的例子：

```go
Email sql.NullString
Phone sql.NullString
```

---
<br/>

- **什么时候可以用 `string`？**

**数据库层必须保证：**

```sql
email VARCHAR(255) NOT NULL DEFAULT ''
```

- **并且：**
	* 业务允许用 `""` 表示“无”
	* 永远不关心 `NULL`

---
<br/>


**业务层怎么用 `sql.NullString` 才不别扭？**

- **1️⃣ 判断是否存在值**

```go
if user.Email.Valid {
    fmt.Println(user.Email.String)
}
```

<br/>

- **2️⃣ 设置值**

```go
user.Email = sql.NullString{
    String: "a@b.com",
    Valid:  true,
}
```
<br/>

- **3️⃣ 设置为 NULL**

```go
user.Email = sql.NullString{
    Valid: false,
}
```

---
<br/>

**进阶：为什么不用 `*string`？**

你可能会问：

> 那我用 `*string` 不也能表示 NULL 吗？

答案：**可以，但不推荐在 DB 层**

原因：

| 对比                  | `*string` | `sql.NullString` |
| ------------------- | --------- | ---------------- |
| 是否语义清晰              | 一般        | ✅ 非常清晰           |
| 是否 DB 标准            | ❌         | ✅                |
| 与 `database/sql` 集成 | ❌         | ✅                |
| 批量扫描安全性             | 差         | 好                |



<br/><br/><br/>

***
<br/><br/>

> <h1 id="函数式选项模式">函数式选项模式</h1>

**简单Demo**

假设你有一个函数，想灵活地传入 `context`，但又不想每次调用都改函数签名。

- **1. 定义选项类型和配置结构**
  
```go
package main

import (
    "context"
    "fmt"
)

// RedisOption 是一个函数类型，用于修改 options
type RedisOption func(*options)

// 内部配置结构
type options struct {
    ctx context.Context
}

// WithContext 是一个“选项函数”，用于设置 context
func WithContext(ctx context.Context) RedisOption {
    return func(o *options) {
        o.ctx = ctx
    }
}
```
<br/>

- **2. 你的服务方法**
  
```go
type RedisService struct{}

func (r *RedisService) Delete(key string, opts ...RedisOption) {
    // 设置默认值
    opt := &options{
        ctx: context.Background(), // 默认 context
    }

    // 应用用户传入的选项
    for _, fn := range opts {
        fn(opt)
    }

    // 使用 context（这里只是打印）
    fmt.Printf("正在删除 key=%s，使用的 context: %v\n", key, opt.ctx)
}
```
<br/>

- **3. 调用方式**

```go
func main() {
    svc := &RedisService{}

    // 不传 context：使用默认 background
    svc.Delete("user:123")

    // 显式传入 context
    ctx := context.WithValue(context.Background(), "trace_id", "abc123")
    svc.Delete("user:456", WithContext(ctx))
}
```

<br/>

**输出示例：**

```sh
正在删除 key=user:123，使用的 context: context.Background
正在删除 key=user:456，使用的 context: context.Background.WithValue(...)
```

---
<br/>

**📌 为什么叫“函数式选项模式”？**

- 因为**每个配置项都是一个函数**（如 `WithContext`）。
- 这些函数**接收并修改配置结构体**。
- 调用时像“插件”一样组合多个函数：`Delete(key, WithContext(ctx), WithTimeout(...))`。
- 非常灵活、可读性强，且支持默认值。












