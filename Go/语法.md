<h2 id=''></h2>
- [基本语法与使用](#基本语法与使用)
	- [短变量](#短变量)
	- [指针](#指针)
	- [类型别名](#类型别名)
- [**容器：存储和组织数据的方式**](#容器：存储和组织数据的方式)
	- [数组](#数组)
	- [切片](#切片)
	- [Map(容器)](#Map(容器))
	- [列表list](#列表list)
- [**流程控制**](#流程控制)
	- [for循环](#for循环) 




<br/>

***
<br/>

> <h1 id='基本语法与使用'>基本语法与使用</h1>

<br/>

> <h2 id='短变量'>短变量</h2>

```
// 短变量声明并初始化
func lowVar() {
	fmt.Printf("\n\n <=============== 🍎 🍎 🍎 ===============> \n\n")

	// Go语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型
	// 注意：由于使用了“:=”，而不是赋值的“=”，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误。
	hp := 10

	// 注意：在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错
	conn, err := net.Dial("tcp", "127.0.0.1: 8080")
	conn2, err := net.Dial("tcp", "127.0.0.1: 8080")

	fmt.Printf("hp: %d, conn: %s, err: %s, conn2: %s", hp, conn, err, conn2)

}
```

打印：

```
<=============== 🍎 🍎 🍎 ===============> 

hp: 10, conn: %!s(<nil>), err: dial tcp 127.0.0.1:8080: connect: connection refused, conn2: %!s(<nil>)

```



<br/>
<br/>

> <h2 id='指针'>指针</h2>

```
// 从指针获取指针指向的值
func pointTest1() {
	fmt.Printf("\n\n <=============== 🍎 🍎 🍎 ===============> \n\n")

	var house string = "🏠房屋 366——26-404"

	ptr := &house

	fmt.Printf("ptr type: %T\n", ptr)
	fmt.Printf("address: %p\n", ptr)

	value := *ptr

	fmt.Printf("value type: %T\n", value)
	fmt.Printf("value: %s\n", value)
}
```

打印：

```
<=============== 🍎 🍎 🍎 ===============> 

ptr type: *string
address: 0x14000098550
value type: string
value: 🏠房屋 366——26-404
```


<br/>

指针地址的交换：变量值的交换Demo

```
// 函数的交换
func chargeValue() {
	fmt.Printf("\n\n <=============== 🍎 🍎 🍎 ===============> \n\n")

	// 准备两个变量，赋值1和2
	x, y := 1, 2
	// 交换变量值
	swap(&x, &y)

	fmt.Println(x, y)

}

func swap(a, b *int) {
	// 取a指针的值，赋给临时变量
	t := *a

	// 取b指针的值，赋给a指针指向的变量
	// 注意，此时“*a”的意思不是取a指针的值，而是“a指向的变量”
	*a = *b
	// 将a指针的值赋给b指针指向的变量
	*b = t
}
```

打印：

```
<=============== 🍎 🍎 🍎 ===============> 

2 1
```

总结：

&emsp; `“ * ”`操作符作为右值时，意义是取指针的值；作为左值时，也就是放在赋值操作符的左边时，表示a指向的变量。其实归纳起来，“*”操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值；当操作在左值时，就是将值设置给指向的变量


<br/>

```
// 使用指针变量获取命令行的输入信息
func point_flag() {
	// 定义命令行参数
	/*
	* 3个参数分别如下：
	* 参数名称：在给应用输入参数时，使用这个名称
	* 参数值的默认值：与flag所使用的函数创建变量类型对应，String对应字符串、Int对应整型、Bool对应布尔型等
	* 参数说明：使用-help时，会出现在说明中
	 */
	var mode = flag.String("mode", "🍊 🍊", "process mode")

	// 解析命令行参数
	flag.Parse()

	fmt.Println(*mode)
}


func main() {
	//fmt.Println("🍎 welcome to Go Lang! 🍎 ")

	point_flag()
}
```

这个函数main.go的文件中，在终端执行：

```
$  go run  ./main.go --mode=🍎 fast

// 或
$ go run  ./main.go 

```

分别打印为：

```
🍎fast

// 或
🍊 🍊
```


![go8](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/go8.png)




<br/>
<br/>


> <h2 id='类型别名'>类型别名</h2>

Go1.9版本之前内建内型定义：

```
type byte unit8

type rune int32
```

Go 1.9版本之后变为

```
type byte = unit8

type rune = int32
```

&emsp; 这个修改就是配合类型别名而进行的修改.


&emsp; 这个修改就是配合类型别名而进行的修改:

```
type Type Alias = type
```

&emsp; 类型别名规定：Type Alias只是Type的别名，本质上Type Alias与Type是同一个类型。


<br/>

***
<br/>

> <h1 id='容器：存储和组织数据的方式'>容器：存储和组织数据的方式</h1>


**介绍：**

&emsp; 变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器”。

<br/>
<br/>

> <h2 id='数组'>数组</h2>

> 初始化和遍历

```
// 初始化数组
func init_array() {
	fmt.Printf("\n\n <=============== 🍎 🍎 🍎 ===============> \n\n")

	var member = [...]string{"曹可馨", "是个", "放屁精🐳", "曹智宸", "是个", "调皮鬼😝", "李亚", "是个", "小螃蟹🦀️"}

	for k, v := range member {
		fmt.Println(k, v)

	}

}
```

打印：

```
 <=============== 🍎 🍎 🍎 ===============> 

0 曹可馨
1 是个
2 放屁精🐳
3 曹智宸
4 是个
5 调皮鬼😝
6 李亚
7 是个
8 小螃蟹🦀️

```




<br/>
<br/>

> <h2 id='切片'>切片</h2>

&emsp; Go语言切片的内部结构包含地址、大小和容量。切片一般用于快速地操作一块数据集合。如果将数据集合比作切糕的话，切片就是你要的“那一块”。切的过程包含从哪里开始（这个就是切片的地址）及切多大（这个就是切片的大小）。容量可以理解为装切片的口袋大小.

![go9](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/go9.png)

```
slice [开始位置:结束位置]
```

```
// 切片
func section_test() {
	fmt.Printf("\n\n <=============== 🍎 🍎 🍎 ===============> \n\n")

	var a = [4]int{10, 20, 30, 40}

	fmt.Println(a, "\n", a[1:3])
}

```

打印：

```
<=============== 🍎 🍎 🍎 ===============> 

[10 20 30 40] 
 [20 30]
```


从数组或切片生成新的切片拥有如下特性。

● 取出的元素数量为：结束位置-开始位置;

● 取出元素不包含结束位置对应的索引，切片最后一个元素使用slice[len(slice)]获取;

● 当缺省开始位置时，表示从连续区域开头到结束位置;

● 当缺省结束位置时，表示从开始位置到整个连续区域末尾;

● 两者同时缺省时，与切片本身等效;

● 两者同时为0时，等效于空切片，一般用于切片复位;

● 根据索引位置取切片slice元素值时，取值范围是（0～len(slice)-1），超界会报运行时错误。生成切片时，结束位置可以填写len(slice)但不会报错。




<br/>
<br/>

> <h2 id="Map(容器)">Map(容器)</h2>

&emsp; Go语言中map的定义是这样的：

```
map[Key Type]Value Type
```
● Key Type为键类型;

● Value Type是键对应的值类型;

一个map里，符合Key Type和Value Type的映射总是成对出现。


```
// map是一个内部实现的类型，使用时，需要手动使用make创建
scene := make(map[string]int)
	scene["route"] = 66
	fmt.Println(scene["route"])
	v := scene["route2"]

	fmt.Println(v)

	m := map[string]string{
		"W": "forward",
		"A": "left",
		"D": "right",
		"S": "backward",
	}

	// 切片的遍历
	for k, v := range m {
		fmt.Println(k, v)
	}
```


打印：

```
66
0
W forward
A left
D right
S backward

```




<br/>
<br/>


> <h2 id='列表list'>列表list</h2>

&emsp； 在Go语言中，将列表使用container/list包来实现，内部的实现原理是双链表。列表能够高效地进行任意位置的元素插入和删除操作。

&emsp; list的初始化有两种方法：New和声明。两种方法的初始化效果都是一致的。

通过声明初始化list:

```
var变量名list.List
```

<br/>

通过container/list包的New方法初始化list

```
变量名 := list.New()
```



<br/>

**列表的添加、删除、遍历**

```
// 导入
import (
	"container/list"
)



// 列表删除
func list_delete() {
	fmt.Printf("\n\n <=============== 🍎 🍎 🍎 ===============> \n\n")

	l := list.New()

	// 尾部添加
	l.PushBack("canon")
	// 头部添加
	l.PushFront(67)
	// 尾部添加后保存元素句柄
	element := l.PushBack("fist")
	// 在fist之后添加high
	l.InsertAfter("high", element)
	// 在fist之前添加noon
	l.InsertBefore("noon", element)
	// 使用
	l.Remove(element)

	for i := l.Front(); i != nil; i = i.Next() {
		fmt.Println(i.Value)
	}
}
```

打印：

```

 <=============== 🍎 🍎 🍎 ===============> 

67
canon
noon
high
```







<br/>

***
<br/>

> <h1 id='流程控制'>流程控制</h1>

<br/>
<br/>

> <h2 id='for循环'>for循环</h2>


**九九乘法表**

```
// 九九乘法表：
func multiplication_table() {

	fmt.Printf("\n\n <=============== 🍎 🍎 🍎 ===============> \n\n")

	// 遍历，决定处理第几行
	for y := 1; y <= 9; y++ {
		// 遍历，决定这一行有多少列
		for x := 1; x <= y; x++ {
			fmt.Printf("%d＊%d=%d ", x, y, x*y)
		}
		// 手动生成回车
		fmt.Println()
	}
}


```

打印：

```
<=============== 🍎 🍎 🍎 ===============> 

1＊1=1 
1＊2=2 2＊2=4 
1＊3=3 2＊3=6 3＊3=9 
1＊4=4 2＊4=8 3＊4=12 4＊4=16 
1＊5=5 2＊5=10 3＊5=15 4＊5=20 5＊5=25 
1＊6=6 2＊6=12 3＊6=18 4＊6=24 5＊6=30 6＊6=36 
1＊7=7 2＊7=14 3＊7=21 4＊7=28 5＊7=35 6＊7=42 7＊7=49 
1＊8=8 2＊8=16 3＊8=24 4＊8=32 5＊8=40 6＊8=48 7＊8=56 8＊8=64 
1＊9=9 2＊9=18 3＊9=27 4＊9=36 5＊9=45 6＊9=54 7＊9=63 8＊9=72 9＊9=81 

```




<br/>
<br/>
> <h2 id=''></h2>






<br/>

***
<br/>

> <h1 id=''></h1>

<br/>
<br/>
> <h2 id=''></h2>




<br/>
<br/>
> <h2 id=''></h2>





<br/>

***
<br/>

> <h1 id=''></h1>

<br/>
<br/>
> <h2 id=''></h2>




<br/>
<br/>
> <h2 id=''></h2>




<br/>

***
<br/>

> <h1 id=''></h1>

<br/>
<br/>
> <h2 id=''></h2>




<br/>
<br/>
> <h2 id=''></h2>



<br/>

***
<br/>

> <h1 id=''></h1>

<br/>
<br/>
> <h2 id=''></h2>




<br/>
<br/>
> <h2 id=''></h2>