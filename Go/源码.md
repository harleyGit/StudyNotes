- [**atomic.Value的底层实现**](#atomic.Value的实现)







<br/><br/><br/>

***
<br/>

> <h1 id="atomic.Value的实现">atomic.Value的实现</h1>

 **`atomic.Value` 是啥？**

Go 提供了一个特殊的容器：

```go
var v atomic.Value
v.Store("hello")
fmt.Println(v.Load()) // hello
```

它能存任意类型 (`any`)，并且保证 **并发安全**。
内部实现用到了 `unsafe` + 原子操作。

<br/>

**官方源码位置**

在 Go 源码里（`src/sync/atomic/value.go`），可以找到类似的定义：

```go
type Value struct {
    // 保存任意值
    v interface{}
}
```

但在 **更底层实现（Go runtime 或老版本源码）** 里，它其实会把接口拆开成 `typ` + `data`，就是你看到的 `efaceWords`。

<br/>

**`atomic.Value.Load()` 源码（简化版）**

在 Go 的 runtime/atomic 里，`Load` 大概长这样（伪代码，和你给的几乎一模一样）：

```go
type efaceWords struct {
    typ  unsafe.Pointer
    data unsafe.Pointer
}

func (v *Value) Load() (val any) {
    vp := (*efaceWords)(unsafe.Pointer(v))
    typ := LoadPointer(&vp.typ) // 原子读 type 指针
    if typ == nil || typ == unsafe.Pointer(&firstStoreInProgress) {
        // 还没有值
        return nil
    }
    data := LoadPointer(&vp.data) // 原子读 data 指针

    // 把 typ 和 data 写到返回值 val 的接口头里
    vlp := (*efaceWords)(unsafe.Pointer(&val))
    vlp.typ = typ
    vlp.data = data
    return
}
```

<br/>

**关键点**

* **为什么用 `efaceWords`？**
  因为 Go 的空接口 `interface{}` 在底层就是两个指针：`typ` + `data`。
  直接操作能避免 `reflect` 的开销。

* **为什么要 `LoadPointer`？**
  这是原子操作，避免并发场景下出现数据竞争。
  确保拿到的 `typ` 和 `data` 是一致的。

* **`firstStoreInProgress` 是啥？**
  一个内部标记值，用来区分“第一次写入还没完成”的情况。
  如果发现 `typ == firstStoreInProgress`，说明正在初始化，`Load` 就返回 `nil`。

* **最后一步干嘛？**
  它把 `typ` 和 `data` 填充到 `val` 这个返回值的接口结构里。
  这样 `val` 就变成真正的 Go 值（比如 string/int/struct），而不是走慢速反射。

<br/>

**小例子（等价逻辑）**

假设我们用伪代码来模拟 `atomic.Value` 的存取：

```go
var v atomic.Value

// 存储
v.Store(123)

// 底层大概做的事：
// v.typ = (*int 类型描述符)
// v.data = 指向 123 的内存地址

// 读取
x := v.Load()

// 底层大概做的事：
// 从 v.typ / v.data 取出来
// 构造一个新的 interface{} 值
// 返回 123
```

---

✅ **总结**
你给的那段 `Load` 函数，几乎就是 **`atomic.Value.Load` 的底层实现**。

* `efaceWords` → 模拟 interface{} 内存布局
* `LoadPointer` → 原子读，保证并发安全
* `firstStoreInProgress` → 避免读到未初始化的值
* 直接写 `val` 的 `typ/data` → 高效返回 `any`，绕过反射


