
> <h2 id=''></h2>
- [**包（package）**](#包（package）)
- [**并发**](#并发)
- [**通道**](#通道)
	- [带缓冲的通道](#带缓冲的通道)
	- [线程锁](#线程锁)
		- [互斥锁](#互斥锁)
		- [读写互斥锁](#读写互斥锁)
		- [等待组](#等待组)
- [**反射**](#反射)

<br/>

***
<br/>

> <h1 id='包（package）'>包（package）</h1>

&emsp; Go语言的源码复用建立在包（package）基础之上。Go语言的入口main()函数所在的包（package）叫main，main包想要引用别的代码，必须同样以包的方式进行引用，本章内容将详细讲解如何导出包的内容及如何导入其他包。

&emsp; Go语言的包与文件夹一一对应，所有与包相关的操作，必须依赖于工作目录（GOPATH）。

查看环境变量配置信息： **go env**

![10](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/go10.png)


<br/>

> **package规则如下：**

包要求在同一个目录下的所有文件的第一行添加如下代码，以标记该文件归属的包：

package包名包的特性如下：

● 一个目录下的同级文件归属一个包；

● 包名可以与其目录不同名；

● 包名为main的包为应用程序的入口包，编译源码没有main包时，将无法编译输出可执行的文件。


<br/>
<br/>

> **导出标识符——让外部访问包的类型和值**


&emsp; 如果想在一个包里引用另外一个包里的标识符（如类型、变量、常量等）时，必须首先将被引用的标识符导出，将要导出的标识符的首字母大写就可以让引用者可以访问这些标识符了。


下面的代码中包含一系列未导出标识符，它们的首字母都为小写，这些标识符可以在包内自由使用，但是包外无法访问它们，代码如下：

```
package my-pig
 var myVar = 100
 const myConst = "hello"
 type myStruct struct {

 }

```

将myConst和myStruct大写，导出这些标识符，如下：

```
package mypkg
 var myVar = 100
 const MyConst = "hello"
 type MyStruct struct {

	// 包外可以访问的字段
	Exported Field int 


	// 仅限包内访问的字段
	private Field int
    
}
```


<br/>
<br/>

> <h2 id=''></h2>










<br/>

***
<br/>

> <h1 id='并发'>并发</h1>

&emsp; 在编写Socket网络程序时，需要提前准备一个线程池为每一个Socket的收发包分配一个线程。开发人员需要在线程数量和CPU数量间建立一个对应关系，以保证每个任务能及时地被分配到CPU上进行处理，同时避免多个任务频繁地在线程间切换执行而损失效率。

&emsp; 虽然，线程池为逻辑编写者提供了线程分配的抽象机制。但是，如果面对随时随地可能发生的并发和线程处理需求，线程池就不是非常直观和方便了。能否有一种机制：使用者分配足够多的任务，系统能自动帮助使用者把任务分配到CPU上，让这些任务尽量并发运作。这种机制在Go语言中被称为goroutine。

&emsp; goroutine的概念类似于线程，但goroutine由Go程序运行时的调度和管理。Go程序会智能地将goroutine中的任务合理地分配给每个CPU。

<br/>
<br/>

> <h2 id='轻量级线程'>轻量级线程</h2>

`runtime.GOMAXPROCS(逻辑CPU数量)`

逻辑CPU数量可以有如下几种数值：

● <1：不修改任何数值。

● =1：单核心执行。

● >1：多核并发执行。

`runtime.NumCPU()`： 查询CPU数量





<br/>
<br/>

> <h2 id=''></h2>




<br/>

***
<br/>

> <h1 id='通道'>通道</h1>

通道的元素类型就是在其内部传输的数据类型，声明如下：

**var 通道变量** 

**chan 通道类型**

● 通道类型：通道内的数据类型；

● 通道变量：保存通道的变量。

chan类型的空值是nil，声明后需要配合make后才能使用。


<br/>



> 创建通道

通道是引用类型，需要使用make进行创建，格式如下：

```
通道实例 := make(chan数据类型)
```

● 数据类型：通道内传输的元素类型。

● 通道实例：通过make创建的通道句柄。


```
1 := make(chan int)            // 创建一个整型类型的通道
 ch2 := make(chan interface{})  // 创建一个空接口类型的通道，可以存放任意格式
 type Equip struct{ /＊ 一些字段 ＊/ }
 ch2 := make(chan ＊Equip)         // 创建Equip指针类型的通道，可以存放＊Equip
```


<br/>


> 通道发送数据


通道的发送使用特殊的操作符“<-”，

将数据通过通道发送的格式为：

`通道变量 <- 值`

● 通道变量：通过make创建好的通道实例。

● 值：可以是变量、常量、表达式或者函数返回值等。值的类型必须与ch通道的元素类型一致。

```
// 创建一个空接口通道
 ch := make(chan interface{})
 // 将0放入通道中
 ch <-0
 // 将hello字符串放入通道中
 ch <- "hello"
```


<br/>


> **通道接收数据特性**

通道接收同样使用“<-”操作符，通道接收有如下特性：

● 通道的收发操作在不同的两个goroutine间进行。

由于通道的数据在没有接收方处理时，数据发送方会持续阻塞，因此通道的接收必定在另外一个goroutine中进行。

● 接收将持续阻塞直到发送方发送数据。

如果接收方接收时，通道中没有发送方发送数据，接收方也会发生阻塞，直到发送方发送数据为止。

● 每次接收一个元素。通道一次只能接收一个数据元素。


<br/>

通道接收数据有4种写法：

**1). 阻塞接受数据：将接收变量作为“<-”操作符的左值**

```
data := <- ch
```

<br/>

**2). 非阻塞接收数据**

```
data, ok := <- ch
```

&emsp; data：表示接收到的数据。未接收到数据时，data为通道类型的零值。● ok：表示是否接收到数据。非阻塞的通道接收方法可能造成高的CPU占用，因此使用非常少。如果需要实现接收超时检测，可以配合select和计时器channel进行。


<br/>

**3). 接收任意数据，忽略接收的数据:阻塞接收数据后，忽略从通道返回的数据**

```
<-ch
```

执行该语句时将会发生阻塞，直到接收到数据，但接收到的数据会被忽略。这个方式实际上只是通过通道在goroutine间阻塞收发实现并发同步。

<br/>


4).循环接收

通道的数据接收可以借用for range语句进行多个元素的接收操作。

```
for data := range ch {

}
```


通道ch是可以进行遍历的，遍历的结果就是接收到的数据。数据类型就是通道的数据类型。通过for遍历获得的变量只有一个，即上面例子中的data。



<br/>
<br/>

> **单向通道**

声明格式:

只能发送的通道类型为chan<-，只能接收的通道类型为<-chan: 

```
// 只能发送通道
var 通道实例 chan <- 元素类型                      

// 只能接收通道
var 通道实例 <-chan 元素类型                      
```

● 元素类型：通道包含的元素类型。

● 通道实例：声明的通道变量。


```
// 声明一个只能发送的通道类型，并赋值为ch
ch := make(chan int)
var chSendOnly chan<- int = ch

//声明一个只能接收的通道类型，并赋值为ch
var chRecvOnly <-chan int = ch
```


<br/>
<br/>


> <h2 id='带缓冲的通道'> 带缓冲的通道</h2>

&emsp; 在无缓冲通道的基础上，为通道增加一个有限大小的存储空间形成带缓冲通道。带缓冲通道在发送时无需等待接收方接收即可完成发送过程，并且不会发生阻塞，只有当存储空间满时才会发生阻塞。同理，如果缓冲通道中有数据，接收时将不会发生阻塞，直到通道中没有数据可读时，通道将会再度阻塞。

&emsp; **提示：** 无缓冲通道保证收发过程同步。无缓冲收发过程类似于快递员给你电话让你下楼取快递，整个递交快递的过程是同步发生的，你和快递员不见不散。但这样做快递员就必须等待所有人下楼完成操作后才能完成所有投递工作。如果快递员将快递放入快递柜中，并通知用户来取，快递员和用户就成了异步收发过程，效率可以有明显的提升。带缓冲的通道就是这样的一个“快递柜”。

<br/>

> 创建带缓冲通道

`通道实例 := make(chan通道类型, 缓冲大小)`

● 通道类型：和无缓冲通道用法一致，影响通道发送和接收的数据类型。

● 缓冲大小：决定通道最多可以保存的元素数量。

● 通道实例：被创建出的通道实例。




<br/>

***
<br/>

> <h2 id='线程锁'>线程锁</h1>

<br/>

> 静态检测

```
/**
 * @description: 序列号生成器
 */

var (
	// 序列号
	seq int64
)

func testLock1() {
	//生成10个并发序列号
	for i := 0; i < 10; i++ {
		go GenID()
	}
	fmt.Println(GenID())
}
func GenID() int64 {
	// 尝试原子的增加序列号
	// 使用原子操作函数atomic.Add Int64()对seq()函数加1操作。
	// 不过这里故意没有使用atomic.Add Int64()的返回值作为Gen ID()函数的返回值，因此会造成一个竞态问题
	atomic.AddInt64(&seq, 1)
	return seq
}

```

在运行程序时，为运行参数加入“-race”参数，开启运行时（runtime）对竞态问题的分析，命令如下：`go run -race main.go`

![go11](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/go11.png)

根据报错信息是`atomic.AddInt64(&seq, 1)`有竞态问题，根据atomic.AddInt64()的参数声明，这个函数会将修改后的值以返回值方式传出。修改后如下：

```
func GenID() int64 {
	// 尝试原子的增加序列号
	return atomic.AddInt64(&seq, 1)
}

```

执行命令后输出：

```
go run -race main.go
<=============== 🍎 🍎 🍎 ===============> 

10


<=============== 🍑 🍑 🍑 ===============> %  
```

本例中只是对变量进行增减操作，虽然可以使用互斥锁（sync.Mutex）解决竞态问题，但是对性能消耗较大。


> <h3 id='互斥锁'>互斥锁</h3>

&emsp; **`（sync.Mutex）`**保证同时只有一个goroutine可以访问共享资源互斥锁是一种常用的控制共享资源访问的方法。




<br/>
<br/>

> <h3 id='读写互斥锁'>读写互斥锁</h3>


&emsp; **`（sync.RWMutex）`**在读比写多的环境下比互斥锁更高效

&emsp;在读多写少的环境中，可以优先使用读写互斥锁，sync包中的RWMutex提供了读写互斥锁的封装。





<br/>
<br/>

> <h3 id='等待组'>等待组</h3>

&emsp; **（sync.Wait Group）** 保证在并发环境中完成指定数量的任务

&emsp; 除了可以使用通道（channel）和互斥锁进行两个并发程序间的同步外，还可以使用等待组进行多个任务的同步。

![go12](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/go12.jpeg)

&emsp; 等待组内部拥有一个计数器，计数器的值可以通过方法调用实现计数器的增加和减少。当我们添加了N个并发任务进行工作时，就将等待组的计数器值增加N。每个任务完成时，这个值减1。同时，在另外一个goroutine中等待这个等待组的计数器值为0时，表示所有任务已经完成。


<br/>
<br/>

> <h2 id=''></h2>


<br/>

***
<br/>

> <h1 id='反射'>反射</h1>





<br/>
<br/>

> <h2 id=''></h2>




<br/>
<br/>

> <h2 id=''></h2>



<br/>
<br/>




