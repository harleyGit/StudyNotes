> # **企业数据库生命管理**
- [**规范铁律**](#规范铁律)
- [工程架构总览](工程架构总览)
- [CRUD理解](#CRUD理解)
- [工程中使用xxx.sql文件](#工程中使用xxx.sql文件)

<br/><br/><br/>

***
<br/>

> <h1 id= "规范铁律">规范铁律</h1>

> **在中大型企业中❓❗️：**
>
> * **🚫⭕️数据库 / 表结构：不由业务代码创建**
> * **❌ 不在运行时判断表是否存在**
> * **❌ 不在插入数据前检查字段是否存在**
> * **✅ 统一通过 SQL 迁移（Migration）或 DBA / DevOps 流程管理**
> * **✅ 业务代码只“使用”表，不“管理”表**

这是**铁律级规范**。

---
<br/>

**数据库 & 表是谁创建的？**

**1️⃣ 三种常见模式（从小到大）**

| 公司规模          | 建库建表方式                       |
| ------------- | ---------------------------- |
| 个人 / Demo     | 手动在终端执行 SQL                  |
| 初创公司          | SQL 脚本 + 项目初始化               |
| **中大型企业（推荐）** | **数据库迁移系统（Migration）+ 审批流程** |

---
<br/>

**2️⃣ 中大型企业标准模式**

**❌ 错误做法**

```go
db.Exec("CREATE TABLE IF NOT EXISTS users (...)")
```

**✅ 正确做法**

* 建库、建表 **只通过 SQL 文件**
* **由 DBA / DevOps / 后端负责人执行**
* 或由 **自动化迁移工具执行（但不是业务代码）**

---
<br/>

**数据库生命周期的标准流程**

**① 项目初始化阶段（第一次）**

**步骤如下：**

```
1. 后端定义表结构（users、orders、logs…）
2. 编写 SQL 初始化脚本
3. SQL 脚本进入 Git 仓库
4. 执行脚本创建库 & 表
5. 业务代码只负责 CRUD
```
<br/>

**一般工程目录结构**

```text
project/
├── cmd/
├── internal/
│   ├── handler/
│   ├── service/
│   ├── repository/
├── migrations/
│   ├── 001_init.sql
│   ├── 002_add_user_index.sql
│   └── 003_add_email_unique.sql
├── go.mod
```

<br/>

**② migrations/001_init.sql**

```sql
CREATE DATABASE IF NOT EXISTS app_db
  DEFAULT CHARSET utf8mb4
  COLLATE utf8mb4_unicode_ci;

USE app_db;

CREATE TABLE users (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  email VARCHAR(128) NOT NULL,
  phone VARCHAR(32),
  password_hash VARCHAR(255) NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY uk_email (email),
  UNIQUE KEY uk_phone (phone)
);
```

**注意：**

* 这里只执行一次
* 不在 Go 程序中运行

<br/>

**上线后：表结构变更怎么做？**

**❌ 错误认知（很多新手会犯）**

> “我插入用户前，先检查 users 表在不在？”

这是**严重错误的设计思想**。

---
<br/>

**正确做法：数据库迁移（Schema Migration）**

**举例：给 users 表新增 avatar 字段**

**新增一个 SQL 文件：**

```sql
-- migrations/004_add_avatar_to_users.sql
ALTER TABLE users ADD COLUMN avatar VARCHAR(255) AFTER password_hash;
```

- **执行方式**
	* 本地开发：手动执行或迁移工具
	* 测试环境：CI 自动执行
	* 生产环境：审批后执行

---
<br/>

**是否要在代码中检查「表 / 字段是否存在」？**

**结论：绝对不做**

**原因（非常重要）**

**1️⃣ 性能问题**

* 每次 INSERT 前查 information_schema？
* 高并发下直接把 DB 打爆

<br/> 

**2️⃣ 并发不安全**

```text
线程 A：发现表不存在
线程 B：发现表不存在
两个同时 CREATE TABLE → 崩溃
```

<br/> 

**3️⃣ 职责严重混乱（这是架构问题）**

| 层            | 职责        |
| ------------ | --------- |
| DBA / DevOps | 管理 schema |
| Migration    | 演进表结构     |
| 业务代码         | 只负责业务逻辑   |

<br/>

**4️⃣ 真实企业态度**

> **“如果表不存在，程序就应该直接启动失败”**

因为：

* 这是**部署问题**
* 不是运行时问题

---
<br/>

**那 Go 程序如何保证「数据库是对的」？**

**标准做法：启动时健康检查（Health Check）**

**示例**

```go
func CheckDB(db *sql.DB) error {
    _, err := db.Exec("SELECT 1 FROM users LIMIT 1")
    return err
}
```

* 程序启动即校验
* 有问题直接 panic / 退出
* Kubernetes / Supervisor 重启

---
<br/>

**企业级推荐数据库管理方式**

**1️⃣ 数据库权限隔离（非常重要）**

| 用户       | 权限                                |
| -------- | --------------------------------- |
| app_user | SELECT / INSERT / UPDATE / DELETE |
| migrator | CREATE / ALTER                    |
| root     | DBA 使用                            |

**生产环境中：**

* Go 程序 **绝不会** 用 root 用户

<br/>

**2️⃣ 数据库变更流程（真实企业）**

```text
需求 → 设计评审
    → SQL 变更脚本
    → DBA 审核
    → 测试环境执行
    → 灰度 / 生产执行
```

<br/>

**3️⃣ 是否允许自动建表？**

| 环境     | 是否允许     |
| ------ | -------- |
| 本地开发   | 可选       |
| 测试     | 可        |
| **生产** | **绝对禁止** |

---
<br/>

**ORM / 自动建表怎么看？**

**GORM 的 AutoMigrate()**

| 场景        | 建议   |
| --------- | ---- |
| Demo      | 可以   |
| 小项目       | 勉强   |
| **中大型企业** | ❌ 禁止 |

原因：

* 无法回滚
* 不可控
* 生产事故源头之一

---
<br/>

**现在应该怎么做？（给你一条清晰路线）**

- **阶段 1（你当前）**
	* 手写 SQL
	* 手动创建库表
	* 业务代码只写 CRUD

<br/>

- **阶段 2**
	* 引入 migrations 目录
	* 所有表结构变化用 SQL 文件记录

<br/>

- **阶段 3**
	* 使用迁移工具（golang-migrate / goose 等）
	* CI 自动校验

---
<br/>

**认知总结:**

> 1️⃣ **表结构不是业务代码的职责**
> 2️⃣ **数据库变更必须可审计、可回滚**
> 3️⃣ **程序假设数据库一定正确，否则直接失败**
> 4️⃣ **任何运行时建表逻辑，都是技术债**


<br/><br/><br/>

***
<br/>

> <h1 id= "工程架构总览">工程架构总览</h1>

```go
go-user-service/
├── cmd/
│   └── server/
│       └── main.go           // 程序入口
│
├── internal/
│   ├── config/               // 配置加载
│   │   └── config.go
│   │
│   ├── db/                   // 数据库初始化
│   │   └── mysql.go
│   │
│   ├── model/                // 数据结构（纯 struct）
│   │   └── user.go
│   │
│   ├── repository/           // 数据访问层（DAO）
│   │   └── user_repository.go
│   │
│   ├── service/              // 业务逻辑层
│   │   └── user_service.go
│   │
│   ├── handler/              // HTTP 接口层
│   │   └── user_handler.go
│   │
│   └── middleware/           // 中间件
│       └── auth.go
│
├── migrations/               // 数据库迁移（核心）
│   ├── 001_init.sql
│   └── 002_add_user_index.sql
│
├── go.mod
└── README.md
```

<br/>

**数据库迁移（Migration）——第一原则**

**1️⃣ migrations/001_init.sql（初始化表）**

```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(128) NOT NULL,
    phone VARCHAR(32),
    password_hash VARCHAR(255) NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_email (email),
    UNIQUE KEY uk_phone (phone)
);

```

- **规则（必须牢记）**
	- 只新增，不修改旧文件
	- 每次变更一个新 SQL
	- SQL 永久存 Git

<br/>

**执行迁移（企业级做法）**
本地 / 测试

```sql
mysql -u root -p app_db < migrations/001_init.sql
```
- **生产**
	- DBA / CI / 迁移工具执行
	- Go 程序 绝不执行建表 SQL


<br/><br/><br/>

***
<br/>

> <h1 id= "CRUD理解">CRUD理解</h1>

**CRUD 是后端开发中最基础、最核心的一组数据操作模型。**

它是下面四个英文单词的缩写：

| 缩写 | 全称     | 中文含义    |
| -- | ------ | ------- |
| C  | Create | 创建 / 新增 |
| R  | Read   | 读取 / 查询 |
| U  | Update | 更新 / 修改 |
| D  | Delete | 删除      |

**可以理解为：对数据库中一张表，能做的所有基础操作。**

<br/>

**用「用户表」来直观理解 CRUD**

假设你有一张 `users` 表。

**1️⃣ Create（新增用户）**

```sql
INSERT INTO users (email, phone, password_hash)
VALUES ('a@b.com', '13800000000', 'xxx');
```

👉 注册用户、本质就是 **Create**

<br/>

**2️⃣ Read（查询用户）**

```sql
SELECT * FROM users WHERE email = 'a@b.com';
```

👉 登录校验、查用户信息，都是 **Read**

<br/>

**3️⃣ Update（更新用户）**

```sql
UPDATE users SET password_hash = 'newhash'
WHERE id = 1;
```

👉 修改密码、更新头像，都是 **Update**

<br/>

**4️⃣ Delete（删除用户）**

```sql
DELETE FROM users WHERE id = 1;
```

👉 注销账号、封号，本质是 **Delete**

---
<br/>

**CRUD 在代码中的体现**

在**企业级 Go 项目**中，CRUD **通常只存在于 Repository（数据访问层）**。

**示例：UserRepository 中的 CRUD**

```go
type UserRepository struct {
    db *sql.DB
}

// C
func (r *UserRepository) Create(ctx context.Context, u *model.User) error

// R
func (r *UserRepository) GetByEmail(ctx context.Context, email string) (*model.User, error)

// U
func (r *UserRepository) UpdatePassword(ctx context.Context, id int64, hash string) error

// D
func (r *UserRepository) DeleteByID(ctx context.Context, id int64) error
```

> **关键认知：**
>
> * Repository = CRUD
> * Service = 业务规则
> * Handler = HTTP 协议

---
<br/> 

**CRUD 和你前面学的「分层架构」怎么对应？**

| 层              | 是否直接写 CRUD | 职责           |
| -------------- | ---------- | ------------ |
| Handler        | ❌          | 参数解析、返回 HTTP |
| Service        | ❌          | 业务规则、流程控制    |
| Repository     | ✅          | 直接操作数据库      |
| DB / Migration | ❌          | 表结构管理        |

---
<br/>

**为什么 CRUD 这么重要？**

**1️⃣ 所有业务最终都会落到 CRUD**

* 注册 → Create
* 登录 → Read
* 修改资料 → Update
* 注销账号 → Delete

**你做 10 年后端，90% 的业务仍然是 CRUD。**

---

**2️⃣ CRUD 是区分“会写代码”和“会做系统”的分水岭**

新手常见误区：

```go
func Register(w http.ResponseWriter, r *http.Request) {
    db.Exec("INSERT INTO users ...")
}
```

这是 **“能跑，但不专业”**。

企业级写法：

```text
Handler → Service → Repository → DB
```

这是 **“能长期维护的系统”**。

---
<br/>

**一个非常重要的补充（认知升级）**

> **CRUD ≠ 直接写 SQL**

CRUD 是一种 **抽象概念**：

* SQL
* ORM
* RPC
* 微服务调用

都只是 CRUD 的不同实现方式。

---
<br/>

**记住这三句话：**

1️⃣ **CRUD 只出现在 Repository 层**
2️⃣ **Service 永远不直接操作数据库**
3️⃣ **Handler 永远不知道 SQL 长什么样**


<br/><br/><br/>

***
<br/>

> <h1 id= "工程中使用xxx.sql文件">工程中使用xxx.sql文件</h1>

**❓问：** `.sql` 文件写好了，在 Go 工程中，究竟如何执行它来创建库和表？”

- **回答：** 中大型企业中：
	- ❌ Go 业务程序 不会 自动执行 xx.sql
	- ✅ SQL 脚本是 通过独立步骤 / 工具 / 流水线执行的
	- ✅ Go 工程只“依赖结果”，不“参与执行”

也就是说：

**“在 Go 工程生命周期里执行，但不是由 Go 程序运行时执行。”**

在企业中有这**[4种对库和表的管理执行方式](./数据库SQL库.md#数据库&表执行方式])**




