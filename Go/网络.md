> <h1 id=""></h1>
- [ä¼ è¾“å±‚](#ä¼ è¾“å±‚)
	- [http.Transport](#http.Transport)
	- [ç½‘ç»œè¿æ¥å·¥å…·net.Dialer](#ç½‘ç»œè¿æ¥å·¥å…·net.Dialer)
		- [TCPè¿æ¥è§„åˆ™DialContext](#TCPè¿æ¥è§„åˆ™DialContext)
		- [TCPåœ°å€åˆ¤æ–­](#TCPåœ°å€åˆ¤æ–­)
		- [ç½‘ç»œåœ°å€ç±»å‹](#ç½‘ç»œåœ°å€ç±»å‹)
	- [net.Dialerå¸¸ç”¨å­—æ®µé€ŸæŸ¥è¡¨](#net.Dialerå¸¸ç”¨å­—æ®µé€ŸæŸ¥è¡¨)
- [GETã€POSTã€PUT(update)ã€DELETEè¯·æ±‚](#GETã€POSTã€PUT(update)ã€DELETEè¯·æ±‚)
	- [GETå–å‚æ•°](#GETå–å‚æ•°) 
	- [POSTã€PUTå–å‚æ•°](#POSTã€PUTå–å‚æ•°) 
	- [DELETEå–å‚æ•°æ–¹å¼](#DELETEå–å‚æ•°æ–¹å¼)
- [ç½‘ç»œå®‰å…¨](#ç½‘ç»œå®‰å…¨)
	- [è¯ä¹¦ç­¾åå¸¸ç”¨æ¦‚å¿µ](#è¯ä¹¦ç­¾åå¸¸ç”¨æ¦‚å¿µ)
	- [ç”Ÿäº§å®‰å…¨å»ºè®®](#ç”Ÿäº§å®‰å…¨å»ºè®®)
	- [ç”Ÿæˆè‡ªç­¾ CAã€ç­¾å‘ server/clientè¯ä¹¦ï¼ˆOpenSSLï¼‰](#ç”Ÿæˆè‡ªç­¾CAã€ç­¾å‘server/clientè¯ä¹¦ï¼ˆOpenSSLï¼‰)
	- [å‡çº§ï¼šä»£ç ç”Ÿæˆè‡ªç­¾åTLSè¯ä¹¦å’Œæ”¯æŒè¯ä¹¦çƒ­é‡è½½](#å‡çº§ï¼šä»£ç ç”Ÿæˆè‡ªç­¾åTLSè¯ä¹¦å’Œæ”¯æŒè¯ä¹¦çƒ­é‡è½½)
	- [åŠ å¯†å’ŒéåŠ å¯†ç›‘å¬](#åŠ å¯†å’ŒéåŠ å¯†ç›‘å¬)
- [å¹¶å‘å®‰å…¨](#å¹¶å‘å®‰å…¨)
	- [å®‰å…¨ä¿å­˜å¤šä¸ªå®¢æˆ·ç«¯é“¾æ¥](#å®‰å…¨ä¿å­˜å¤šä¸ªå®¢æˆ·ç«¯é“¾æ¥)





<br/><br/><br/>

***
<br/>

> <h1 id="ä¼ è¾“å±‚">ä¼ è¾“å±‚</h1>

***
<br/><br/><br/>
> <h2 id="http.Transport">http.Transport</h2>


```go
&http.Transport{
    DialContext: (&net.Dialer{
        ...
    }).DialContext,
}
```

æ˜¯ Go é‡Œ HTTP å®¢æˆ·ç«¯ **è‡ªå®šä¹‰ç½‘ç»œè¿æ¥è¡Œä¸º**çš„å†™æ³•ã€‚

<br/>
 
 **`http.Transport`**

* `http.Transport` æ˜¯ Go `net/http` åŒ…é‡Œè´Ÿè´£ **HTTP è¯·æ±‚ä¼ è¾“å±‚**çš„ç»“æ„ä½“ã€‚
* å®ƒå†³å®šäº†ï¼š
	* æ€ä¹ˆå»ºç«‹ TCP è¿æ¥
	* æ€ä¹ˆåšè¿æ¥æ± å¤ç”¨
	* æ˜¯å¦æ”¯æŒ TLS/ä»£ç†
	* è¶…æ—¶ç­–ç•¥ç­‰

é€šå¸¸ä¼šé…åˆ `http.Client` ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š

```go
client := &http.Client{
    Transport: &http.Transport{
        // è‡ªå®šä¹‰è§„åˆ™å†™åœ¨è¿™é‡Œ
    },
}
```

***
<br/><br/><br/>
> <h2 id="ç½‘ç»œè¿æ¥å·¥å…·net.Dialer">ç½‘ç»œè¿æ¥å·¥å…·net.Dialer</h2>


* `net.Dialer` æ˜¯ Go é‡Œç”¨äºå»ºç«‹ç½‘ç»œè¿æ¥çš„å·¥å…·ï¼Œèƒ½è®¾ç½®å¾ˆå¤šåº•å±‚é€‰é¡¹ï¼Œä¾‹å¦‚ï¼š

	* `Timeout`ï¼šæ•´ä½“æ‹¨å·è¶…æ—¶æ—¶é—´
	* `KeepAlive`ï¼šTCP ä¿æ´»æ—¶é—´
	* `LocalAddr`ï¼šæŒ‡å®šæœ¬åœ° IP/ç«¯å£
	* `DualStack`ï¼šIPv4/IPv6 é€‰æ‹©

ä¾‹å¦‚ï¼š

```go
dialer := &net.Dialer{
    Timeout:   5 * time.Second,
    KeepAlive: 30 * time.Second,
}
```


<br/><br/>
> <h3 id="TCPè¿æ¥è§„åˆ™DialContext">TCPè¿æ¥è§„åˆ™DialContext</h3>

`DialContext`

* `net.Dialer` æœ‰ä¸ªæ–¹æ³• `DialContext(ctx, network, address)`ï¼Œå¯ä»¥å»ºç«‹ç½‘ç»œè¿æ¥ï¼Œå¹¶æ”¯æŒå–æ¶ˆ/è¶…æ—¶æ§åˆ¶ã€‚
* `http.Transport` çš„å­—æ®µ **`DialContext`** éœ€è¦ä¸€ä¸ªå‡½æ•°ç­¾åï¼š

```go
func(ctx context.Context, network, addr string) (net.Conn, error)
```

* æŠŠ `net.Dialer.DialContext` èµ‹å€¼ç»™ `http.Transport.DialContext`ï¼Œç­‰äºå‘Šè¯‰ HTTP å®¢æˆ·ç«¯ï¼š
  ğŸ‘‰ã€Œä»¥åæ‰€æœ‰ TCP è¿æ¥çš„å»ºç«‹ï¼Œéƒ½ç”¨æˆ‘è¿™ä¸ª dialer çš„è§„åˆ™æ¥åšã€‚ã€

<br/>

```go
dialer := &net.Dialer{
    Timeout:   5 * time.Second,   // å»ºç«‹è¿æ¥çš„è¶…æ—¶æ—¶é—´
    KeepAlive: 30 * time.Second,  // TCPä¿æ´»
}

transport := &http.Transport{
    DialContext: dialer.DialContext, // ç”¨ dialer æ¥å»ºç«‹è¿æ¥
}

client := &http.Client{
    Transport: transport,
    Timeout:   10 * time.Second,     // æ•´ä¸ªè¯·æ±‚è¶…æ—¶æ—¶é—´
}

resp, err := client.Get("https://example.com")
```

è¿™é‡Œï¼š

* **æ‹¨å·è¶…æ—¶**ï¼š5 ç§’å†…è¿ä¸ä¸ŠæœåŠ¡å™¨å°±æŠ¥é”™ã€‚
* **HTTP è¯·æ±‚è¶…æ—¶**ï¼šæ•´ä¸ªè¯·æ±‚ï¼ˆåŒ…æ‹¬å»ºç«‹è¿æ¥ã€å‘åŒ…ã€æ”¶åŒ…ï¼‰è¶…è¿‡ 10 ç§’å°±å¤±è´¥ã€‚

<br/>


âœ… **æ€»ç»“**
`&http.Transport{ DialContext: (&net.Dialer{...}).DialContext }`
å°±æ˜¯åœ¨å‘Šè¯‰ Go çš„ HTTP å®¢æˆ·ç«¯ï¼š**ç”¨è‡ªå®šä¹‰çš„ dialer æ¥å»ºç«‹ TCP è¿æ¥**ï¼Œè¿™æ ·å¯ä»¥ç²¾ç»†æ§åˆ¶è¿æ¥è¶…æ—¶ã€IP ç­–ç•¥ã€ä¿æ´»ç­‰ã€‚


***
<br/><br/><br/>
> <h2 id="TCPåœ°å€åˆ¤æ–­">TCPåœ°å€åˆ¤æ–­</h2>

`net.SplitHostPort` æ˜¯ Go **æ ‡å‡†åº“ net åŒ…** é‡Œçš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥æŠŠ `"ä¸»æœº:ç«¯å£"` è¿™æ ·çš„å­—ç¬¦ä¸²æ‹†å¼€ã€‚

<br/>

```go
host, port, err := net.SplitHostPort(addr string)
```

* `addr`ï¼šè¦è§£æçš„åœ°å€å­—ç¬¦ä¸²ï¼Œæ¯”å¦‚ `"127.0.0.1:8080"`ã€`"[::1]:80"`ã€‚
* `host`ï¼šè¿”å›ä¸»æœºéƒ¨åˆ†ï¼ˆIPã€åŸŸåï¼Œæˆ–è€… IPv6 è¦å¸¦ `[]` æ—¶ä¼šå»æ‰ï¼‰ã€‚
* `port`ï¼šè¿”å›ç«¯å£éƒ¨åˆ†ã€‚
* `err`ï¼šå¦‚æœ `addr` æ ¼å¼ä¸ç¬¦åˆ `"host:port"`ï¼Œä¼šè¿”å›é”™è¯¯ã€‚

<br/>

```go
package main

import (
	"fmt"
	"net"
)

func main() {
	h, p, err := net.SplitHostPort("127.0.0.1:8080")
	fmt.Println(h, p, err) // è¾“å‡º: 127.0.0.1 8080 <nil>

	h, p, err = net.SplitHostPort("[::1]:443")
	fmt.Println(h, p, err) // è¾“å‡º: ::1 443 <nil>

	// é”™è¯¯ç¤ºä¾‹
	h, p, err = net.SplitHostPort("localhost")
	fmt.Println(h, p, err) // è¾“å‡º:   net.SplitHostPort: missing port in address
}
```

***
<br/><br/><br/>
> <h2 id="ç½‘ç»œåœ°å€ç±»å‹">ç½‘ç»œåœ°å€ç±»å‹</h2>


Go çš„ `net` åŒ…é‡Œï¼Œå¸¸è§çš„åœ°å€ç±»å‹æœ‰ï¼š

* **`net.Addr`**
  æŠ½è±¡æ¥å£ï¼Œè¡¨ç¤ºä¸€ä¸ªç½‘ç»œç«¯ç‚¹åœ°å€ã€‚æ¯”å¦‚ï¼š
	
	* TCP åœ°å€ï¼š`*net.TCPAddr`
	* UDP åœ°å€ï¼š`*net.UDPAddr`
	* Unix åŸŸå¥—æ¥å­—åœ°å€ï¼š`*net.UnixAddr`

* **`*net.TCPAddr`**
  å…·ä½“å®ç°ï¼Œè¡¨ç¤ºä¸€ä¸ª TCP åœ°å€ã€‚åŒ…å«ï¼š

  ```go
  type TCPAddr struct {
      IP   IP
      Port int
      Zone string // IPv6 ä½œç”¨åŸŸï¼Œå¯å¿½ç•¥
  }
  ```

<br/>

**ç¤ºä¾‹**

å‡è®¾ `RealHTTPAddr` è¿”å›çš„æ˜¯ `127.0.0.1:8080`ï¼Œ`RealTCPAddr` è¿”å› `192.168.1.100:5000`ï¼š

```go
package main

import (
    "fmt"
    "net"
)

func main() {
    var httpAddr net.Addr = &net.TCPAddr{IP: net.ParseIP("127.0.0.1"), Port: 8080}
    var tcpAddr net.Addr = &net.TCPAddr{IP: net.ParseIP("192.168.1.100"), Port: 5000}

    if addr, ok := httpAddr.(*net.TCPAddr); ok {
        fmt.Printf("HTTP Addr: %s:%d\n", addr.IP, addr.Port)
    }

    if addr, ok := tcpAddr.(*net.TCPAddr); ok {
        fmt.Printf("TCP Addr: %s:%d\n", addr.IP, addr.Port)
    }
}
```

è¾“å‡ºï¼š

```
HTTP Addr: 127.0.0.1:8080
TCP Addr: 192.168.1.100:5000
```

<bt/>

âœ… **æ€»ç»“**

* `n.RealHTTPAddr()` / `n.RealTCPAddr()` è¿”å›ä¸€ä¸ª `net.Addr` æ¥å£ï¼Œä»£è¡¨èŠ‚ç‚¹çš„ä¸åŒç½‘ç»œåœ°å€
* `.(*net.TCPAddr)` æ˜¯**ç±»å‹æ–­è¨€**ï¼ŒæŠŠæ¥å£å€¼è½¬æ¢ä¸ºå…·ä½“ TCP åœ°å€ç±»å‹
* `ok` ç”¨äºåˆ¤æ–­æ˜¯å¦çœŸçš„èƒ½è½¬æˆ TCP åœ°å€ï¼Œé˜²æ­¢è¿è¡Œæ—¶å´©æºƒ
* è¿™æ ·å†™çš„ç›®çš„å°±æ˜¯èƒ½è·å– **å…·ä½“çš„ IP å’Œç«¯å£** æ¥åšç½‘ç»œæ“ä½œ


***
<br/><br/><br/>
> <h2 id="net.Dialerå¸¸ç”¨å­—æ®µé€ŸæŸ¥è¡¨">net.Dialerå¸¸ç”¨å­—æ®µé€ŸæŸ¥è¡¨</h2>

 **`net.Dialer` é€ŸæŸ¥è¡¨**

| å­—æ®µ               | ç±»å‹                                                                            | åšä»€ä¹ˆ                                | é›¶å€¼/é»˜è®¤è¡Œä¸º                          | æ”¾è¿› `http.Transport` åçš„æ•ˆæœ                     | å¸¸è§å–å€¼                                            | å¤‡æ³¨/å‘ç‚¹                             |
| ---------------- | ----------------------------------------------------------------------------- | ---------------------------------- | -------------------------------- | -------------------------------------------- | ----------------------------------------------- | --------------------------------- |
| `Timeout`        | `time.Duration`                                                               | **æ‹¨å·é˜¶æ®µ**çš„æœ€é•¿æ—¶é•¿ï¼ˆå»ºç«‹ TCP/UDP è¿æ¥ï¼‰       | `0` è¡¨ç¤ºä¸é™åˆ¶ï¼Œä¾èµ–ä¸Šå±‚ `ctx` æˆ– OS        | ä½œä¸º `Transport.DialContext` çš„è¶…æ—¶ä¸Šé™ï¼ˆä»…è¿æ¥é˜¶æ®µï¼‰      | `5s`ã€`3s`                                       | ä¸ `ctx` çš„ `deadline` å–**æ›´æ—©**è€…ç”Ÿæ•ˆ   |
| `Deadline`       | `time.Time`                                                                   | æ‹¨å·å¿…é¡»åœ¨è¿™ä¸ª**ç»å¯¹æ—¶é—´**å‰å®Œæˆ                 | `time.Time{}` ä¸å¯ç”¨                | åŒä¸Š                                           | `time.Now().Add(5 * time.Second)`               | é€šå¸¸ä¸ç”¨ï¼›ç”¨ `Timeout`/`ctx` æ›´æ¸…æ™°        |
| `KeepAlive`      | `time.Duration`                                                               | TCP Keep-Alive å‘¨æœŸ                  | `0` = **å¯ç”¨**å¹¶ç”¨ OS é»˜è®¤ï¼›è´Ÿå€¼ = **ç¦ç”¨** | å½±å“åº•å±‚ TCP è¿æ¥æ˜¯å¦å‘ keepalive æ¢æµ‹åŒ…                 | `30s` å¸¸è§                                        | åªå¯¹ TCPï¼›é•¿è¿æ¥æœåŠ¡å»ºè®®å¯ç”¨                  |
| `LocalAddr`      | `net.Addr`ï¼ˆä¾‹å¦‚ `*net.TCPAddr`ï¼‰                                                 | ç»‘å®š**æœ¬åœ°** IP/ç«¯å£ï¼ˆé€‰æ‹©ç½‘å¡/å‡ºå£ï¼‰            | `nil` è‡ªåŠ¨é€‰æ‹©                       | è®© HTTP èµ°æŒ‡å®šç½‘å¡/æº IP                            | `&net.TCPAddr{IP: net.ParseIP("192.168.1.10")}` | ç±»å‹è¦ä¸ç½‘ç»œä¸€è‡´ï¼ˆTCP/UDPï¼‰                 |
| `DualStack`      | `bool`                                                                        | æ—§çš„ IPv4/IPv6 åŒæ ˆå¼€å…³                  | å·²**åºŸå¼ƒ**ï¼Œæ–°ç‰ˆæœ¬æ— æ•ˆ                    | æ—                                             | ä¸å»ºè®®ä½¿ç”¨                                           | ç°åœ¨é»˜è®¤å·²æ˜¯â€œHappy Eyeballsâ€ç­–ç•¥          |
| `FallbackDelay`  | `time.Duration`                                                               | IPv6/IPv4 ç«é€Ÿæ—¶çš„å›é€€å»¶è¿Ÿï¼ˆHappy Eyeballsï¼‰ | `0` = ä½¿ç”¨é»˜è®¤ï¼ˆçº¦ `300ms`ï¼‰ï¼›è´Ÿå€¼ = ç¦ç”¨    | å½±å“è¿æ¥é¦–åŒ…æ›´å¿«ï¼šå…ˆè¯•ä¸€ä¸ªæ—ï¼Œå»¶è¿Ÿåè¯•å¦ä¸€ä¸ª                       | `200â€“300ms`                                     | ä»…ä¸»æœºåæ‹¨å·æ—¶ç›¸å…³ï¼ˆéœ€è¦è§£æå¾—åˆ°å¤šåœ°å€ï¼‰              |
| `Resolver`       | `*net.Resolver`                                                               | è‡ªå®šä¹‰ DNS è§£æ                         | `nil` ç”¨ç³»ç»Ÿè§£æå™¨                     | é…åˆ HTTPï¼šè§£æåŸŸåç”¨ä½ çš„ resolverï¼ˆå¯èµ°ä¸“ç”¨ DNSã€DoTã€DoH ç­‰ï¼‰ | è‡ªå®šä¹‰ `Dial` åˆ°ç‰¹å®š DNS                              | å¯ç”¨ `PreferGo` å¼ºåˆ¶ Go è§£æ/è‡ªå®šä¹‰ `Dial` |
| `Control`        | `func(network, address string, c syscall.RawConn) error`                      | åœ¨è¿æ¥åˆ›å»ºåã€`Connect` å‰è®¾ç½®**åº•å±‚ fd é€‰é¡¹**   | `nil` ä¸è®¾ç½®                        | å¯¹ HTTP åº•å±‚è¿æ¥ç”Ÿæ•ˆï¼ˆå¦‚ TOSã€FASTOPENï¼‰                | è®¾ç½® TOS/DSCPã€ç»‘å®š SO\_MARK ç­‰                       | ä¸è¦é˜»å¡ï¼›è·¨å¹³å°å¯ç”¨æ€§ä¸åŒ                     |
| `ControlContext` | `func(ctx context.Context, network, address string, c syscall.RawConn) error` | `Control` çš„å¸¦ä¸Šä¸‹æ–‡ç‰ˆæœ¬ï¼ˆä¼˜å…ˆçº§æ›´é«˜ï¼‰           | `nil` ä¸è®¾ç½®                        | åŒä¸Š                                           | åŒä¸Š                                              | æœ‰ `ctx` æ›´æ˜“è¶…æ—¶/å–æ¶ˆ                   |

<br/>

> å°ç»“ï¼šæŠŠ `dialer.DialContext` èµ‹ç»™ `http.Transport.DialContext`ï¼Œå°±æŠŠ**è¿æ¥å»ºç«‹é˜¶æ®µ**çš„ç­–ç•¥ï¼ˆè¶…æ—¶ã€keepaliveã€æœ¬åœ°åœ°å€ã€DNSã€fd é€‰é¡¹ç­‰ï¼‰æ¥å…¥äº† HTTP å®¢æˆ·ç«¯ã€‚
> å…¶ä»–é˜¶æ®µï¼ˆTLS æ¡æ‰‹ã€é¦–åŒ…å“åº”ã€æ•´ä½“è¯·æ±‚ï¼‰éœ€è¦ç”¨ `http.Transport` / `http.Client` çš„å­—æ®µåˆ†åˆ«æ§åˆ¶ï¼ˆè§ä¸‹ï¼‰ã€‚

<br/>

**ä¸ `http.Transport` / `http.Client` çš„è”åŠ¨è¦ç‚¹**

* è¿æ¥é˜¶æ®µï¼ˆTCP/UDP æ‹¨å·ï¼‰ï¼šç”± **`Dialer.Timeout/Deadline` + `ctx`** æ§åˆ¶ã€‚
* TLS é˜¶æ®µï¼š`Transport.TLSHandshakeTimeout`ã€‚
* ç­‰é¦–å­—èŠ‚/å“åº”å¤´ï¼š`Transport.ResponseHeaderTimeout`ã€‚
* 100-continue ç­‰å¾…æ—¶é•¿ï¼š`Transport.ExpectContinueTimeout`ã€‚
* ç©ºé—²è¿æ¥æ± ï¼š`Transport.MaxIdleConns`ã€`MaxIdleConnsPerHost`ã€`IdleConnTimeout`ã€‚
* æ¯ä¸»æœºæœ€å¤§å¹¶å‘è¿æ¥ï¼š`Transport.MaxConnsPerHost`ã€‚
* ä»£ç†ï¼š`Transport.Proxy`ï¼ˆç¯å¢ƒä»£ç†æˆ–è‡ªå®šä¹‰ï¼‰ã€‚
* HTTP/2ï¼š`Transport.ForceAttemptHTTP2`ï¼ˆå¤šæ•°ç‰ˆæœ¬é»˜è®¤å¼€å¯ï¼›è‡ªå®šä¹‰ `DialTLSContext` å¯èƒ½å½±å“ h2ï¼‰ã€‚
* **æ•´ä½“è¯·æ±‚è¶…æ—¶**ï¼ˆåŒ…æ‹¬é‡å®šå‘ï¼‰ï¼šç”¨ `http.Client{Timeout: ...}` æˆ– `req.WithContext(ctx)` çš„ `deadline`ã€‚

> è¯¯åŒºï¼šæƒ³ç»™â€œæ¯æ¬¡è¯»å†™â€éƒ½é™æ—¶ï¼Œå¾ˆå¤šäººä¼šåœ¨ `DialContext` é‡Œ `SetDeadline`ã€‚**ä¸è¦**è¿™ä¹ˆåšï¼ˆä¼šå½±å“ HTTP/2 å¤šè·¯å¤ç”¨ï¼‰ã€‚ä¼˜å…ˆç”¨ `ResponseHeaderTimeout`ã€`Client.Timeout`ï¼Œæˆ–åœ¨éœ€è¦æ—¶å¯¹ `Request.Context()` è®¾å®š deadlineã€‚

<br/>

**å®ç”¨æ¨¡æ¿**

**1ï¼‰ç¨³å¥çš„è¶…æ—¶ + è¿æ¥æ± é…ç½®ï¼ˆé€šç”¨ç”Ÿäº§å»ºè®®ï¼‰**

```go
dialer := &net.Dialer{
    Timeout:   5 * time.Second,   // è¿æ¥è¶…æ—¶
    KeepAlive: 30 * time.Second,  // TCP KeepAlive
    // LocalAddr: å¯é€‰ï¼Œç»‘å®šæœ¬åœ°IP
    // Resolver:  å¯é€‰ï¼Œè‡ªå®šä¹‰DNS
}

tr := &http.Transport{
    Proxy:                 http.ProxyFromEnvironment,
    DialContext:           dialer.DialContext,
    ForceAttemptHTTP2:     true,                 // å¯ç”¨ HTTP/2
    MaxIdleConns:          100,                  // æ€»ç©ºé—²è¿æ¥
    MaxIdleConnsPerHost:   10,                   // æ¯ä¸»æœºç©ºé—²
    MaxConnsPerHost:       0,                    // 0=ä¸é™åˆ¶ï¼ˆä½†å—æ± é™åˆ¶ï¼‰
    IdleConnTimeout:       90 * time.Second,     // ç©ºé—²è¿æ¥å›æ”¶
    TLSHandshakeTimeout:   10 * time.Second,     // TLS
    ExpectContinueTimeout: 1 * time.Second,      // 100-continue
    ResponseHeaderTimeout: 10 * time.Second,     // ç­‰é¦–ä¸ªå“åº”å¤´
    // TLSClientConfig:     å¯é€‰
}

client := &http.Client{
    Transport: tr,
    Timeout:   15 * time.Second,                 // æ•´ä½“è¯·æ±‚ä¸Šé™ï¼ˆå«é‡å®šå‘ï¼‰
}
```

**è¯´æ˜**ï¼š

* ä¸‰å±‚è¶…æ—¶å½¼æ­¤ç‹¬ç«‹ï¼šæ‹¨å·ï¼ˆ5sï¼‰/TLSï¼ˆ10sï¼‰/ç­‰å¾…å“åº”å¤´ï¼ˆ10sï¼‰ï¼Œ**æ•´ä½“**ï¼ˆ15sï¼‰ã€‚
* ç”Ÿäº§ç¯å¢ƒå»ºè®®**å¤ç”¨**ä¸€ä¸ª `Transport`/`Client` å®ä¾‹ï¼ˆé¿å…æ¯æ¬¡åˆ›å»ºå¯¼è‡´æ— è¿æ¥å¤ç”¨ä¸æ³„æ¼ï¼‰ã€‚
* é€€å‡ºæ—¶å¦‚éœ€ä¸»åŠ¨å›æ”¶å¯ `tr.CloseIdleConnections()`ã€‚

<br/>

**2ï¼‰æŒ‡å®šæœ¬åœ°ç½‘å¡/æº IPï¼ˆèµ°ç‰¹å®šå‡ºå£ï¼‰**

```go
dialer := &net.Dialer{
    Timeout:   5 * time.Second,
    KeepAlive: 30 * time.Second,
    LocalAddr: &net.TCPAddr{IP: net.ParseIP("192.168.10.23")}, // æŒ‡å®šæºIP
}
tr := &http.Transport{ DialContext: dialer.DialContext }
client := &http.Client{ Transport: tr }
```

> æ³¨æ„ï¼š`LocalAddr` ç±»å‹éœ€ä¸ç½‘ç»œåŒ¹é…ï¼ˆTCP/UDPï¼‰ï¼›ç«¯å£ç•™ `0` è®© OS åˆ†é…ä¸´æ—¶ç«¯å£ã€‚

<br/> 

**3ï¼‰è‡ªå®šä¹‰ DNSï¼ˆèµ°ç‰¹å®š DNS æœåŠ¡å™¨ï¼‰**

```go
resolver := &net.Resolver{
    PreferGo: true, // å¼ºåˆ¶ä½¿ç”¨ Go çš„çº¯å®ç°ï¼ˆä¸èµ°ç³»ç»Ÿè§£æï¼‰
    Dial: func(ctx context.Context, network, address string) (net.Conn, error) {
        // ç›´æ¥è¿åˆ°ä½ çš„ DNS æœåŠ¡å™¨ï¼ˆä¾‹å¦‚ 8.8.8.8:53 æˆ–å…¬å¸å†…ç½‘DNSï¼‰
        d := &net.Dialer{}
        return d.DialContext(ctx, "udp", "8.8.8.8:53")
    },
}

dialer := &net.Dialer{
    Timeout:  5 * time.Second,
    Resolver: resolver,
}

tr := &http.Transport{ DialContext: dialer.DialContext }
client := &http.Client{ Transport: tr }
```

> ä¹Ÿå¯ä»¥æŠŠ `udp` æ”¹æˆ `tcp`ï¼Œæˆ–åœ¨ `Dial` ä¸­åšè¶…æ—¶/å›é€€ç­–ç•¥ã€‚

<br/>

**4ï¼‰è®¾ç½®åº•å±‚ socket é€‰é¡¹ï¼ˆæ¯”å¦‚ DSCP/TOSã€TCP\_FASTOPEN ç­‰ï¼‰**

```go
dialer := &net.Dialer{
    Timeout: 5 * time.Second,
    ControlContext: func(ctx context.Context, network, address string, c syscall.RawConn) error {
        var ctrlErr error
        err := c.Control(func(fd uintptr) {
            // åœ¨è¿™é‡Œè°ƒç”¨å¹³å°ç›¸å…³çš„ setsockopt
            // ç¤ºä¾‹ï¼ˆä¼ªä»£ç ï¼‰ï¼šunix.SetsockoptInt(int(fd), unix.IPPROTO_IP, unix.IP_TOS, 0x10)
        })
        if err != nil { return err }
        return ctrlErr
    },
}
tr := &http.Transport{ DialContext: dialer.DialContext }
client := &http.Client{ Transport: tr }
```

> æé†’ï¼šè¿™éƒ¨åˆ†**å¼ºçƒˆä¾èµ–å¹³å°**ï¼›åŠ¡å¿…åšç¼–è¯‘æ ‡ç­¾ä¸å®¹é”™ï¼Œä¸”ä¸è¦è€—æ—¶é˜»å¡ã€‚

<br/>

**å¸¸è§é—®ç­” / æ˜“è¸©å‘**

* **Qï¼šæˆ‘æŠŠè¯»å†™è¶…æ—¶æ”¾åœ¨ `DialContext` é‡Œ `SetDeadline` è¡Œä¸è¡Œï¼Ÿ**
  Aï¼šä¸å»ºè®®ã€‚é‚£ä¼šç»™**æ•´æ¡è¿æ¥**è®¾æ€»æœŸé™ï¼Œå½±å“å¤ç”¨/HTTP2 çš„å¤šè·¯å¤ç”¨ã€‚ä¼˜å…ˆç”¨ `ResponseHeaderTimeout`ã€`Client.Timeout` æˆ–æ¯ä¸ªè¯·æ±‚çš„ `ctx` deadlineã€‚

* **Qï¼š`DualStack` è¯¥ä¸è¯¥å¼€ï¼Ÿ**
  Aï¼šåˆ«ç®¡å®ƒäº†ï¼Œå·²ç»åºŸå¼ƒä¸”é»˜è®¤å°±æ˜¯â€œHappy Eyeballsâ€ï¼ˆIPv6/IPv4 å¹¶è¡Œ/å›é€€ï¼‰ã€‚éœ€è¦çš„è¯è°ƒ `FallbackDelay`ã€‚

* **Qï¼šé¢‘ç¹ `http.Client{}` æ–°å»ºæœ‰é—®é¢˜å—ï¼Ÿ**
  Aï¼šä¼šå¯¼è‡´**è¿æ¥æ— æ³•å¤ç”¨**ç”šè‡³æ³„æ¼ï¼Œåå/å»¶è¿Ÿéƒ½å˜å·®ã€‚å»ºè®®**å…¨å±€å¤ç”¨** `Transport`/`Client`ã€‚

* **Qï¼šä»£ç† + HTTPS + HTTP/2 æœ‰å•¥æ³¨æ„ï¼Ÿ**
  Aï¼šè‡ªå®šä¹‰ `DialTLSContext` å¯èƒ½è®©è‡ªåŠ¨ HTTP/2 æ¢æµ‹å¤±æ•ˆï¼›è°¨æ…æ”¹ã€‚ç”¨ç³»ç»Ÿé»˜è®¤æœ€ç¨³ã€‚

* **Qï¼š`KeepAlive` è®¾å¤šå°‘åˆé€‚ï¼Ÿ**
  Aï¼š`30s` æ˜¯é€šç”¨é€‰æ‹©ï¼›å¯¹å¼±ç½‘/é•¿è¿æ¥åœºæ™¯å¾ˆæœ‰å¸®åŠ©ã€‚è®¾è´Ÿå€¼ä¼šç¦ç”¨ keepaliveã€‚

---

å¥½ ğŸ‘ é‚£æˆ‘å¸®ä½ è®¾è®¡ä¸€ä»½â€œæœ€ä¼˜é…ç½®æ¸…å•â€ã€‚ä¸è¿‡ä¸åŒä¸šåŠ¡åœºæ™¯ä¸‹çš„ **HTTP å®¢æˆ·ç«¯æœ€ä½³é…ç½®**ä¼šæœ‰å·®åˆ«ï¼Œæ‰€ä»¥æˆ‘å…ˆåˆ—å‡ ä¸ªå¸¸è§åœºæ™¯ï¼Œå†ç»™å¯¹åº”é…ç½®ã€‚ä½ å¯ä»¥å¯¹å·å…¥åº§ï¼Œæˆ‘å†å¸®ä½ è°ƒæ•´ã€‚


***
<br/><br/><br/>
> <h2 id="HTTPå®¢æˆ·ç«¯æœ€ä½³é…ç½®æ–¹æ¡ˆ">HTTPå®¢æˆ·ç«¯æœ€ä½³é…ç½®æ–¹æ¡ˆ</h2>
  
**1.é€šç”¨ä¸šåŠ¡ API è°ƒç”¨ï¼ˆWeb æœåŠ¡ â†” å¾®æœåŠ¡ï¼‰**

* ç‰¹ç‚¹ï¼š

  * QPS ä¸­ç­‰ï¼ˆ100ï½2000/sï¼‰
  * è¯·æ±‚çŸ­å°ï¼Œå“åº”å¿«ï¼ˆJSONã€Protobufï¼‰
  * ä¸»è¦éœ€æ±‚ï¼š**å¯é ã€å¿«é€Ÿå¤±è´¥ã€è¿æ¥å¤ç”¨**

```go
dialer := &net.Dialer{
    Timeout:   3 * time.Second,   // æ‹¨å·è¶…æ—¶
    KeepAlive: 30 * time.Second,  // TCPä¿æ´»
}

tr := &http.Transport{
    Proxy:                 http.ProxyFromEnvironment,
    DialContext:           dialer.DialContext,
    ForceAttemptHTTP2:     true,
    MaxIdleConns:          200,              // æ€»ç©ºé—²è¿æ¥
    MaxIdleConnsPerHost:   50,               // æ¯ä¸ªä¸»æœºç©ºé—²
    MaxConnsPerHost:       100,              // æ¯ä¸»æœºæœ€å¤§è¿æ¥
    IdleConnTimeout:       90 * time.Second, // ç©ºé—²è¿æ¥å­˜æ´»
    TLSHandshakeTimeout:   5 * time.Second,
    ExpectContinueTimeout: 1 * time.Second,
    ResponseHeaderTimeout: 5 * time.Second,
}

client := &http.Client{
    Transport: tr,
    Timeout:   10 * time.Second,   // æ•´ä½“è¯·æ±‚è¶…æ—¶
}
```

ğŸ‘‰ **æ•ˆæœ**ï¼š

* å¿«é€Ÿå¤±è´¥ï¼ˆ3s æ‹¨å·ï¼Œ5s å“åº”è¶…æ—¶ï¼‰ã€‚
* æœ‰é™è¿æ¥æ± ï¼Œé¿å…è¿‡åº¦åˆ›å»ºè¿æ¥ã€‚
* é»˜è®¤ HTTP/2ï¼Œååæ›´é«˜ã€‚

<br/>

**2.é«˜å¹¶å‘çˆ¬è™« / æ•°æ®é‡‡é›†**

* ç‰¹ç‚¹ï¼š

	* QPS é«˜ï¼ˆå‡ åƒ/sï¼‰
	* ç›®æ ‡ç«™ç‚¹å¤šï¼ŒIP/åŸŸåå¤š
	* ä¸»è¦éœ€æ±‚ï¼š**é«˜è¿æ¥å¤ç”¨ã€è¶…æ—¶æ›´å®½æ¾**

```go
dialer := &net.Dialer{
    Timeout:   5 * time.Second,
    KeepAlive: 60 * time.Second,
}

tr := &http.Transport{
    DialContext:           dialer.DialContext,
    MaxIdleConns:          1000,
    MaxIdleConnsPerHost:   200,
    MaxConnsPerHost:       500,
    IdleConnTimeout:       120 * time.Second,
    TLSHandshakeTimeout:   10 * time.Second,
    ResponseHeaderTimeout: 10 * time.Second,
}

client := &http.Client{
    Transport: tr,
    Timeout:   20 * time.Second,
}
```

ğŸ‘‰ **æ•ˆæœ**ï¼š

* å¤§é‡é•¿è¿æ¥å¤ç”¨ï¼Œå‡å°‘ä¸‰æ¬¡æ¡æ‰‹/TLS å¼€é”€ã€‚
* æ›´é•¿çš„è¶…æ—¶ï¼Œé€‚åˆç›®æ ‡ç«™ç‚¹å“åº”è¾ƒæ…¢ã€‚

<br/>

**3.æ–‡ä»¶ä¸Šä¼ /ä¸‹è½½ï¼ˆå¤§æ–‡ä»¶ä¼ è¾“ï¼‰**

	* ç‰¹ç‚¹ï¼š
	
	* è¯·æ±‚å¯èƒ½å¾ˆæ…¢ï¼ˆåˆ†é’Ÿçº§ï¼‰
	* å¤§æµé‡ï¼Œé•¿è¿æ¥
	* ä¸»è¦éœ€æ±‚ï¼š**é•¿è¶…æ—¶ã€ä¿æŒç¨³å®š**

```go
dialer := &net.Dialer{
    Timeout:   10 * time.Second,
    KeepAlive: 30 * time.Second,
}

tr := &http.Transport{
    DialContext:         dialer.DialContext,
    MaxIdleConns:        100,
    MaxIdleConnsPerHost: 10,
    IdleConnTimeout:     90 * time.Second,
    TLSHandshakeTimeout: 10 * time.Second,
}

client := &http.Client{
    Transport: tr,
    Timeout:   0,  // ä¸è®¾æ•´ä½“è¶…æ—¶ï¼Œç”¨ request.WithContext æ§åˆ¶
}
```

ğŸ‘‰ **æ•ˆæœ**ï¼š

* ä¸å¼ºè¡Œé™åˆ¶æ•´ä½“è¶…æ—¶ï¼Œè®©å¤§æ–‡ä»¶èƒ½ä¼ å®Œã€‚
* å»ºè®®ç”¨ `req.WithContext(ctx)` ç»™å•æ¬¡ä»»åŠ¡è®¾ç½® deadlineã€‚

<br/>

**4.å†…ç½‘è°ƒç”¨ / å¾®æœåŠ¡ Mesh ç¯å¢ƒ**

* ç‰¹ç‚¹ï¼š

	* éƒ½æ˜¯å†…ç½‘ IPï¼Œå»¶è¿Ÿä½
	* QPS é«˜ï¼Œä¾èµ–è¿æ¥æ± 
	* ä¸»è¦éœ€æ±‚ï¼š**ä½å»¶è¿Ÿï¼Œå¼ºè¿æ¥æ± å¤ç”¨**

```go
dialer := &net.Dialer{
    Timeout:   1 * time.Second,   // å†…ç½‘å¿«ï¼Œè¶…æ—¶è¦æ›´ä¸¥æ ¼
    KeepAlive: 15 * time.Second,
    LocalAddr: &net.TCPAddr{IP: net.ParseIP("10.0.0.23")}, // æŒ‡å®šå†…ç½‘å‡ºå£ï¼Œå¯é€‰
}

tr := &http.Transport{
    DialContext:         dialer.DialContext,
    MaxIdleConns:        500,
    MaxIdleConnsPerHost: 200,
    IdleConnTimeout:     60 * time.Second,
    TLSHandshakeTimeout: 2 * time.Second,
}

client := &http.Client{
    Transport: tr,
    Timeout:   5 * time.Second,
}
```

ğŸ‘‰ **æ•ˆæœ**ï¼š

* å†…ç½‘é«˜å¹¶å‘ï¼Œä¸¥æ ¼è¶…æ—¶é˜²æ­¢é›ªå´©ã€‚
* å‡ºå£ç»‘å®šå¯ä»¥é¿å…èµ°é”™è¯¯ç½‘å¡ã€‚

<br/>

**æ€»ç»“é€‰å‹æŒ‡å—**

* **API è°ƒç”¨** â†’ ç¨³å¥è¶…æ—¶ + ä¸­ç­‰è¿æ¥æ± 
* **çˆ¬è™«/é‡‡é›†** â†’ å¤§è¿æ¥æ±  + å®½æ¾è¶…æ—¶
* **å¤§æ–‡ä»¶ä¼ è¾“** â†’ ç¦ç”¨æ•´ä½“ Timeout + ä¸Šä¸‹æ–‡æ§åˆ¶
* **å†…ç½‘è°ƒç”¨** â†’ ä¸¥æ ¼è¶…æ—¶ + å¤§è¿æ¥æ±  + å¯ç»‘å‡ºå£


<br/><br/><br/>

***
<br/>

> <h1 id="GETã€POSTã€PUT(update)ã€DELETEè¯·æ±‚">GETã€POSTã€PUT(update)ã€DELETEè¯·æ±‚</h1>

**HTTP è¯·æ±‚æ–¹å¼åŒºåˆ†ï¼š**

```go
r.Method
```

å®ƒçš„å€¼æ˜¯ä¸‹é¢ä¹‹ä¸€ï¼š

* `"GET"`
* `"POST"`
* `"PUT"`ï¼ˆupdateï¼‰
* `"DELETE"`
* `"PATCH"`ï¼ˆå¯é€‰ï¼‰

ğŸ‘‰ **Go åŸç”Ÿä¸ä¼šå¸®ä½ åšè·¯ç”±åˆ†å‘**ï¼Œå¿…é¡»ä½ è‡ªå·±åˆ¤æ–­ã€‚

<br/>

```go
package main

import (
	"encoding/json"
	"net/http"
	"strings"
)

type UserHandler struct{}

func (h *UserHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:		// æŸ¥è¯¢ç”¨æˆ·
		h.Get(w, r)
	case http.MethodPost:		// æ–°å»ºç”¨æˆ·
		h.Create(w, r)
	case http.MethodPut:		// æ›´æ–°ç”¨æˆ·
		h.Update(w, r)
	case http.MethodDelete:		// åˆ é™¤ç”¨æˆ·
		h.Delete(w, r)
	default:
		w.WriteHeader(http.StatusMethodNotAllowed)
	}
}

func (h *UserHandler) Get(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("get user"))
}

func (h *UserHandler) Create(w http.ResponseWriter, r *http.Request) {
	var body map[string]any
	json.NewDecoder(r.Body).Decode(&body)
	json.NewEncoder(w).Encode(body)
}

func (h *UserHandler) Update(w http.ResponseWriter, r *http.Request) {
	id := strings.TrimPrefix(r.URL.Path, "/api/user/")
	w.Write([]byte("update user " + id))
}

func (h *UserHandler) Delete(w http.ResponseWriter, r *http.Request) {
	id := strings.TrimPrefix(r.URL.Path, "/api/user/")
	w.Write([]byte("delete user " + id))
}

func main() {
	mux := http.NewServeMux()
	mux.Handle("/api/user", &UserHandler{})
	mux.Handle("/api/user/", &UserHandler{})

	http.ListenAndServe(":3000", mux)
}
```

***
<br/>

***
<br/><br/><br/>
> <h2 id="GETå–å‚æ•°">GETå–å‚æ•°</h2>
**GETï¼šä» URL Query å–å‚æ•°ï¼ˆWeb / App éƒ½é€šç”¨ï¼‰**

```go
id := r.URL.Query().Get("id")
```

<br/>

```
GET /api/user?id=123
```

***
<br/><br/><br/>
> <h2 id="POSTã€PUTå–å‚æ•°">POSTã€PUTå–å‚æ•°</h2>

**POST / PUTï¼šä» Body è¯» JSON**

```go
type CreateUserReq struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func decodeJSON(r *http.Request, v any) error {
	return json.NewDecoder(r.Body).Decode(v)
}
```

ä½¿ç”¨ï¼š

```go
var req CreateUserReq
if err := decodeJSON(r, &req); err != nil {
	http.Error(w, "invalid body", http.StatusBadRequest)
	return
}
```

***
<br/><br/><br/>
> <h2 id="DELETEå–å‚æ•°æ–¹å¼">DELETEå–å‚æ•°æ–¹å¼</h2>
**DELETEï¼šä¸¤ç§å¸¸è§æ–¹å¼ï¼ˆæ¨èç¬¬äºŒç§ï¼‰**

- **æ–¹å¼ 1ï¼ˆä¸æ¨èï¼‰**

```
DELETE /api/user?id=123
```

<br/>

```go
id := r.URL.Query().Get("id")
```

<br/>

- **æ–¹å¼ 2ï¼ˆæ¨èï¼‰**

```
DELETE /api/user/123
```

<br/>

**åŸç”Ÿ http è§£æ pathï¼š**

```go
id := strings.TrimPrefix(r.URL.Path, "/api/user/")
```

---
<br/>

**App / Web å…±ç”¨æ¥å£çš„å·¥ç¨‹è§„èŒƒï¼ŒğŸ”¥ ç»Ÿä¸€çº¦å®šã€‚ä¸¾ä¾‹å¦‚ä¸‹ï¼š**

| è¡Œä¸º | Method | è·¯å¾„              |
| -- | ------ | --------------- |
| æŸ¥è¯¢ | GET    | /api/users      |
| è¯¦æƒ… | GET    | /api/users/{id} |
| åˆ›å»º | POST   | /api/users      |
| æ›´æ–° | PUT    | /api/users/{id} |
| åˆ é™¤ | DELETE | /api/users/{id} |




<br/><br/><br/>

***
<br/>

> <h1 id="ç½‘ç»œå®‰å…¨">ç½‘ç»œå®‰å…¨</h1>


***
<br/><br/><br/>
> <h2 id="è¯ä¹¦ç­¾åå¸¸ç”¨æ¦‚å¿µ">è¯ä¹¦ç­¾åå¸¸ç”¨æ¦‚å¿µ</h2>

* **PEM**ï¼šä¸€ç§æ–‡æœ¬ç¼–ç æ ¼å¼ï¼Œç”¨ `-----BEGIN CERTIFICATE-----` åŒ…è£¹ base64 ç¼–ç çš„ DER æ•°æ®ã€‚
* **leafï¼ˆå¶å­è¯ä¹¦ï¼‰**ï¼šç”¨äºæ ‡è¯†æœåŠ¡å™¨æˆ–å®¢æˆ·ç«¯çš„è¯ä¹¦ï¼ˆæœ‰å…¬é’¥ï¼‰ã€‚
* **ä¸­é—´è¯ä¹¦ï¼ˆintermediateï¼‰**ï¼šCA å±‚çº§ä¸­çš„ä¸­é—´ CAï¼Œåº”éšæœåŠ¡å™¨è¯ä¹¦ä¸€èµ·å‘é€ï¼ˆæœåŠ¡å™¨å‘é€ leaf + intermediatesï¼›å®¢æˆ·ç«¯éœ€è¦å…¶ä¸­çš„ chain ä»¥å»ºç«‹åˆ°æ ¹ CA çš„ä¿¡ä»»é“¾ï¼‰ã€‚
* **æ ¹è¯ä¹¦ï¼ˆRoot CAï¼‰**ï¼šè‡ªç­¾åè¯ä¹¦ï¼Œæ”¾åˆ° trust storeï¼ˆä¾‹å¦‚æ“ä½œç³»ç»Ÿçš„ç³»ç»Ÿè¯ä¹¦åº“æˆ–è‡ªå»ºçš„ `CertPool`ï¼‰ã€‚
* **è¯ä¹¦é“¾é¡ºåº**ï¼šæœåŠ¡ç«¯åœ¨ `Certificates` ä¸­åº”ç¡®ä¿è¯ä¹¦ PEM é¡ºåºä¸º `leaf` + `intermediates`ï¼ˆè‹¥åªæœ‰ leaf ä¹Ÿå¯ä»¥ï¼‰ã€‚
* **AppendCertsFromPEM è¿”å› false**ï¼šé€šå¸¸è¡¨ç¤ºè¯»å–çš„æ–‡ä»¶ä¸æ˜¯æœ‰æ•ˆçš„ PEM è¯ä¹¦ï¼Œæˆ–å†…å®¹ä¸ºç©ºã€‚
* **è¯ä¹¦ SANï¼ˆsubjectAltNameï¼‰**ï¼šç°ä»£ TLS æ£€æŸ¥ä¸»æœºåæ—¶ä½¿ç”¨ SANï¼Œä¸åº”ä»…ä¾èµ– CommonName (CN)ã€‚
* **ç§é’¥åŠ å¯†**ï¼š`tls.LoadX509KeyPair` ä¸èƒ½ç›´æ¥åŠ è½½å¸¦å£ä»¤çš„ PEM ç§é’¥ï¼ˆéœ€è¦å…ˆè§£å¯† PEMï¼‰ï¼Œè‹¥ç§é’¥è¢«åŠ å¯†ï¼Œéœ€è¦å…ˆè§£å¯†æˆ–ç”Ÿæˆæ— å¯†ç ç§é’¥ã€‚

***
<br/><br/><br/>
> <h2 id="ç”Ÿäº§å®‰å…¨å»ºè®®">ç”Ÿäº§å®‰å…¨å»ºè®®</h2>

* æœ€ä½ TLS ç‰ˆæœ¬å»ºè®® `tls.VersionTLS12` æˆ– `tls.VersionTLS13`ï¼ˆä¼˜å…ˆ TLS1.3ï¼‰ã€‚
* å°½é‡ä¸è¦ä½¿ç”¨ `InsecureSkipVerify: true`ï¼ˆä¼šç»•è¿‡è¯ä¹¦éªŒè¯ï¼‰ã€‚
* è¯ä¹¦è¦ä½¿ç”¨æœ‰æ•ˆçš„ SANï¼Œæ—¶é—´è¦æ£€æµ‹ï¼ˆè¿‡æœŸ/æœªç”Ÿæ•ˆï¼‰ã€‚
* åœ¨æœåŠ¡ç«¯å­˜æ”¾ç§é’¥è¯·ä¿è¯æ–‡ä»¶æƒé™ï¼ˆä¾‹å¦‚ `0600`ï¼‰å¹¶é¿å…æŠŠç§é’¥æ”¾ä»£ç ä»“åº“ã€‚
* è‹¥éœ€è¦é¢‘ç¹æ›¿æ¢è¯ä¹¦ï¼ˆçƒ­é‡è½½ï¼‰ï¼Œè®¾è®¡ reload æœºåˆ¶ï¼ˆæ›¿æ¢ `tls.Config` å¹¶ä¼˜é›…åˆ‡æ¢ listenerï¼‰ã€‚

***
<br/><br/><br/>
> <h2 id="ç”Ÿæˆè‡ªç­¾CAã€ç­¾å‘server/clientè¯ä¹¦ï¼ˆOpenSSLï¼‰">ç”Ÿæˆè‡ªç­¾ CAã€ç­¾å‘ server/client è¯ä¹¦ï¼ˆOpenSSLï¼‰</h2>

**åœ¨ Unix/bash ä¸‹ï¼š**

**1.ç”Ÿæˆ CAï¼ˆè‡ªç­¾ï¼‰ï¼š**

```bash
# ç”Ÿæˆ CA ç§é’¥
openssl genrsa -out ca.key 4096

# ç”Ÿæˆè‡ªç­¾ CA è¯ä¹¦ï¼ˆ10 å¹´ï¼‰
openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 \
  -subj "/CN=MyTestCA" -out ca.pem
```

<br/>

**2.ç”ŸæˆæœåŠ¡å™¨è¯ä¹¦å¹¶ç”¨ CA ç­¾åï¼ˆæ³¨æ„ SAN åŒ…å« localhost ä¸ 127.0.0.1ï¼‰ï¼š**

```bash
# server ç§é’¥
openssl genrsa -out server.key 2048

# server CSRï¼ˆCommonName å¯æ˜¯ localhostï¼‰
openssl req -new -key server.key -subj "/CN=localhost" -out server.csr

# åˆ›å»ºä¸€ä¸ª ext æ–‡ä»¶åŒ…å« SAN
cat > server_ext.cnf <<EOF
subjectAltName = DNS:localhost,IP:127.0.0.1
EOF

# ç”¨ CA ç­¾ç½²ï¼Œç”Ÿæˆ server.crt
openssl x509 -req -in server.csr -CA ca.pem -CAkey ca.key -CAcreateserial \
  -out server.crt -days 365 -sha256 -extfile server_ext.cnf
```

<br/>

**3.ç”Ÿæˆå®¢æˆ·ç«¯è¯ä¹¦å¹¶ç­¾åï¼š**

```bash
openssl genrsa -out client.key 2048
openssl req -new -key client.key -subj "/CN=client" -out client.csr
openssl x509 -req -in client.csr -CA ca.pem -CAkey ca.key -CAcreateserial \
  -out client.crt -days 365 -sha256
```

<br/>

4. **ï¼ˆå¯é€‰ï¼‰æŠŠ server è¯ä¹¦ä¸ä¸­é—´ CA æ‹¼åœ¨ä¸€èµ·ï¼ˆè‹¥æœ‰ä¸­é—´ CAï¼‰ï¼š**
   `cat server.crt intermediate.pem > server-chain.pem`
   ï¼ˆè¿™é‡Œæˆ‘ä»¬åªæœ‰è‡ªç­¾ CAï¼Œserver.crt å°±å¤Ÿï¼›ä½†é€šå¸¸æœ€å¥½æŠŠä¸­é—´è¯ä¹¦ä¹Ÿæ”¾è¿› server çš„ cert æ–‡ä»¶ä¸­ï¼Œä¾›å®¢æˆ·ç«¯å»ºç«‹å®Œæ•´é“¾ï¼‰

<br/>

# äº”ã€å®Œæ•´ Go ç¤ºä¾‹ï¼šæœåŠ¡ç«¯ï¼ˆå¯é€‰æ ¡éªŒå®¢æˆ·ç«¯è¯ä¹¦ï¼‰ + å®¢æˆ·ç«¯ï¼ˆå¯é€‰æä¾›å®¢æˆ·ç«¯è¯ä¹¦ï¼‰

ä¸‹é¢ç¤ºä¾‹æ¼”ç¤ºï¼š

* æœåŠ¡ç«¯ï¼šåŠ è½½ `server.crt` + `server.key`ï¼ŒæŠŠ `ca.pem` åŠ åˆ° `ClientCAs`ï¼Œ`ClientAuth = VerifyClientCertIfGiven`ï¼ˆå¯é€‰æ ¡éªŒï¼‰ï¼›
* å®¢æˆ·ç«¯ï¼šæŠŠ `ca.pem` åŠ å…¥ `RootCAs` ä»¥ä¿¡ä»»æœåŠ¡ç«¯ï¼›å¹¶å¯é€‰æ‹©åŠ è½½ `client.crt`/`client.key` ä½œä¸ºå®¢æˆ·ç«¯è¯ä¹¦ç”¨äºåŒå‘è®¤è¯ã€‚

> è¯·æŠŠä¸Šé¢ OpenSSL ç”Ÿæˆçš„ `server.crt/server.key/ca.pem/client.crt/client.key` æ”¾åœ¨å½“å‰ç›®å½•è¿è¡Œã€‚

<br/>

**æœåŠ¡ç«¯ä»£ç ï¼ˆserver.goï¼‰**

```go
package main

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"log"
	"net/http"
	"os"
)

func main() {
	// æ–‡ä»¶è·¯å¾„ï¼ˆæŒ‰éœ€ä¿®æ”¹ï¼‰
	serverCertFile := "server.crt"
	serverKeyFile := "server.key"
	caFile := "ca.pem" // ç”¨äºéªŒè¯å®¢æˆ·ç«¯è¯ä¹¦ï¼ˆå¦‚æœå®¢æˆ·ç«¯æä¾›ï¼‰

	// 1) åŠ è½½ server cert + key
	cert, err := tls.LoadX509KeyPair(serverCertFile, serverKeyFile)
	if err != nil {
		log.Fatalf("failed to load server key pair: %v", err)
	}

	// 2) å‡†å¤‡ Client CA poolï¼ˆå¦‚æœè¦éªŒè¯ client certï¼‰
	clientCAPool := x509.NewCertPool()
	caPEM, err := os.ReadFile(caFile)
	if err != nil {
		log.Fatalf("failed to read CA file: %v", err)
	}
	if ok := clientCAPool.AppendCertsFromPEM(caPEM); !ok {
		log.Fatalf("failed to append CA certs")
	}

	// 3) æ„é€  tls.Config
	tlsConfig := &tls.Config{
		Certificates: []tls.Certificate{cert},
		// å¯é€‰ç­–ç•¥ï¼šVerifyClientCertIfGiven / RequireAndVerifyClientCert / NoClientCert
		ClientAuth: tls.VerifyClientCertIfGiven,
		ClientCAs:  clientCAPool,
		MinVersion: tls.VersionTLS12,
	}

	// 4) ç®€å• http handlerï¼Œæ¼”ç¤ºå¦‚ä½•è¯»å–å®¢æˆ·ç«¯è¯ä¹¦ä¿¡æ¯
	mux := http.NewServeMux()
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Hello TLS world\n")
		// æŸ¥çœ‹æ˜¯å¦æœ‰å®¢æˆ·ç«¯è¯ä¹¦
		if r.TLS != nil && len(r.TLS.PeerCertificates) > 0 {
			clientCert := r.TLS.PeerCertificates[0]
			fmt.Fprintf(w, "Client cert CN: %s\n", clientCert.Subject.CommonName)
		} else {
			fmt.Fprintf(w, "No client certificate presented\n")
		}
	})

	server := &http.Server{
		Addr:      ":8443",
		Handler:   mux,
		TLSConfig: tlsConfig,
	}

	log.Printf("starting HTTPS server on %s", server.Addr)
	// ä½¿ç”¨ tls.Listen + server.Serve ä»¥ç¡®ä¿ä½¿ç”¨è‡ªå®šä¹‰ TLSConfig
	ln, err := tls.Listen("tcp", server.Addr, tlsConfig)
	if err != nil {
		log.Fatalf("tls listen error: %v", err)
	}
	log.Fatal(server.Serve(ln))
}
```

<br/>

**å®¢æˆ·ç«¯ä»£ç ï¼ˆclient.goï¼‰**

```go
package main

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"
)

func main() {
	caFile := "ca.pem"
	// å¯é€‰ï¼šå¦‚æœæœåŠ¡ç«¯è¦æ±‚å®¢æˆ·ç«¯è¯ä¹¦ï¼Œåˆ™åŠ è½½
	clientCertFile := "client.crt"
	clientKeyFile := "client.key"

	// 1) Root CA poolï¼ˆç”¨äºéªŒè¯æœåŠ¡ç«¯è¯ä¹¦ï¼‰
	rootCAs := x509.NewCertPool()
	caPEM, err := os.ReadFile(caFile)
	if err != nil {
		log.Fatalf("read ca pem: %v", err)
	}
	if ok := rootCAs.AppendCertsFromPEM(caPEM); !ok {
		log.Fatalf("failed to append CA certs")
	}

	// 2) å¯é€‰åŠ è½½å®¢æˆ·ç«¯è¯ä¹¦ï¼ˆå½“æœåŠ¡ç«¯è¦æ±‚æ—¶ï¼‰
	var clientCerts []tls.Certificate
	if _, err := os.Stat(clientCertFile); err == nil {
		cert, err := tls.LoadX509KeyPair(clientCertFile, clientKeyFile)
		if err != nil {
			log.Fatalf("failed to load client key pair: %v", err)
		}
		clientCerts = []tls.Certificate{cert}
	}

	// 3) æ„é€  tls.Config
	tlsConfig := &tls.Config{
		RootCAs:      rootCAs,       // ç”¨äºéªŒè¯æœåŠ¡å™¨è¯ä¹¦
		Certificates: clientCerts,   // å¦‚æœä¸ºç©ºï¼Œåˆ™ä¸å‘é€å®¢æˆ·ç«¯è¯ä¹¦
		MinVersion:   tls.VersionTLS12,
		// ServerName: "localhost", // ä¸€èˆ¬ç”±è¯·æ±‚ URL å†³å®šï¼›å¦‚æœç”¨ IP åˆ™é¡»æ‰‹åŠ¨è®¾
	}

	transport := &http.Transport{
		TLSClientConfig: tlsConfig,
	}
	client := &http.Client{
		Transport: transport,
		Timeout:   10 * time.Second,
	}

	resp, err := client.Get("https://localhost:8443/")
	if err != nil {
		log.Fatalf("request error: %v", err)
	}
	defer resp.Body.Close()

	fmt.Printf("status: %s\n", resp.Status)
	buf := make([]byte, 4096)
	n, _ := resp.Body.Read(buf)
	fmt.Printf("%s\n", string(buf[:n]))
}
```

<br/>

**å¦‚ä½•è¿è¡Œ**

1. ç”Ÿæˆè¯ä¹¦ï¼ˆè§ä¸Šé¢ OpenSSL å‘½ä»¤ï¼‰ã€‚
2. åœ¨ä¸€ä¸ªç»ˆç«¯è¿è¡Œ `go run server.go`ã€‚
3. åœ¨å¦ä¸€ä¸ªç»ˆç«¯è¿è¡Œ `go run client.go`ï¼ˆè‹¥å®¢æˆ·ç«¯è¯ä¹¦å­˜åœ¨ï¼Œä¼šè‡ªåŠ¨å‘é€ï¼‰ã€‚

* è‹¥æœåŠ¡å™¨ `ClientAuth` ä¸º `VerifyClientCertIfGiven`ï¼š

  * å®¢æˆ·ç«¯ä¸æä¾›å®¢æˆ·ç«¯è¯ä¹¦æ—¶ä¹Ÿèƒ½è¿æ¥ï¼›è‹¥å®¢æˆ·ç«¯æä¾›è¯ä¹¦åˆ™æœåŠ¡å™¨ä¼šéªŒè¯è¯ä¹¦é“¾ã€‚
* è‹¥æœåŠ¡å™¨ `ClientAuth` ä¸º `RequireAndVerifyClientCert`ï¼š

  * å®¢æˆ·ç«¯å¿…é¡»æä¾›è¯ä¹¦ä¸”ç”± `ClientCAs` ä¿¡ä»»ï¼Œå¦åˆ™æ¡æ‰‹å¤±è´¥ï¼ˆ403/connection closedï¼‰ã€‚

<br/>

**å¸¸è§å‘ä¸è°ƒè¯•æŠ€å·§**

* **`AppendCertsFromPEM` è¿”å› false**ï¼šæ£€æŸ¥ PEM æ–‡ä»¶æ˜¯å¦åŒ…å« `-----BEGIN CERTIFICATE-----` å—ï¼Œæ˜¯å¦æœ‰æ¢è¡Œé—®é¢˜æˆ–éè¯ä¹¦å­—ç¬¦ä¸²ã€‚
* **æœåŠ¡å™¨è¯ä¹¦ hostname éªŒè¯å¤±è´¥**ï¼šç¡®ä¿ server è¯ä¹¦çš„ SAN åŒ…å«ä½ è®¿é—®çš„ä¸»æœºåï¼ˆ`localhost` æˆ– IPï¼‰ï¼ŒGo ä¸å†ä½¿ç”¨ CN åš hostname éªŒè¯ï¼Œéœ€ç”¨ SANã€‚
* **ç§é’¥/è¯ä¹¦ä¸åŒ¹é…**ï¼š`tls.LoadX509KeyPair` ä¼šæŠ¥é”™ï¼Œç¡®è®¤ç§é’¥å¯¹åº”è¯ä¹¦ã€‚
* **å®¢æˆ·ç«¯è¿æ¥æ˜¾ç¤º EOF / handshake error**ï¼šæŸ¥çœ‹æœåŠ¡ç«¯æ—¥å¿—æ˜¯å¦å› ä¸º `ClientAuth` æ‹’ç»äº†è¿æ¥ï¼ˆæ¯”å¦‚è¦æ±‚ client cert ä½†æœªæä¾›æˆ–éªŒè¯ä¸é€šè¿‡ï¼‰ã€‚
* **ç”Ÿäº§ç¯å¢ƒä¸è¦ä½¿ç”¨è‡ªç­¾ CAï¼ˆé™¤éå†…éƒ¨ç§æœ‰ CAï¼‰**ï¼šæµè§ˆå™¨æˆ–ç³»ç»Ÿé€šå¸¸ä¸ä¿¡ä»»è‡ªç­¾ CAã€‚
* **TLS 1.3 ä¸ 1.2 è¡Œä¸ºä¸åŒ**ï¼šGo ä¼šè‡ªåŠ¨å¤„ç† TLS1.3 çš„ cipher è®¾ç½®ï¼Œæ‰‹å·¥è®¾ç½® `CipherSuites` åªå½±å“ TLS1.2 åŠä»¥ä¸‹ã€‚
* **è¯ä¹¦çƒ­æ›´**ï¼šå¦‚æœéœ€è¦æ— ç¼æ›¿æ¢è¯ä¹¦ï¼Œéœ€å®ç°è¯ä¹¦çƒ­åŠ è½½ï¼ˆä¾‹å¦‚å®šæœŸ `tlsConfig.GetCertificate` å›è°ƒè¯»å–æ–°è¯ä¹¦ï¼‰ã€‚

***
<br/><br/><br/>
> <h2 id="å‡çº§ï¼šä»£ç ç”Ÿæˆè‡ªç­¾åTLSè¯ä¹¦å’Œæ”¯æŒè¯ä¹¦çƒ­é‡è½½">å‡çº§ï¼šä»£ç ç”Ÿæˆè‡ªç­¾åTLSè¯ä¹¦å’Œæ”¯æŒè¯ä¹¦çƒ­é‡è½½</h2>

**æ”¹è¿›ï¼š**

1. **ç”¨ Go ä»£ç ç”Ÿæˆè‡ªç­¾å TLS è¯ä¹¦ï¼ˆæ›¿ä»£ openssl å‘½ä»¤ï¼Œä¸ä¾èµ–å¤–éƒ¨å·¥å…·ï¼‰**ã€‚
2. **æ”¯æŒè¯ä¹¦çƒ­é‡è½½**ï¼ˆæ£€æµ‹è¯ä¹¦æ–‡ä»¶å˜åŒ–ï¼ŒåŠ¨æ€æ›´æ–° `tls.Config`ï¼Œä¸ç”¨é‡å¯æœåŠ¡ï¼‰ã€‚

<br/> 

**1.ç”Ÿæˆè‡ªç­¾åè¯ä¹¦ï¼ˆGo ä»£ç å®ç°ï¼‰**

åœ¨ Go é‡Œï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ ‡å‡†åº“ `crypto/x509`, `crypto/rsa`, `encoding/pem`, `crypto/rand` æ¥ç”Ÿæˆ RSA ç§é’¥å’Œè‡ªç­¾åè¯ä¹¦ã€‚è¿™æ ·å°±ä¸ç”¨ `openssl`ã€‚

ä»£ç æ­¥éª¤ï¼š

* ç”Ÿæˆ RSA ç§é’¥ï¼ˆ2048 ä½ï¼‰ã€‚
* æ„é€ è¯ä¹¦æ¨¡æ¿ï¼ˆ`x509.Certificate`ï¼‰ï¼Œè®¾ç½®ç”¨é€”ï¼ˆServerAuthï¼‰ã€æœ‰æ•ˆæœŸã€åŸŸåç­‰ã€‚
* ç”¨ `x509.CreateCertificate` ç”Ÿæˆ DER ç¼–ç è¯ä¹¦ã€‚
* è¾“å‡ºä¸º PEM æ–‡ä»¶ï¼ˆ`.crt` å’Œ `.key`ï¼‰ã€‚

<br/>

**2.æ”¯æŒçƒ­é‡è½½è¯ä¹¦**

`tls.Config` æä¾›äº†ä¸€ä¸ªé’©å­ `GetCertificate`ï¼Œå¯ä»¥åœ¨æ¡æ‰‹æ—¶åŠ¨æ€è¿”å›è¯ä¹¦ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ª `atomic.Value` æˆ– `sync.RWMutex` æ¥ä¿å­˜å½“å‰çš„è¯ä¹¦ï¼Œå½“æ–‡ä»¶å˜åŠ¨æ—¶é‡æ–°åŠ è½½ã€‚

æ–‡ä»¶å˜åŒ–ç›‘å¬å¯ä»¥ç”¨ **fsnotify** åº“ï¼ˆå¸¸ç”¨ï¼‰ã€‚

<br/>

**ğŸ”¥å®Œæ•´ç¤ºä¾‹ä»£ç ï¼ˆå¯è¿è¡Œï¼‰**

```go
package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"log"
	"math/big"
	"net/http"
	"os"
	"sync/atomic"
	"time"

	"github.com/fsnotify/fsnotify"
)

var certAtomic atomic.Value // å­˜å‚¨æœ€æ–°è¯ä¹¦

// ç”Ÿæˆè‡ªç­¾åè¯ä¹¦å¹¶ä¿å­˜åˆ°æ–‡ä»¶
func generateSelfSignedCert(certFile, keyFile string) error {
	// ç”Ÿæˆç§é’¥
	priv, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return fmt.Errorf("failed to generate private key: %w", err)
	}

	// è¯ä¹¦æ¨¡æ¿
	serialNumber, _ := rand.Int(rand.Reader, big.NewInt(1<<62))
	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			Organization: []string{"MyCompany"},
			CommonName:   "localhost",
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(365 * 24 * time.Hour), // æœ‰æ•ˆæœŸä¸€å¹´
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
		DNSNames:              []string{"localhost"},
	}

	// åˆ›å»ºè¯ä¹¦ (è‡ªç­¾å)
	derBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)
	if err != nil {
		return fmt.Errorf("failed to create certificate: %w", err)
	}

	// å†™è¯ä¹¦æ–‡ä»¶
	certOut, err := os.Create(certFile)
	if err != nil {
		return err
	}
	pem.Encode(certOut, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
	certOut.Close()

	// å†™ç§é’¥æ–‡ä»¶
	keyOut, err := os.Create(keyFile)
	if err != nil {
		return err
	}
	pem.Encode(keyOut, &pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(priv)})
	keyOut.Close()

	log.Printf("Generated self-signed cert: %s, %s\n", certFile, keyFile)
	return nil
}

// åŠ è½½è¯ä¹¦
func loadCert(certFile, keyFile string) (*tls.Certificate, error) {
	cert, err := tls.LoadX509KeyPair(certFile, keyFile)
	if err != nil {
		return nil, err
	}
	return &cert, nil
}

// ç›‘å¬è¯ä¹¦æ–‡ä»¶å˜åŒ–ï¼Œè‡ªåŠ¨çƒ­é‡è½½
func watchCert(certFile, keyFile string) {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}
	defer watcher.Close()

	// ç›‘å¬ç›®å½•
	dir := "."
	if err := watcher.Add(dir); err != nil {
		log.Fatal(err)
	}

	for {
		select {
		case event := <-watcher.Events:
			// åˆ¤æ–­æ˜¯å¦è¯ä¹¦æˆ–å¯†é’¥è¢«ä¿®æ”¹
			if event.Op&(fsnotify.Write|fsnotify.Create) != 0 &&
				(event.Name == certFile || event.Name == keyFile) {
				log.Println("Detected cert/key change, reloading...")

				if cert, err := loadCert(certFile, keyFile); err == nil {
					certAtomic.Store(cert)
					log.Println("Certificate reloaded successfully")
				} else {
					log.Printf("Failed to reload cert: %v\n", err)
				}
			}
		case err := <-watcher.Errors:
			log.Println("Watcher error:", err)
		}
	}
}

func main() {
	certFile := "server.crt"
	keyFile := "server.key"

	// å¦‚æœä¸å­˜åœ¨ï¼Œå…ˆç”Ÿæˆ
	if _, err := os.Stat(certFile); os.IsNotExist(err) {
		if err := generateSelfSignedCert(certFile, keyFile); err != nil {
			log.Fatal(err)
		}
	}

	// åˆå§‹åŠ è½½è¯ä¹¦
	cert, err := loadCert(certFile, keyFile)
	if err != nil {
		log.Fatal(err)
	}
	certAtomic.Store(cert)

	// å¯åŠ¨æ–‡ä»¶ç›‘æ§ï¼Œçƒ­é‡è½½
	go watchCert(certFile, keyFile)

	// é…ç½® TLS
	tlsConfig := &tls.Config{
		MinVersion: tls.VersionTLS12,
		// æ¯æ¬¡æ¡æ‰‹æ—¶ä» atomic é‡Œå–æœ€æ–°è¯ä¹¦
		GetCertificate: func(info *tls.ClientHelloInfo) (*tls.Certificate, error) {
			return certAtomic.Load().(*tls.Certificate), nil
		},
	}

	// HTTPS server
	server := &http.Server{
		Addr:      ":8443",
		TLSConfig: tlsConfig,
	}

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Hello, TLS with hot reload! Time: %s\n", time.Now())
	})

	log.Println("Starting HTTPS server on https://localhost:8443")
	log.Fatal(server.ListenAndServeTLS("", "")) // è¯ä¹¦ç”± GetCertificate æä¾›
}
```

<br/>

**è¿è¡Œè¯´æ˜**

- 1.è¿è¡Œ `go run main.go`ï¼Œä¼šè‡ªåŠ¨ç”Ÿæˆ `server.crt` å’Œ `server.key`ã€‚
- 2.æ‰“å¼€æµè§ˆå™¨è®¿é—® `https://localhost:8443`ï¼Œä¼šæç¤ºè‡ªç­¾åè¯ä¹¦ä¸å®‰å…¨ï¼ˆæ­£å¸¸ï¼‰ã€‚
- 3.ä¿®æ”¹è¯ä¹¦æ–‡ä»¶ï¼ˆä¾‹å¦‚é‡æ–°è¿è¡Œ `generateSelfSignedCert` æˆ–ç›´æ¥æ›¿æ¢ `server.crt`ã€`server.key`ï¼‰ï¼ŒæœåŠ¡å™¨ä¼š **è‡ªåŠ¨çƒ­é‡è½½è¯ä¹¦**ï¼Œä¸ç”¨é‡å¯ã€‚

<br/>

**è§£é‡Šä¸ºä»€ä¹ˆè¦è¿™æ ·åš**

ä»¥å‰ç”¨ `openssl` å‘½ä»¤ï¼š

```bash
openssl req -new -x509 -nodes -out server.crt -keyout server.key -days 365
```

* `req -new -x509`ï¼šç”Ÿæˆæ–°è¯ä¹¦ï¼Œå¹¶è‡ªç­¾åï¼ˆX.509 æ ¼å¼ï¼‰ã€‚
* `-nodes`ï¼šä¸åŠ å¯†ç§é’¥ï¼ˆé¿å…è¾“å…¥å¯†ç ï¼‰ã€‚
* `-out server.crt`ï¼šè¾“å‡ºè¯ä¹¦æ–‡ä»¶ã€‚
* `-keyout server.key`ï¼šè¾“å‡ºç§é’¥æ–‡ä»¶ã€‚
* `-days 365`ï¼šè¯ä¹¦æœ‰æ•ˆæœŸ 365 å¤©ã€‚

è€Œæˆ‘ç”¨ Go ä»£ç é‡Œçš„ `x509.CreateCertificate` æ›¿ä»£äº† `openssl req -new -x509`ï¼Œç”¨ PEM ç¼–ç æ›¿ä»£äº†è¾“å‡º `.crt` å’Œ `.key` æ–‡ä»¶ï¼ŒåŠŸèƒ½å®Œå…¨ä¸€è‡´ã€‚


***
<br/><br/><br/>
> <h2 id="ç½‘ç»œåŠ å¯†ä¼ è¾“æ•°æ®æ¼”ç¤º">ç½‘ç»œåŠ å¯†ä¼ è¾“æ•°æ®æ¼”ç¤º</h2>

æ¼”ç¤ºä¸€ä¸ª**å®Œæ•´çš„ TLS åŒå‘è®¤è¯ + çƒ­é‡è½½è¯ä¹¦ + å®¢æˆ·ç«¯/æœåŠ¡ç«¯åŠ è§£å¯†é€šä¿¡çš„ Go ç¤ºä¾‹**ã€‚

**æˆ‘ä»¬ä¼šå®ç°ä»¥ä¸‹åŠŸèƒ½ï¼š**

1. **ç”¨ Go ç”Ÿæˆè‡ªç­¾åè¯ä¹¦**ï¼ˆä¸ä¾èµ– OpenSSLï¼‰ã€‚
2. **æœåŠ¡ç«¯åŠ è½½ TLS è¯ä¹¦**ï¼Œæ”¯æŒ **çƒ­é‡è½½**ï¼ˆç›‘å¬æ–‡ä»¶å˜åŒ–ï¼Œè‡ªåŠ¨æ›¿æ¢æ–°è¯ä¹¦ï¼‰ã€‚
3. **å®¢æˆ·ç«¯ä½¿ç”¨ TLS è¯ä¹¦ä¸æœåŠ¡ç«¯é€šä¿¡**ï¼Œä¼ è¾“æ•°æ®è‡ªåŠ¨åŠ å¯†ã€‚
4. **æœåŠ¡ç«¯æ”¶åˆ°æ•°æ®åè§£å¯†ã€å¤„ç†ï¼ˆæ‹¼æ¥å­—ç¬¦ä¸²ï¼‰ï¼Œå†åŠ å¯†è¿”å›**ã€‚
5. **å®¢æˆ·ç«¯è§£å¯†æœåŠ¡ç«¯è¿”å›çš„æ•°æ®**ã€‚
6. **æ¼”ç¤ºç½‘ç»œä¼ è¾“ï¼ˆåŸºäº TCP over TLSï¼‰**ã€‚

<br/> 

**1.Go ç”Ÿæˆè‡ªç­¾åè¯ä¹¦**

æˆ‘ä»¬å…ˆå†™ä¸€ä¸ª `generate_cert.go` æ¥ç”Ÿæˆ `cert.pem` å’Œ `key.pem`ï¼Œé¿å…ä¾èµ– `openssl`ã€‚

```go
package main

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"math/big"
	"os"
	"time"
)

func main() {
	priv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		panic(err)
	}

	serialNumber, _ := rand.Int(rand.Reader, big.NewInt(1<<62))

	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			Organization: []string{"MyOrg"},
			CommonName:   "localhost",
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(365 * 24 * time.Hour), // æœ‰æ•ˆæœŸ 1 å¹´
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
		BasicConstraintsValid: true,
	}

	certDER, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)
	if err != nil {
		panic(err)
	}

	// ä¿å­˜ cert.pem
	certOut, _ := os.Create("cert.pem")
	_ = pem.Encode(certOut, &pem.Block{Type: "CERTIFICATE", Bytes: certDER})
	certOut.Close()

	// ä¿å­˜ key.pem
	keyOut, _ := os.Create("key.pem")
	b, _ := x509.MarshalECPrivateKey(priv)
	_ = pem.Encode(keyOut, &pem.Block{Type: "EC PRIVATE KEY", Bytes: b})
	keyOut.Close()

	println("è¯ä¹¦ cert.pem å’Œ key.pem å·²ç”Ÿæˆ âœ…")
}
```

è¿è¡Œï¼š

```bash
go run generate_cert.go
```

ä¼šå¾—åˆ° `cert.pem` å’Œ `key.pem`ã€‚

<br/> 

**2.æœåŠ¡ç«¯ï¼ˆæ”¯æŒè¯ä¹¦çƒ­é‡è½½ï¼‰**

```go
package main

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"sync/atomic"
	"time"

	"github.com/fsnotify/fsnotify"
)

var tlsConfig atomic.Value // ä¿å­˜å½“å‰ tls.Config

func loadTLSConfig() *tls.Config {
	cert, err := tls.LoadX509KeyPair("cert.pem", "key.pem")
	if err != nil {
		log.Fatalf("åŠ è½½è¯ä¹¦å¤±è´¥: %v", err)
	}

	certPool := x509.NewCertPool()
	caCert, _ := os.ReadFile("cert.pem")
	certPool.AppendCertsFromPEM(caCert)

	return &tls.Config{
		Certificates: []tls.Certificate{cert},
		ClientAuth:   tls.RequireAndVerifyClientCert,
		ClientCAs:    certPool,
		MinVersion:   tls.VersionTLS12,
	}
}

func watchCert() {
	watcher, _ := fsnotify.NewWatcher()
	defer watcher.Close()
	_ = watcher.Add(".")

	for {
		select {
		case ev := <-watcher.Events:
			if ev.Op&(fsnotify.Write|fsnotify.Create) != 0 &&
				(ev.Name == "cert.pem" || ev.Name == "key.pem") {
				fmt.Println("ğŸ”„ æ£€æµ‹åˆ°è¯ä¹¦æ›´æ–°ï¼Œé‡æ–°åŠ è½½...")
				tlsConfig.Store(loadTLSConfig())
			}
		case err := <-watcher.Errors:
			log.Println("watcher error:", err)
		}
	}
}

func handleConn(conn net.Conn) {
	defer conn.Close()
	buf := make([]byte, 4096)
	n, err := conn.Read(buf)
	if err != nil {
		log.Println("è¯»å–é”™è¯¯:", err)
		return
	}
	clientMsg := string(buf[:n])
	fmt.Println("ğŸ“© æ”¶åˆ°å®¢æˆ·ç«¯:", clientMsg)

	// æœåŠ¡ç«¯è§£å¯†ååŠ å…¥æ•°æ®
	resp := clientMsg + " + server-data"

	// åŠ å¯†åå‘é€å›å®¢æˆ·ç«¯
	_, _ = conn.Write([]byte(resp))
}

func main() {
	// åˆå§‹åŠ è½½è¯ä¹¦
	tlsConfig.Store(loadTLSConfig())

	// å¼€å¯è¯ä¹¦çƒ­é‡è½½
	go watchCert()

	ln, err := tls.Listen("tcp", ":8443", tlsConfig.Load().(*tls.Config))
	if err != nil {
		log.Fatal("å¯åŠ¨æœåŠ¡å¤±è´¥:", err)
	}
	defer ln.Close()
	fmt.Println("ğŸš€ TLS æœåŠ¡å¯åŠ¨åœ¨ :8443")

	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Println("accept é”™è¯¯:", err)
			continue
		}
		go handleConn(conn)
	}
}
```

<br/> 

**3.å®¢æˆ·ç«¯**

```go
package main

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"os"
)

func main() {
	cert, _ := tls.LoadX509KeyPair("cert.pem", "key.pem")

	certPool := x509.NewCertPool()
	caCert, _ := os.ReadFile("cert.pem")
	certPool.AppendCertsFromPEM(caCert)

	tlsConfig := &tls.Config{
		Certificates: []tls.Certificate{cert},
		RootCAs:      certPool,
	}

	conn, err := tls.Dial("tcp", "localhost:8443", tlsConfig)
	if err != nil {
		panic(err)
	}
	defer conn.Close()

	msg := "hello-from-client"
	fmt.Println("â¡ï¸ å‘é€:", msg)
	_, _ = conn.Write([]byte(msg))

	buf := make([]byte, 4096)
	n, _ := conn.Read(buf)
	fmt.Println("â¬…ï¸ æ”¶åˆ°:", string(buf[:n]))
}
```

<br/> 

**4.è¿è¡Œæµç¨‹**

**1.ç”Ÿæˆè¯ä¹¦ï¼š**

   ```bash
   go run generate_cert.go
   ```

<br/>

2.å¯åŠ¨æœåŠ¡ç«¯ï¼š

   ```bash
   go run server.go
   ```

<br/>

3. å¯åŠ¨å®¢æˆ·ç«¯ï¼š

   ```bash
   go run client.go
   ```

æ•ˆæœï¼š

```
å®¢æˆ·ç«¯:
â¡ï¸ å‘é€: hello-from-client
â¬…ï¸ æ”¶åˆ°: hello-from-client + server-data

æœåŠ¡ç«¯:
ğŸ“© æ”¶åˆ°å®¢æˆ·ç«¯: hello-from-client
```

---
<br/>

**ğŸ”‘ æ ¸å¿ƒè¦ç‚¹**

* `generate_cert.go` ç”¨ Go ç”Ÿæˆ **è‡ªç­¾åè¯ä¹¦**ï¼Œæ›¿ä»£ OpenSSLã€‚
* æœåŠ¡ç«¯ `tls.Listen` ç›‘å¬ **TCP+TLS**ï¼Œæ¥æ”¶åŠ å¯†æ•°æ®ã€‚
* å®¢æˆ·ç«¯ `tls.Dial` å»ºç«‹ TLS è¿æ¥ï¼Œè‡ªåŠ¨ **åŠ å¯†/è§£å¯†ä¼ è¾“**ã€‚
* æœåŠ¡ç«¯é€šè¿‡ `fsnotify` å®ç° **çƒ­é‡è½½è¯ä¹¦**ï¼Œä¸ä¸­æ–­æœåŠ¡å³å¯åˆ‡æ¢æ–°è¯ä¹¦ã€‚
* åŒå‘è®¤è¯ï¼šæœåŠ¡ç«¯è¦æ±‚ `ClientAuth: tls.RequireAndVerifyClientCert`ã€‚


***
<br/><br/><br/>
> <h2 id="åŠ å¯†å’ŒéåŠ å¯†ç›‘å¬">åŠ å¯†å’ŒéåŠ å¯†ç›‘å¬</h2>

Go é‡Œ `net.Listen` ç”¨æ¥å¯åŠ¨ä¸€ä¸ª**ç›‘å¬å™¨ï¼ˆListenerï¼‰**ï¼Œè¿”å›ä¸€ä¸ªå®ç°äº† `net.Listener` æ¥å£çš„å¯¹è±¡ï¼š

```go
ln, err := net.Listen(network, address)
```

- **ğŸ‘‰ è¿™æ˜¯ä¸€ä¸ªæ™®é€šçš„ç›‘å¬å™¨ï¼Œç›´æ¥ç›‘å¬åœ¨ TCP æˆ– Unix Socket ä¸Šï¼Œä¸å¸¦åŠ å¯†ã€‚**

	* å®¢æˆ·ç«¯è¿ä¸Šæ¥ï¼Œæ•°æ®æ˜¯ **æ˜æ–‡ä¼ è¾“**ã€‚
	* å¸¸ç”¨äºæ™®é€š TCP æœåŠ¡ã€å†…éƒ¨é€šä¿¡ï¼Œæˆ–è€…åé¢è‡ªå·±å†åšåŠ å¯†ï¼ˆæ¯”å¦‚ä½ å‰é¢æåˆ°çš„ RSA/ECIES ç«¯åˆ°ç«¯åŠ å¯†ï¼‰ã€‚
	* `network`ï¼šç½‘ç»œç±»å‹ï¼Œæ¯”å¦‚ `"tcp"`, `"udp"`, `"unix"`, `"tcp4"`, `"tcp6"`ã€‚
	* `address`ï¼šç›‘å¬çš„åœ°å€ã€‚

	  * å¯¹ TCPï¼š`"host:port"`ï¼Œå¦‚ `"127.0.0.1:8080"`ã€`":8080"`ï¼ˆè¡¨ç¤ºæ‰€æœ‰ç½‘å¡ï¼‰ã€‚
	  * å¯¹ Unix socketï¼š`"/tmp/app.sock"`ã€‚

è¿”å›å€¼ `ln` æ˜¯ä¸€ä¸ª `net.Listener`ï¼Œä½ å¯ä»¥ç”¨ `ln.Accept()` ç­‰æ–¹æ³•æ¥æ”¶è¿æ¥ã€‚

<br/><br/>

**åŠ å¯†ç›‘å¬ï¼š**

```go
n.httpsListener, err = tls.Listen("tcp", opts.HTTPSAddress, n.tlsConfig)
```

<br/>

ğŸ‘‰ è¿™æ˜¯ä¸€ä¸ª **TLS ç›‘å¬å™¨**ï¼Œå®ƒæœ¬è´¨ä¸Šæ˜¯ï¼š

```go
ln, err := net.Listen("tcp", addr)
return tls.NewListener(ln, config)
```

ä¹Ÿå°±æ˜¯è¯´ï¼š

* å…ˆå¼€ä¸€ä¸ª TCP ç›‘å¬ã€‚
* ç„¶åæŠŠå®ƒåŒ…ä¸€å±‚ `tls.NewListener`ï¼Œè¿™æ ·æ‰€æœ‰ `Accept()` æ¥æ”¶åˆ°çš„è¿æ¥ï¼Œéƒ½ä¼šåœ¨ **æ¡æ‰‹é˜¶æ®µè¿›è¡Œ TLS/SSL åè®®åå•†**ï¼Œæ•°æ®ä¼ è¾“æ˜¯ **åŠ å¯†çš„**ã€‚

<br/>

 **åŒºåˆ«å¯¹æ¯”**

| é¡¹ç›®   | `net.Listen`         | `tls.Listen`            |
| ---- | -------------------- | ----------------------- |
| åè®®å±‚  | TCP/Unix socket åŸå§‹è¿æ¥ | åœ¨ TCP ä¹‹ä¸ŠåŠ ä¸€å±‚ TLS         |
| æ•°æ®å®‰å…¨ | æ˜æ–‡ä¼ è¾“                 | åŠ å¯†ä¼ è¾“ï¼ˆåŸºäºè¯ä¹¦ã€TLS æ¡æ‰‹ï¼‰       |
| ç”¨é€”   | å†…éƒ¨é€šä¿¡ã€æ— åŠ å¯†æœåŠ¡           | HTTPS æœåŠ¡å™¨ã€åŠ å¯† TCP æœåŠ¡     |
| é…ç½®éœ€æ±‚ | ä¸éœ€è¦é¢å¤–é…ç½®              | éœ€è¦ `tls.Config`ï¼ˆè¯ä¹¦ã€ç§é’¥ç­‰ï¼‰ |


<br/>

 **å¯¹æ¯”**

**æ™®é€š TCP æœåŠ¡ï¼ˆä¸åŠ å¯†ï¼‰**

```go
ln, _ := net.Listen("tcp", ":8080")
for {
    conn, _ := ln.Accept()
    go func(c net.Conn) {
        buf := make([]byte, 1024)
        n, _ := c.Read(buf)
        fmt.Println("æ”¶åˆ°:", string(buf[:n]))
        c.Write([]byte("Hello (plain TCP)\n"))
    }(conn)
}
```

<br/>

**TLS åŠ å¯†æœåŠ¡ï¼ˆç±»ä¼¼ HTTPSï¼‰**

```go
cert, _ := tls.LoadX509KeyPair("server.crt", "server.key")
config := &tls.Config{Certificates: []tls.Certificate{cert}}

ln, _ := tls.Listen("tcp", ":8443", config)
for {
    conn, _ := ln.Accept()
    go func(c net.Conn) {
        buf := make([]byte, 1024)
        n, _ := c.Read(buf)
        fmt.Println("æ”¶åˆ°:", string(buf[:n]))
        c.Write([]byte("Hello (TLS encrypted)\n"))
    }(conn)
}
```

<br/>

âœ… æ‰€ä»¥ç»“è®ºï¼š

* `net.Listen` å°±æ˜¯æœ€åŸå§‹çš„ç›‘å¬ï¼Œæ˜æ–‡æ•°æ®ã€‚
* `tls.Listen` æ˜¯åœ¨ TCP ä¸ŠåŠ äº†ä¸€å±‚ TLS åŠ å¯†ï¼Œé€‚åˆåš HTTPS / å®‰å…¨é€šä¿¡ã€‚






<br/><br/><br/>

***
<br/>

> <h1 id="å¹¶å‘å®‰å…¨">å¹¶å‘å®‰å…¨</h1>


***
<br/><br/><br/>
> <h2 id="å®‰å…¨ä¿å­˜å¤šä¸ªå®¢æˆ·ç«¯é“¾æ¥">å®‰å…¨ä¿å­˜å¤šä¸ªå®¢æˆ·ç«¯é“¾æ¥</h2>

**`conns sync.Map`** åœ¨ Go é‡Œç»å¸¸ç”¨åˆ°ï¼Œå°¤å…¶æ˜¯å†™å¹¶å‘ç½‘ç»œç¨‹åºæ—¶ã€‚

<br/>

**1.ä»€ä¹ˆæ˜¯ `sync.Map`ï¼Ÿ**

* `sync.Map` æ˜¯ Go **æ ‡å‡†åº“ `sync` åŒ…**é‡Œçš„ä¸€ä¸ªå¹¶å‘å®‰å…¨çš„ Mapã€‚
* å®ƒå’Œæ™®é€šçš„ `map[K]V` ä¸åŒï¼Œæ™®é€š map **ä¸æ˜¯å¹¶å‘å®‰å…¨**çš„ï¼Œåœ¨å¤š goroutine åŒæ—¶è¯»å†™æ—¶å¯èƒ½å¯¼è‡´ **fatal error: concurrent map writes**ã€‚
* `sync.Map` å†…éƒ¨å®ç°äº† **è¯»å†™é” + åŸå­æ“ä½œ**ï¼Œä¿è¯åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹å¯ä»¥å®‰å…¨åœ°è¯»å†™ã€‚

<br/>

**2.`conns sync.Map` çš„ä½œç”¨**

åœ¨ä½ çš„åœºæ™¯é‡Œï¼ˆæœåŠ¡ç«¯ã€å®¢æˆ·ç«¯ï¼ŒTLS/åŠ å¯†é€šä¿¡ï¼‰ï¼Œæˆ‘ä»¬éœ€è¦ä¿å­˜å¤šä¸ªå®¢æˆ·ç«¯çš„è¿æ¥ã€‚
é€šå¸¸ä¼šå®šä¹‰ï¼š

```go
type Server struct {
    conns sync.Map // ä¿å­˜æ‰€æœ‰æ´»è·ƒçš„å®¢æˆ·ç«¯è¿æ¥
}
```

è¿™æ ·å°±å¯ä»¥å®‰å…¨åœ°åœ¨å¤šä¸ª goroutine ä¸­ **åŒæ—¶å­˜å–è¿æ¥**ã€‚

**3.`sync.Map` çš„å¸¸ç”¨æ–¹æ³•**

**ï¼ˆ1ï¼‰å­˜å‚¨è¿æ¥**

```go
server.conns.Store(connID, conn)
```

* `connID` å¯ä»¥æ˜¯ä¸€ä¸ªå”¯ä¸€æ ‡è¯†ï¼ˆæ¯”å¦‚å®¢æˆ·ç«¯ IP+ç«¯å£ï¼Œæˆ–è€…è‡ªå¢ IDï¼‰ã€‚
* `conn` å°±æ˜¯ä¸€ä¸ªå®¢æˆ·ç«¯çš„è¿æ¥ï¼ˆå¦‚ `net.Conn`ï¼‰ã€‚

<br/>

**ï¼ˆ2ï¼‰è¯»å–è¿æ¥**

```go
value, ok := server.conns.Load(connID)
if ok {
    conn := value.(net.Conn) // ç±»å‹æ–­è¨€
    // å¯ä»¥å¯¹ conn è¿›è¡Œæ“ä½œï¼Œæ¯”å¦‚å†™æ¶ˆæ¯
}
```

<br/>

**ï¼ˆ3ï¼‰åˆ é™¤è¿æ¥**

```go
server.conns.Delete(connID)
```

* å½“å®¢æˆ·ç«¯æ–­å¼€æ—¶ï¼Œå°±ä» map ä¸­åˆ æ‰ã€‚

<br/>

**ï¼ˆ4ï¼‰éå†æ‰€æœ‰è¿æ¥ï¼ˆå¹¿æ’­ï¼‰**

```go
server.conns.Range(func(key, value interface{}) bool {
    conn := value.(net.Conn)
    conn.Write([]byte("hello all"))
    return true // è¿”å› true è¡¨ç¤ºç»§ç»­éå†
})
```

<br/>

**4.åº”ç”¨åœºæ™¯**

å‡è®¾æœåŠ¡ç«¯è¦ä¿å­˜æ‰€æœ‰ TLS è¿æ¥ï¼Œå¹¶æ”¯æŒ**å¹¿æ’­æ¶ˆæ¯**ï¼Œå°±ä¼šç”¨åˆ°ï¼š

```go
type Server struct {
    conns sync.Map
}

func (s *Server) addConn(id string, conn net.Conn) {
    s.conns.Store(id, conn)
}

func (s *Server) removeConn(id string) {
    s.conns.Delete(id)
}

func (s *Server) broadcast(msg string) {
    s.conns.Range(func(key, value interface{}) bool {
        conn := value.(net.Conn)
        conn.Write([]byte(msg))
        return true
    })
}
```

è¿™æ ·ï¼š

* **å¤šå®¢æˆ·ç«¯åŒæ—¶è¿æ¥** â†’ `sync.Map` ä¿è¯ä¸ä¼šå‡ºé”™ã€‚
* **å¹¿æ’­æ¶ˆæ¯** â†’ éå† `sync.Map` å³å¯ã€‚
* **ç§»é™¤æ–­å¼€è¿æ¥** â†’ è°ƒç”¨ `Delete`ã€‚

<br/>

**å’Œæ™®é€š `map` å¯¹æ¯”**

| ç‰¹æ€§   | `map[K]V`  | `sync.Map`       |
| ---- | ---------- | ---------------- |
| å¹¶å‘å®‰å…¨ | âŒ ä¸æ˜¯       | âœ… æ˜¯              |
| æ€§èƒ½   | æ›´å¿«ï¼ˆæ— é”ï¼‰     | è¾ƒæ…¢ï¼ˆåŠ é”/åŸå­æ“ä½œï¼‰      |
| é€‚ç”¨åœºæ™¯ | å•çº¿ç¨‹ / æœ‰é”ä¿æŠ¤ | å¤š goroutine å¹¶å‘è®¿é—® |


<br/><br/>

**ç¤ºä¾‹ï¼šå¤šåç¨‹å®‰å…¨å­˜å–è¿æ¥å¯¹è±¡**

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªç®€å•çš„â€œèŠå¤©å®¤æœåŠ¡ç«¯â€ï¼Œéœ€è¦ç»´æŠ¤æ‰€æœ‰å®¢æˆ·ç«¯è¿æ¥ã€‚æˆ‘ä»¬ç”¨ `sync.Map` æ¥ä¿å­˜è¿æ¥ï¼š

```go
package main

import (
	"fmt"
	"net"
	"sync"
	"time"
)

type Client struct {
	ID   string
	Conn net.Conn
}

var conns sync.Map // ç”¨æ¥å­˜å‚¨æ‰€æœ‰å®¢æˆ·ç«¯è¿æ¥ (key=å®¢æˆ·ç«¯ID, value=*Client)

func handleConnection(conn net.Conn, id string) {
	defer conn.Close()

	client := &Client{ID: id, Conn: conn}
	// å­˜å‚¨å®¢æˆ·ç«¯è¿æ¥
	conns.Store(id, client)
	fmt.Println("å®¢æˆ·ç«¯å·²è¿æ¥:", id)

	// æ¨¡æ‹Ÿæ¥æ”¶å’Œå¤„ç†æ¶ˆæ¯
	buf := make([]byte, 1024)
	for {
		n, err := conn.Read(buf)
		if err != nil {
			fmt.Println("å®¢æˆ·ç«¯æ–­å¼€:", id)
			conns.Delete(id) // åˆ é™¤å®¢æˆ·ç«¯
			return
		}
		msg := string(buf[:n])
		fmt.Printf("æ”¶åˆ°æ¥è‡ª %s çš„æ¶ˆæ¯: %s\n", id, msg)

		// å›å¤å®¢æˆ·ç«¯
		reply := fmt.Sprintf("ä½ å¥½ %s, æˆ‘æ”¶åˆ°äº†: %s", id, msg)
		conn.Write([]byte(reply))
	}
}

func main() {
	// å¯åŠ¨ä¸€ä¸ª TCP æœåŠ¡
	ln, err := net.Listen("tcp", ":8080")
	if err != nil {
		panic(err)
	}
	fmt.Println("æœåŠ¡å¯åŠ¨ï¼Œç›‘å¬ :8080")

	// å®šæ—¶æ‰“å°å½“å‰è¿æ¥æ•°
	go func() {
		for {
			count := 0
			conns.Range(func(key, value any) bool {
				count++
				return true
			})
			fmt.Println("å½“å‰åœ¨çº¿å®¢æˆ·ç«¯æ•°é‡:", count)
			time.Sleep(5 * time.Second)
		}
	}()

	// æ¥å—è¿æ¥
	idCounter := 0
	for {
		conn, err := ln.Accept()
		if err != nil {
			fmt.Println("è¿æ¥é”™è¯¯:", err)
			continue
		}
		idCounter++
		clientID := fmt.Sprintf("user-%d", idCounter)
		go handleConnection(conn, clientID)
	}
}
```

<br/>

**ä»£ç è§£è¯»**

1. **å®šä¹‰å…¨å±€è¿æ¥è¡¨**

```go
var conns sync.Map
```

   `sync.Map` ä»£æ›¿æ™®é€šçš„ `map[string]*Client`ï¼Œä¸ç”¨åŠ é”ï¼Œå¤©ç„¶æ”¯æŒå¤šåç¨‹å®‰å…¨ã€‚

2. **å­˜å‚¨è¿æ¥**

   ```go
   conns.Store(id, client)
   ```

   è¿™é‡ŒæŠŠ `å®¢æˆ·ç«¯ID` ä½œä¸º keyï¼ŒæŠŠ `*Client` ä½œä¸º value å­˜è¿› `sync.Map`ã€‚

3. **åˆ é™¤è¿æ¥**

   ```go
   conns.Delete(id)
   ```

   å½“å®¢æˆ·ç«¯æ–­å¼€æ—¶ï¼Œåˆ é™¤å®ƒçš„è¿æ¥ã€‚

4. **éå†è¿æ¥**

   ```go
   conns.Range(func(key, value any) bool {
       count++
       return true
   })
   ```

   `Range` éå† `sync.Map`ï¼Œå¸¸ç”¨äºå¹¿æ’­æ¶ˆæ¯æˆ–ç»Ÿè®¡å½“å‰è¿æ¥æ•°ã€‚

<br/>

 **ä½¿ç”¨åœºæ™¯**

* èŠå¤©å®¤ç»´æŠ¤æ‰€æœ‰åœ¨çº¿ç”¨æˆ·è¿æ¥ã€‚
* WebSocket/TCP æœåŠ¡ç«¯ï¼Œç®¡ç†æˆç™¾ä¸Šåƒçš„å¹¶å‘è¿æ¥ã€‚
* å…±äº«ç¼“å­˜ï¼ˆé«˜å¹¶å‘ç¯å¢ƒä¸‹çš„ KV ç¼“å­˜ï¼‰ã€‚






