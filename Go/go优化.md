> </h1>
- [**数据库原理**](#数据库原理)
- [**数据库优化**](#数据库优化)
- [**大量数据时的索引优化**](#大量数据时的索引优化)
- [**索引原理**](#索引原理)
- [减少频繁分配内存](#减少频繁分配内存)

要使用好ORM，其核心还是掌握关系型数据库的原理、优化、索引等。受自身项目所限，读者使用基本的SQL功能就能完成任务，如果数据量大了，那么势必会遇到查询缓慢的问题；如果服务失联，那么势必会遇到数据丢失的问题。这些才是关系型数据库使用的核心，读者需要懂得索引的原理、索引的优化，才能设计更加健壮的模型，完成任务的同时使系统具备持续迭代的能力。

建议读者熟练掌握编程语言的同时多研究基础原理，这些原理的掌握才是读者应对繁复变化的核心竞争力。

<br/>

***
<br/><br/><br/>
> <h1 id="数据库原理">数据库原理</h1>


<br/><br/><br/>

***
<br/>
> <h1 id="数据库优化">数据库优化</h1>


<br/><br/><br/>

***
<br/>
> <h1 id="大量数据时的索引优化">大量数据时的索引优化</h1>


<br/><br/><br/>

***
<br/>
> <h1 id="索引原理">索引原理</h1>


<br/><br/><br/>

***
<br/>

> <h1 id="减少频繁分配内存">减少频繁分配内存</h1>


**复用 `bytes.Buffer`，减少频繁分配内存**。

<br/> 

**1️⃣ `sync.Pool`**

```go
var bp sync.Pool
```

* `sync.Pool` 是 Go 标准库里的一个结构，作用是**缓存可重复利用的对象**，避免频繁 `new` / `GC`。
* 适合那些「生命周期很短、创建代价不大」的对象，例如 `bytes.Buffer`、临时切片等。

> **特点**：
>
> * `Pool` 里的对象不保证长期存在，GC 可能把它们回收。
> * 多 goroutine 并发使用是安全的。

<br/> 

**2️⃣ 初始化 `Pool`**

```go
func init() {
    bp.New = func() interface{} {
        return &bytes.Buffer{}
    }
}
```

* `Pool.New` 是一个 **工厂函数**：当 `Get()` 时池子里没有可用对象，就会调用这个函数创建新的。
* 这里返回 `&bytes.Buffer{}` —— 一个新的缓冲区。


- **init 是 Go 的一个特殊函数：**
	- 名字必须是 init（没有参数、没有返回值）。
	- 不能被手动调用。
	- 每个包里可以有多个 init，它们会在 main() 之前自动执行，用来做初始化工作。

<br/> 

**3️⃣ 取出对象**

```go
func bufferPoolGet() *bytes.Buffer {
    return bp.Get().(*bytes.Buffer)
}
```

* `bp.Get()` 从池里取一个对象：

  * 如果池里有 → 返回已有对象。
  * 如果没有 → 调用 `bp.New` 创建。
* 因为 `Pool` 存的是 `interface{}`，所以要做类型断言 `.(*bytes.Buffer)`，拿到真正的类型。

<br/> 

**4️⃣ 放回对象**

```go
func bufferPoolPut(b *bytes.Buffer) {
    b.Reset()   // 清空缓冲区内容，避免旧数据被下一个使用者看到
    bp.Put(b)   // 把对象放回池里，供后续复用
}
```

* `Reset()`：清空 `Buffer` 的内容，但不释放底层内存。
* `bp.Put(b)`：把对象归还池子。


<br/>

这里说的 **“没有释放底层内存”** 指的是 `bytes.Buffer.Reset()` 的行为。

- `bytes.Buffer` 内部其实是一个 `[]byte` 切片，用来存放数据。
- 当你写入数据时，这个切片的容量 (cap) 可能会逐渐变大。

```go
b := &bytes.Buffer{}
b.WriteString("hello world") // 底层 []byte 现在有容量
```


如果之后调用：

```go
b.Reset()
```


Reset() 只会把 长度 置为 0，让 Buffer 看起来“空”了，但 不会把底层那块已经分配好的内存归还给 Go 运行时，容量还是原来的。
所以下一次写数据，Buffer 可以直接复用之前分配的内存，而不用重新分配一块新的。

<br/>

**📌 好处：**

频繁复用 bytes.Buffer 时，避免每次都重新申请内存，性能更好。

这也是 sync.Pool + bytes.Buffer 常见搭配的原因。

<br/>

**📌 注意：**

如果 buffer 很大，而后面不再需要这么大容量，想真正释放那块内存，就不能只 Reset()；最简单的方式是丢弃这个 Buffer，让它不再被引用，交给 GC 回收。


***
<br/><br/>


**5️⃣ 使用示例**

```go
b := bufferPoolGet()        // 从池里拿一个 *bytes.Buffer
b.WriteString("hello pool") // 使用
fmt.Println("len:", b.Len(), "cap:", b.Cap()) // len: 11, cap: 64(示例)

b.Reset()
fmt.Println("after reset -> len:", b.Len(), "cap:", b.Cap()) // len:0, cap 仍然是64
```

**输出**里可以看到 Reset() 后长度为 0，但容量没变，这就是“没有释放底层内存”的意思。

下次再 `bufferPoolGet()`，可能就会直接拿到这个 `buf`（内容已被 `Reset()`）。

<br/> 

**6️⃣ 为什么要这么做？**

* 避免频繁 `new(bytes.Buffer)` 和垃圾回收。
* 提高性能，尤其在高并发或需要频繁创建临时缓冲区的场景。

👉 例如在 HTTP 服务器里，每个请求都要临时拼接字符串，用 `sync.Pool` 可以减少内存分配压力。

<br/> 

**7️⃣ 总结表**

| 代码片段               | 作用             |
| ------------------ | -------------- |
| `var bp sync.Pool` | 定义全局对象池        |
| `bp.New = ...`     | 指定池子空时如何创建新对象  |
| `bp.Get()`         | 从池子获取对象（或新建）   |
| `b.Reset()`        | 清空 `Buffer` 内容 |
| `bp.Put(b)`        | 把用完的对象放回池子     |

<br/> 

> 这段代码实现了一个 `bytes.Buffer` 的复用池，用来避免频繁创建和销毁缓冲区，提升性能、降低 GC 压力。







