<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MVVM设计模式(一)</title>
    <style type="text/css" media="all">
      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif;
        font-size: 14px;
        line-height: 20px;
        color: #777;
        background-color: white;
      }
      .container {
        width: 700px;
        margin-right: auto;
        margin-left: auto;
      }

      .post {
        font-family: Georgia, "Times New Roman", Times, "SimSun", serif;
        position: relative;
        padding: 70px;
        bottom: 0;
        overflow-y: auto;
        font-size: 16px;
        font-weight: normal;
        line-height: 25px;
        color: #515151;
      }

      .post h1{
        font-size: 50px;
        font-weight: 500;
        line-height: 60px;
        margin-bottom: 40px;
        color: inherit;
      }

      .post p {
        margin: 0 0 35px 0;
      }

      .post img {
        border: 1px solid #D9D9D9;
      }

      .post a {
        color: #28A1C5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="post">
        <h1 class="title">MVVM设计模式(一)</h1>
        <div class="show-content">
          <h1><b>MVVM的定义：</b></h1><p>①. <b>Model</b>- model 在 MVVM 中没有真正的变化. 取决于你的偏好, 你的 model 可能会或可能不会封装一些额外的业务逻辑工作. 我更倾向于把它当做一个容纳表现数据-模型对象信息的结构体, 并在一个单独的管理类中维护的创建/管理模型的统一逻辑.</p><p><b>②. View</b>- view 包含实际 UI 本身(不论是UIView代码, storyboard 和 xib), 任何视图特定的逻辑, 和对用户输入的反馈. 在 iOS 中这不仅需要UIView代码和那些文件, 还包括很多需由UIViewController处理的工作.</p><p><b>③. View-Model</b>- 这个术语本身会带来困惑, 因为它混搭了两个我们已知的术语, 但却是完全不同的东东. 它不是传统数据-模型结构中模型的意思(又来了, 只是我喜欢这个例子). 它的职责之一就是作为一个表现视图显示自身所需数据的静态模型;但它也有收集, 解释和转换那些数据的责任. 这留给了 view (controller) 一个更加清晰明确的任务: 呈现由 view-model 提供的数据.</p><p>View-Model 的总结：</p><blockquote><p>view-model一词的确不能充分表达我们的意图. 一个更好的术语可能是 “View Coordinator”(感谢 Dave Lee 提的这个 “View Coordinator” 术语, 真是个好点子). 你可以认为它就像是电视新闻主播背后的研究人员和作家团队. 它从必要的资源(数据库, 网络服务调用, 等)中获取原始数据, 运用逻辑, 并处理成 view (controller) 的展示数据. 它(通常通过属性)暴露给视图控制器需要知道的仅关于显示视图工作的信息(理想地你不会暴漏你的 data-model 对象). 它还负责对上游数据的修改(比如更新模型/数据库, API POST 调用)</p></blockquote><hr><p>MVC 中的 MVVM:</p><p>为了图解表示, 我们颠倒了<b>MVC</b>中的<b>V</b>和<b>C</b>, 于是首字母缩写更能准确地反映出组件间的关系方位, 给我们带来<b>MCV</b>. 我也会对<b>MVVM</b>这么干, 将<b>V(iew)</b>移到<b>VM</b>的右边最终成为了<b>MVMV</b>. (我相信这些首字母缩写起初不排成这样更合理的顺序是有原因的. )</p><p>下面让我们来看个简单的映射：</p><p><br></p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/2959789-a945be9cd9190bc4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="auto" height="auto"><br><div class="image-caption">MVC和MVVM的映射</div>
</div><p>a. 我试图遵循区块尺寸(非常)大致对应它们负责的工作量.</p><p>b. 你可以看到我们巨大的视图控制器和 view-model 之间有大块工作上的重合.</p><p>c. 你也可以看看视图控制器在 MVVM 中的足迹有多大一部分是跟视图重合的.</p><p>我们试图将重合的那块工作区域剥离到 view-model 中, 并让视图控制器的更加简洁。</p><p>实际上最终以<b>MVMCV</b>告终.<b>M</b>odel<b>V</b>iew-<b>M</b>odel<b>C</b>ontroller<b>V</b>iew作为结点。</p><p><br></p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/2959789-6d732da5a18f6b21.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="auto" height="auto"><br><div class="image-caption">融合</div>
</div><p>现在视图控制器仅关注用 view-model 的数据配置和管理各种各样的视图, 并先于用户输入时让 view-model 获知并需要向上游修改数据. 视图控制器不需要了解关于网络服务调用, Core Data, 模型对象等. (事实上有时通过 view-model 头文件而不是复制一大堆属性来暴漏 model 是很务实的, 后面还会有)</p><p>view-model 会在视图控制器上以一个属性的方式存在. 视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知. </p><p>帮助你理解我们如何把组件组装在一起还有组件对应职责的另一种方式, 就是着眼于我们新的应用构建模块层级图.</p><p><br></p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/2959789-3b55dd7c1dda4db6.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="auto" height="auto"><br><div class="image-caption">对应关系图</div>
</div><p><br></p><hr><h1><b>View-Model 和 View Controller 在一起，但独立</b></h1><p>我们来看个简单的 view-model 头文件来，以便对你有个更好地概念. 为了情节简单, 我们构建按了一个伪造的推特客户端来查看任何推特用户的最新回复, 通过输入他们的姓名并点击 “Go”. 我们的样例界面将会是这样:</p><p>a. 有一个让用户输入他们姓名的UITextField, 和一个写着 “Go” 的UIButton</p><p>b. 有显示被查看的当前用户头像和姓名的UIImageView和UILabel各一个</p><p>c. 下面放着一个显示最新回复推文的UITableView</p><p>d. 允许无限滚动</p><p><br></p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/2959789-4924000f7bc8aca0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="auto" height="auto"><br><div class="image-caption"></div>
</div><blockquote><p>这里的view-model因该这样定义：view-model 暴漏视图控制器所必需的最小量信息, 视图控制器实际上并不在乎 view-model 是如何获得这些信息的. 现在我们两者都不在乎. 仅仅假定你习惯于标准的网络服务请求, 校验, 数据操作和存储.</p></blockquote><p>view-model 不做的事：对视图控制器以任何形式直接起作用或直接通告其变化</p><hr><p>View Controller要做的事：</p><p>视图控制器从 view-model 获取的数据将用来:</p><blockquote>
<p>当 usernameValid 的值发生变化时触发 “Go” 按钮的 enabled 属性</p>
<p> 当 usernameValid 等于 NO 时调整按钮的 alpha 值为0. 5(等于 YES 时设为1. 0) </p>
<p>更新 UILable 的 text 属性为字符串 userFullName 的值 </p>
<p>更新 UIImageView 的 image 属性为 userAvatarImage 的值</p>
<p> 用 tweets 数组中的对象设置表格视图中的 cell (后面会提到) 当滑到表格视图底部时如果 allTweetsLoaded 为 NO , 提供一个 显示 “loading” 的 cell </p>
</blockquote><p>视图控制器不做的事:</p><blockquote>
<p>发起网络服务调用</p>
<p>管理tweets数组</p>
<p>判定username内容是否有效</p>
<p>将用户的姓和名格式化为全名</p>
<p>下载用户头像并转成UIImage(如果你习惯在UIImageView上使用类别从网络加载图片, 你可以暴漏 URL 而不是图片. 这样没有让 view-model 和 UIKit 更完全摆脱, 但我视UIImage为数据而非数据的确切显示. 这些东西不是固定死的. )</p>
</blockquote><p>注意：视图控制器总的责任是处理 view-model 中的变化.</p><p>视图控制器将对 view-model 起如下作用:</p><blockquote>
<p>每当UITextField中的文本发生变化, 更新 view-model 上仅有的readwrite属性username</p>
<p>当 “Go” 按钮被按下时调用 view-model 上的getTweetsForCurrentUsername方法</p>
<p>当到达表格中的 “loading” cell 时调用 view-model 上的loadMoreTweets方法</p>
</blockquote><hr><p>子 view-model的作用：</p><p>使用 view-model 上的tweets数组中的对象配置表格视图的 cell. 通常你会期待展现tweets的是数据-模型对象. 你可能已经对其感到奇怪, 因为我们试图通过 MVVM 模式不暴漏数据-模型对象. (前面提到过的)</p><p>view-model 不必在屏幕上显示所有东西.你可用子 view-model 来代表屏幕上更小, 更潜在被封装的部分. 如果一个视图上的一小块儿(比如表格的 cell)在 app 中可以被重用以及(或)表现多个数据-模型对象, 子 view-model 会格外有利</p><p><br></p><hr><h1><b>View-Model 产生 View-Model</b></h1><blockquote><p>严格来说, 你应该为 app delegate 中的顶级视图控制器创建一个 view-model. 当展示一个新的视图控制器时, 或很小的视图被 view-model 表现时, 你应要求当前的 view-model 为你创建一个子 view-model.</p></blockquote><p><br></p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/2959789-720d0e181d04fb59.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>假如我们想要在用户轻拍应用顶部的头像时添加一个资料视图控制器. 我们可以为一级 view-model 添加类似如下方法:</p><blockquote><p>- (MYTwitterUserProfileViewModel *) viewModelForCurrentUser;</p></blockquote><p>然后在我们的一级视图控制器中这么用它:</p><p>在这个例子中我将会展现当前用户的资料视图控制器, 但是我的资料视图控制器需要一个 view-model. 我这的主视图控制器不知道用于创建关联相关用户 view-model 的全部必要数据, 所以它请求它自己的 view-model 来干这种创建新 view-model 的苦差事.(这就助长和造成了逻辑混乱，代码烦乱的开始)</p><h2><b>View-Model 列表</b></h2><p>至于我们的推特 cell, 当数据驱动屏幕(在这个例子中或许是通过网络服务调用)聚到一起时, 我将会代表性地提前为对应的 cell 创建所有的 view-model. 所以在我们这个方案中,tweets将会是一个MYTweetCellViewModel对象数组. 在我的表格视图中的cellForRowAtIndexPath方法中, 我将会在正确的索引上简单地抓取 view-model, 并把它赋值给我的 cell 上的 view-model 属性.</p><p><a href="http://www.jianshu.com/writer#/notebooks/20046551/notes/21256875" target="_blank">MVVM(二)</a></p>
        </div>
      </div>
    </div>
  </body>
</html>
