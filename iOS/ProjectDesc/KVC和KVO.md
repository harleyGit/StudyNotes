
- **KVC**
	- KVC处理数值和结构体类型属性
- **KVO**
	- KVO实现的原理
- [**KVC和KVO详解**](https://www.jianshu.com/p/b9f020a8b4c9)


<br/>

***
<br/>

># KVC

&emsp; ` KVC（Key-Value-Coding）`键值编码，就是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态地访问和修改对象的属性。而不是在编译时确定，这也是iOS开发中的黑魔法之一。很多高级的iOS开发技巧都是基于KVC实现的。



<br/>


- **`KVC处理数值和结构体类型属性`**

&emsp;  不是每一个方法都返回对象，但是valueForKey：总是返回一个id对象，如果原本的变量类型是值类型或者结构体，返回值会封装成NSNumber或者NSValue对象。

&emsp;  这两个类会处理从数字，布尔值到指针和结构体任何类型。然后开发者需要手动转换成原来的类型。

&emsp;  尽管valueForKey：会自动将值类型封装成对象，但是setValue：forKey：却不行。你必须手动将值类型转换成NSNumber或者NSValue类型，才能传递过去。

&emsp;  因为传递进去和取出来的都是id类型，所以需要开发者自己担保类型的正确性，运行时Objective-C在发送消息的会检查类型，如果错误会直接抛出异常。



<br/>

***
<br/>

>#  KVO

&emsp;  `KVO (即 Key-Value-Observing)`，翻译成键值观察。它是一种观察者模式的衍生。其基本思想是，对目标对象的某属性添加观察，当该属性发生变化时，通过触发观察者对象实现的KVO接口方法，来自动的通知观察者。


<br/>

- **`KVO实现的原理`**

&emsp;  KVO 是通过 isa-swizzling 实现的。

&emsp;  基本的流程就是编译器自动为被观察对象创造一个派生类，并将被观察对象的isa 指向这个派生类。如果用户注册了对某此目标对象的某一个属性的观察，那么此派生类会重写这个方法，并在其中添加进行通知的代码。

&emsp;  Objective-C 在发送消息的时候，会通过 isa 指针找到当前对象所属的类对象。而类对象中保存着当前对象的实例方法，因此在向此对象发送消息时候，实际上是发送到了派生类对象的方法。

&emsp;  由于编译器对派生类的方法进行了 override，并添加了通知代码，因此会向注册的对象发送通知。注意派生类只重写注册了观察者的属性方法。

```
KVO底层实现原理：
1. 动态生成子类 NSKVONotifiying_A;
2. 重写get方法；
3. 子类消息转发给父类；
```


