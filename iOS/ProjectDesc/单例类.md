- **系统单例类**
	- 变量在内存中的状态
- **自定义单例类**
	- Demo
	- 拓展：浅复制和深复制
- **单例设计(Swift)**




<br/>

***
<br/>

># 系统单例类

>UIApplication                     (应用程序实例类)<br/>
NSNotificationCenter         (消息中心类)<br/>
NSFileManager                   (文件管理类)<br/>
NSUserDefaults                  (应用程序设置)<br/>
NSURLCache                      (请求缓存类)<br/>
NSHTTPCookieStorage     (应用程序cookies池)<br/>



<br/>


- **`变量在内存中的状态`**

![变量的存储状态](https://upload-images.jianshu.io/upload_images/2959789-268e2272ebd5a7c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

全局区域使用关键字：`static`,单例类使用这个关键字。


<br/>

***
<br/>

># 自定义单例类


<br/>

- **`Demo`**

`GUserManager .h`

```
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface GUserManager : NSObject<NSCopying, NSMutableCopying>


@end

NS_ASSUME_NONNULL_END
```

`GUserManager .m`

```
#import "GUserManager.h"
#define user    [NSUserDefaults standardUserDefaults]

@implementation GUserManager
static GUserManager *_userManager = nil;

+ (instancetype) shareInstance {
    if (_userManager != nil) {
        return _userManager;
    }
    
    return [[self alloc] init];
}

+ (instancetype)allocWithZone:(struct _NSZone *)zone {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        if (!_userManager) {
            _userManager = [super allocWithZone:zone];
        }
    });
    
    return _userManager;
}

- (nonnull id)copyWithZone:(nullable NSZone *)zone {
     return _userManager;
}

- (nonnull id)mutableCopyWithZone:(nullable NSZone *)zone {
     return _userManager;
}

@end
```

**遵守`NSCopying, NSMutableCopying`协议的原因：**

&emsp;  如果不慎调用了 `copy` 或 `mutableCopy` 方法就会导致程序运行崩溃，自定义的类，要实现 copy 就要默认实现 `NSCopying` 协议，同理实现 `mutablecopy` 就要实现 `NSMutableCopying` 协议。

&emsp;  `NSCopying` 协议中有一个唯一的方法 `- (id)copyWithZone:(nullable NSZone *)zone;` 需要实现，同样的，`NSMutableCopying` 也有唯一一个方法 `- (id)mutableCopyWithZone:(nullable NSZone *)zone;` 需要实现。


<br/>

- **`拓展：浅复制和深复制`**

```
NSString *string = @"huangJiaJu 歌";
NSLog(@"string值：%@,     %p", string, string);
//NSLog(@"string值：%@,     %p", string, &string) //&string 是string指针的地址值，相当于指针的指针，会与结果相背

NSString *stringCopy = [string copy];
NSLog(@"stringCopy值：%@,     %p", stringCopy, stringCopy);

NSMutableString *stringMCopy = [string mutableCopy];
[stringMCopy appendString:@"Hero"];
NSLog(@"stringMCopy值：%@,    %p", stringMCopy, stringMCopy);
    
```
输出：

```
2019-06-27 11:23:29.026700+0800 Genealogy[3368:109679] string值：huangJiaJu 歌,     0x10f348930
2019-06-27 11:23:30.802144+0800 Genealogy[3368:109679] stringCopy值：huangJiaJu 歌,     0x10f348930
2019-06-27 11:23:33.459110+0800 Genealogy[3368:109679] stringMCopy值：huangJiaJu 歌Hero,    0x600003864480
```
&emsp;  总结一下：string 和 stringCopy 指向的是同一块内存区域，而系统则为 stringMCopy 分配了一个新的内存地址。由此可见，copy 是指针复制（浅拷贝），mutableCopy 是对象复制（深拷贝）。

&emsp;  需要注意的是，在 iOS 中并不是所有的对象都支持copy，mutableCopy，遵守NSCopying协议的类可以发送copy消息，遵守NSMutableCopying协议的类才可以发送mutableCopy消息。否则，会发生异常。


参考资料：[^fn1][^fn2]

[^fn1]:[单例类书写](https://www.jianshu.com/p/a92c0283f243)
[^fn2]:[单例模式的简单使用](https://www.jianshu.com/p/d07298613f86)


<br/>

***
<br/>

># 单例设计(Swift)

&emsp; 使用一个静态类型属性创建简单的单例对象，它保证懒初始化一次，即使在多个线程同时访问时也是如此:

**`创建一个单例`**

```
class Singleton {
    static let sharedInstance = Singleton()
}
```

&emsp; 如果需要在初始化之外执行其他设置，可以将闭包调用的结果分配给全局常量:

```
class Singleton {
    static let sharedInstance: Singleton = {
        let instance = Singleton()
        // setup code
        return instance
    }()
}
```

