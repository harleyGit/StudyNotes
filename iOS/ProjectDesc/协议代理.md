

- **Swift可选协议**
- **面向协议编程**
	- 面向对象和协议对比 
- [**Swift标准库中常见的协议**](https://blog.csdn.net/daiqiao_ios/article/details/79581729)


<br/>

***
<br/>


># Swift可选协议

```
protocol  MiningHeaderViewDelegate {
    //可选协议的实现
    func setUpContent(_ titleArray: [String]?, completeHandler:@escaping (_ index: Int) -> Void)
    
    //必选协议实现
    func setTitles(_ titleArray: [String])
}

extension MiningHeaderViewDelegate {
    
    func setUpContent(_ titleArray: [String]?, completeHandler:@escaping (_ index: Int) -> Void) {}
}
```


<br/>

***
<br/>

># 面向协议编程

**简介：**

&emsp; 简单来说，面向协议编程是在面向对象编程基础上演变而来，将程序设计过程中遇到的数据类型的抽取（抽象）由使用基类进行抽取改为使用协议（Java语言中的接口）进行抽取。更简单点举个栗子来说，一个猫类、一个狗类，我们很容易想到抽取一个描述动物的基类，也会有人想到抽取一个动物通用的协议，那后者就可以被叫做面向协议编程了。什么？就是这样而已？苹果官方那么正式的称Swift是一门支持面向协议编程的语言，难道就是这么简单的内容？当然不会，有过面向对象编程经验的人都会清楚，协议的使用限制很多，并不能适用于大多数情况下数据类型的抽象。而在Swift语言中，协议被赋予了更多的功能和更广阔的使用空间，在Swift 2.0中，更为协议增加了扩展功能，使其能够胜任绝大多数情况下数据类型的抽象，所以苹果开始声称Swift是一门支持面向协议编程的语言。

&emsp; Swift中许多常见的数据类型、字符串、集合类型，以及结构体和枚举都是值类型而非引用类型，值类型的变量在赋值时会自动进行一次低消耗的值拷贝，**对比对象的copy要更加高效而且不存在线程安全问题**。


<br/>

**引用类型**

```
class Book {
    var name: String
    var pages: Int
    init(name: String, pages: Int) {
        self.name = name
        self.pages = pages
    }
}
class Person {
    var name: String
    var book: Book
    init(name: String, book: Book) {
        self.name = name
        self.book = book
    }
}
let 围城 = Book(name: "围城", pages: 888)
let 小明 = Person(name: "小明", book: 围城) // 小明有一本全新的《围城》
let 小刚 = Person(name: "小刚", book: 围城) // 小刚也有一本全新的《围城》
小明.book.pages = 88 // 小明淘气把书弄坏了，只剩88页了
print(小刚.book.pages) // 输出结果：88  WTF! Where is my new book?
```

<br/>

**值类型**

```
struct Book {
    var name: String
    var pages: Int
    init(name: String, pages: Int) {
        self.name = name
        self.pages = pages
    }
}
struct Person {
    var name: String
    var book: Book
    init(name: String, book: Book) {
        self.name = name
        self.book = book
    }
}


let 围城 = Book(name: "围城", pages: 888)
var 小明 = Person(name: "小明", book: 围城) // 小明有一本全新的《围城》
let 小刚 = Person(name: "小刚", book: 围城) // 小刚也有一本全新的《围城》
小明.book.pages = 88 // 小明淘气把书弄坏了，只剩88页了
print(小刚.book.pages) // 输出结果：888
```



<br/>

**更好的抽象类型的特点：**

- 更多地支持值类型，同时也支持引用类型
- 更多地支持静态类型关联（编译期），同时也支持动态派发（运行时）
- 结构不庞大不复杂
- 模型可扩展
- 不给模型强制添加数据
- 不给模型增加初始化任务的负担
- 清楚哪些方法该实现哪些方法不需实现



<br/>
<br/>

> **面向对象和协议对比**

- **面向对象**

```
class Ordered {
    func precedes(other: Ordered) -> Bool { fatalError("implement me!") }
}
class Number: Ordered {
    var value: Double = 0
    override func precedes(other: Ordered) -> Bool {
        return self.value < (other as! Number).value
    }
}
func binarySearch(sortedKeys: [Ordered], forKey k: Ordered) -> Int {
    var lo = 0
    var hi = sortedKeys.count
    while hi > lo {
        let mid = lo + (hi - lo) / 2
        if sortedKeys[mid].precedes(k) { lo = mid + 1 }
        else { hi = mid }
    }
    return lo
}
```


<br/>

- **面向协议**

```
protocol Ordered {
    func precedes(other: Self) -> Bool
}
struct Number: Ordered {
    var value: Double = 0
    func precedes(other: Number) -> Bool {
        return self.value < other.value
    }
}
func binarySearch<T: Ordered>(sortedKeys: [T], forKey k: T) -> Int {
    var lo = 0
    var hi = sortedKeys.count
    while hi > lo {
        let mid = lo + (hi - lo) / 2
        if sortedKeys[mid].precedes(k) { lo = mid + 1 }
        else { hi = mid }
    }
    return lo
}
```

面向对象不足：
- OC语言中没有抽象类这个概念，所有抽象类都是靠文档注释标明；
- 其他类型若想使用该二分查找法，必须继承自Ordered抽象类，在单继承体系中，该类型将无法再继承其他类型
- 方法参数接收的数组中，类型要求不严格，可以放入多种不同类型的Ordered子类对象
- 基于前一点原因，为保证严谨性，必须在方法实现内部增加类型判断；


<br/>

&emsp；基于上面的2个案例我们可以体会到面向协议编程的优势了，在Swift2.0中我们用Self用于约束泛型，功能类似于OC中的instancetype，示例：`extension Ordered where Self: Comparable`

&emsp；而且协议可扩展，意味着你不仅可以扩展一个类型使其遵守Ordered协议，还可以直接扩展某个协议，详见如下两段代码示例

```
// 扩展类型
extension Int: Ordered {
    func precedes(other: Int) -> Bool {
        return self < other
    }
}
extension String: Ordered {
    func precedes(other: String) -> Bool {
        return self < other
    }
}
let intIndex = binarySearch([2, 3, 5, 7], forKey: 5) // 输出结果2
let stringIndex = binarySearch(["2", "3", "5", "7"], forKey: "5") // 输出结果2
```

<br/>

```
// 扩展协议：方式一
//extension Comparable {
//    func precedes(other: Self) -> Bool {
//        return self < other
//    }
//}
// 扩展协议：方式二（Swift 2.0的推荐方式）
extension Ordered where Self: Comparable {
    func precedes(other: Self) -> Bool {
        return self < other
    }
}
extension Int: Ordered {}
extension String: Ordered {}
let intIndex = binarySearch([2, 3, 5, 7], forKey: 5) // 输出结果2
let stringIndex = binarySearch(["2", "3", "5", "7"], forKey: "5") // 输出结果2
```



<br/>

**总结：**
- 面向对象编程和面向协议编程最明显的区别在于程序设计过程中对数据类型的抽取（抽象）上，面向对象编程使用类和继承的手段，数据类型是引用类型；而面向协议编程使用的是遵守协议的手段，数据类型是值类型（Swift中的结构体或枚举）。
- 面向协议编程是在面向对象编程基础上发展而来的，而并不是完全背离面向对象编程的思想。
- 面向对象编程是伟大的编程思想，也是当今主流的编程思想，它的问题在于被过多的使用在其实并不需要使用它的情况下。
- Swift是一门支持多编程范式的语言，既支持面向对象编程，也支持面向协议编程，同时还支持函数式编程。在项目开发过程中，控制器和视图部分由于使用系统框架，应更多采用面向对象编程的方式；而模型或业务逻辑等自定义类型部分，则应优先考虑面向协议编程。























