>
- [**SwiftRuntime**](#SwiftRuntime)
	- [Dispatch(派发)是什么](#Dispatch(派发)是什么)
	- [Dispatch种类](#Dispatch种类)
		- [V-Table](#V-Table)
		- [PWT(协议目击表)](#PWT(协议目击表))
	- [Swift派发方式](#Swift派发方式)
	- @_dynamicReplacement
- [OC Runtime](#OCRuntime)



<br/>

***
<br/><br/>


> <h1 id='SwiftRuntime'>SwiftRuntime</h1>

<br/>


> <h2 id='Dispatch(派发)是什么'>Dispatch(派发)是什么</h2>


&emsp; Dispatch 派发，指的是**语言底层**找到用户想要调用的方法，并执行调用过程的动作。

&emsp; Call 调用，指的是**语言在高级层面**，指示一个函数进行相关命令的行为。

- 对于一个编译型语言来说，一般有三种方式可以派发到方法：**静态派发，基于 Table 的派发**，**消息派发(前者也被称作 Static Dispatch，后两个为 Dynamic Dispatch。)**。举例：

	- Java 默认是使用 Table 方式派发的，你可以使用 final 关键字来强制动态派发。
	
	- C++ 默认是静态派发的，你可以使用 virtual 关键字来启用 Table 派发(一句话总结，编译器在编译期间就已经确定了的推断路径，运行期间按照既定路线走就行。)。
	
	- Objective-C 全都基于消息派发，不过也允许你使用 C level 的函数直接派发。
	
	- Swift 则巧妙的使用了这三种方法，分别应对不同的情况.





<br/>
<br/>
<br/>


> <h2 id='Dispatch种类'>Dispatch种类</h2>

- **Direct Dispatch 直接派发**
	- 直接派发（静态派发）最快。不只是因为他的汇编命令少，还因为他可以应用很多编译器黑魔法，比如 inline 优化等。

	- 不过这种方式局限性最大，因为不够动态而无法支持子类。

<br/>

- **Table 派发**

	- 基于 Table 的派发机制是编译语言最常用的方式，Table 一般是用函数地址的数组来存储每个类的声明。大多数语言包括 Swift 都把这个称作 VTable，不过 Swift 中还有一个术语叫做 Witness Table 是服务于 Protocol 的，下面会提到。

	- 每个子类都会有自己的 VTable 副本，子类中 override 的方法指针也会被替换成新的，子类新添加的方法则会被添加在 Table 的尾部。程序会在运行时确定每个函数具体的地址。

	- 表的查找就实现而言非常简单，而且性能可以预测，不过还是比直接派发更慢一些。从字节码的角度来说，这种方法多了两步查找和一部跳转，这些都是开销。而且，这种方法没法使用一些黑魔法来优化。

	- 另一个不好的点在于，这种基于数组的派发让 extension 没法扩展这个 table。因为在子类添加方法列表到尾部后，extension 就没有一个安全的 index 可以添加他的方法到 table 中。

<br/>


- **Message 派发**

	- Message 派发是最灵活的派发方式。他是 Cocoa 的基石，也是 KVO，UIAppearance，Core Data 的核心。

	- 他的关键功能是可以让开发者在运行时改变消息发送的行为。不仅可以通过 swizzling 修改 method，还可以通过 isa-swizzling 来修改对象。

	- 一旦有消息发出，runtime 就会基于继承关系开始查找，虽然听起来很慢，但是有 cache 做保障，一旦 cache 经过预热，就和 Table 方式差不多快了。



<br/>


- [**队列派发**](https://hechen.xyz/post/messagedispatchinswift/#pwt)

&emsp; 在 Swift 中，针对拥有继承的 Class 类型来说，依然采用了 V-Table 这种实现形式达到对多态的支持，而针对值类型由于 Protocol 产生的多态而采用了另外一种函数表派发形式，这个表格被称为协议目击表 （Protocol Witness Table，简称 PWT），这个暂时略去不表。


<br/>
<br/>


> <h3 id='V-Table'>V-Table</h3>

- 对于 V-Table 的应用场景下，每一个类都会维护一个函数表，里面记录着该类所有的函数指针，主要包含：
	- 由父类继承而来的方法执行地址；
	
	- 如果子类覆写了父类方法的话，表格里面就会保存被重载之后的函数。
	
	- 子类新添加的函数会插入到这个表格的末尾

- 在程序运行期间会根据这个表去查询真正要调用的函数是哪一个。这种特性就极大的提升了代码的灵活性，也是 Java，C++ 等语言得以支持多态这种语言特性的基石。当然，相对于静态派发而言，表格派发则多了很多的隐式花销，因为函数调用不再是直接调用了，而是需要通过先行查表的形式找到真实的函数指针来执行，编译器也无法再进行诸如 inline 等编译期优化了。


<br/>
<br/>


> <h3 id='PWT(协议目击表)'>PWT(协议目击表)</h3>

&emsp; 对于 Swift 来说，还有更为重要的 Protocol，对于符合同一协议的对象本身是不一定拥有继承关系的，因此 V-Table 就没法使用了。这里，Swift 使用了 Protocol Witness Table 的数据结构达到动态查询协议方法的目的。如果将上面的例子中的 Drawable 抽象成协议。



<br/>
<br/>


>### <h3 id='Swift派发方式'>[Swift派发方式](https://blog.csdn.net/preyer2011/article/details/129052530)</h3>

Swift 中并不只有 2 种（**静态和动态**）派发方法，而是 4 种派发方法:

- inline 内联（最快）

- 静态派发: 又叫做早期绑定，是指在编译期将方法调用绑定到方法的实现上，这种派发方式非常快。在编译期，编译器可以看到调用方和被调方的所有信息，直接生成跳转代码，这样在运行期就不会有其它额外的开销。并且编译器可以根据自己知道的信息进行优化，比如内联，可以极大提高程序运行效率；

- 虚拟派发: 

- 动态派发（最慢）: 在编译期，编译器会给每个包含动态派发方法的类型创建一个虚函数表，这个表会被放在内存的静态区，表中是方法名到方法实现地址的映射。当这个类型的方法被调用时，运行时会去这个类型的虚函数表中寻找这个方法名对应的实现地址，然后再跳转到这个地址执行代码。
	- 动态派发是在运行时决定方法调用地址，因此需要有个查找方法地址的机制，在 Swift 中是通过虚函数表（Virtual Method Table），简称 V-Table 实现的，因此动态派发也被称为表派发（Table Dispatch）
	
	- 是在程序运行时才确定方法的实现，Swift中使用dynamic修饰的方法是使用动态派发模式（ps：@objc修饰的方法**不一定是动态派发**，只是标明该方法对Objective-C可见）

由编译器来决定应该使用哪种派发方法，优先使用**内联**，然后再按需选择。


<br/>
<br/>


&emsp; 其中Swift结构体被分配在堆区，其函数默认是静态派发模式，以及使用**final、private、static关键字**修饰的类也是静态派发模式。

动态派发是在程序运行时才确定方法的实现，Swift中使用dynamic修饰的方法是使用动态派发模式（ps：@objc修饰的方法不一定是动态派发，只是标明该方法对Objective-C可见）。


由于Swift为了性能，牺牲了它的动态性，使得我们在Swift层面上能做的事情很少。不过，由于Swift的类分为两种: 继承自NSObject的类以及默认继承自**SwiftObject的类**，既然Swift中有**继承自NSObject的派生类**，那么也就意味着OC的动态性也能在Swift里面应用



<br/>
<br/>

>## <h2 id='@_dynamicReplacement'>[@_dynamicReplacement](https://juejin.cn/post/6888989886280368141)</h2>




<br/>

***
<br/><br/>


> <h1 id='OCRuntime'>OC Runtime</h1>


&emsp; 在Swift中，继承自NSObject的类都保留了其动态性，所以我们可以通过OC runtime获取到其方法，所以，也可以通过这个方式对Swift代码进行hook。

&emsp; 我们从OC的运行时特性可知，所有的运行时方法都依赖TypeEncoding，也就是method_getTypeEncoding返回的结果，他指定了方法的参数类型以及在函数调用时参数入栈所要的内存空间，没有这个标识就无法动态的压入参数，而一些Swift特有的类型无法映射到OC的类型,也无法用OC的typeEncoding表示，就没法通过runtime获取。


&emsp; 除了继承自NSObject的类之外，继承自SwiftObject类也能开启其动态性，其开启方式是在属性或方法前加上@objc和dynamic。@objc是用来将Swift的API导出给Objective-C和Objective-C runtime使用的，如果你的类继承自Objective-c的类（如NSObject）将会自动被编译器插入@objc标识。加了@objc标识的方法、属性无法保证都会被运行时调用，因为Swift会做静态优化。要想完全被动态调用，必须使用dynamic修饰。使用dynamic修饰将会隐式的加上@objc标识。


[Swift Runtime分析：还像OC Runtime一样吗？](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247488491&idx=1&sn=a5364eacd752f455837179681f4a774c&source=41#wechat_redirect)


