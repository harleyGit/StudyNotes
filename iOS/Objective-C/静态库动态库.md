> <h2 id=''></h2>
- [**知识预备**](#知识预备)
	- [代码分发方式](#代码分发方式)
	- [各个语言编译流程](#各个语言编译流程)
- [**语言编译流程**](#语言编译流程)
	- [将程序编译成可执行文件的步骤](#将程序编译成可执行文件的步骤)
- [**静态库和动态库**](#静态库和动态库)
	- [设备架构](#设备架构)
	- [动、静态库知识预备](#动、静态库知识预备)
		- [静态库与动态库的区别](#静态库与动态库的区别)
	- [静、动态库打包](#静、动态库打包)
		- [静态库.a生成](#静态库.a生成)
			- [Xcode13没有Products目录解决](#Xcode13没有Products目录解决)
		- [静态库.framework生成](#静态库.framework生成)
- [**动态库**](#动态库)
	- [tbd格式](#tbd格式)
	- [Framework](#Framework)
	- [Mach-o格式](#Mach-o格式)
	- [动态库打包](#动态库打包)



<br/>

***
<br/>

> <h1 id='知识预备'>知识预备</h1>

> <h2 id='代码分发方式'>代码分发方式</h2>

![43](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc43.png)

**库可分为开源库和闭源库:**
- 开源库：对外公开源代码, 能看到具体的代码实现, 例如Github上面的第三方开源库都称之为开源库
- 闭源库：不公开源代码, 文件是经过编译后的二进制文件, 看不到具体实现.可分为静态库和动态库

<br/>

> <h2 id='各个语言编译流程'>各个语言编译流程</h2>

![ios各个语言编译流程](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc29.png)



<br/>

***
<br/>


> <h1 id='语言编译流程'>语言编译流程</h1>

<br/>

> <h2 id='将程序编译成可执行文件的步骤'>将程序编译成可执行文件的步骤</h2>

- 将程序编译成可执行文件的步骤

```
cd 项目文件夹

clang -ccc-print-phases main.m 
```


![39](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc39.png)

经历的步骤是: `源代码=>预处理器=>编译器=>汇编=>机器码=>链接=>可执行文件`


<br/>

***
<br/>


> <h1 id='静态库和动态库'>静态库和动态库</h2>


> <h2 id='设备架构'> 设备架构</h2>

|**模拟器CPU架构**||
|:--|:--|
|CPU类型|模拟器机型|
| i386 | iPhone4s、 iPhone5 |
| x86_64 | iPhone5s、 iPhoneX|




<br/>


|    **真机CPU架构**||
|:--|:--|
| armv6 | iPhone、iPhone 2、iPhone 3G、iPod Touch |
| armv7 | iPhone3Gs、 iPhone4s |
| armv7s | iPhone5、iPhone5c |
| armv64 | iPhone5s、 iPhoneX|


&emsp; 理论上指令集是向下兼容的，比如连接设备为 arm64，那么是有可能编译出的动态库所支持的指令集为 armv7s 或者是 armv7。但是向下兼容并不是说一个 armv7s 的动态库可以用在 arm64 架构的设备上，如果连接的设备是 arm64 的，而导入的动态库是没有支持 arm64，那么在编译阶段即会报错。

> <h2 id=''></h2>


> <h2 id=''></h2>



> <h2 id='动、静态库知识预备'>动、静态库知识预备</h2>

<br/>

>静态库与动态库本质

<br/>

> <h3 id='静态库与动态库的区别'>静态库与动态库的区别</h3>

> - 加载期: 静态库和动态库是相对编译期和运行期的：静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要改静态库；而动态库在程序编译时并不会被链接到目标代码中，只是在程序运行（启动依赖或者按需加载）时候加载进程序的地址空间的，因为在程序运行期间还需要动态库的存在。

> 格式:
> - 静态库：以.a 和 .framework为文件后缀名
> - 动态库：以.tbd(之前叫.dylib) 和 .framework 为文件后缀名。（系统直接提供给我们的framework都是动态库！）

解释:
- .a是一个纯二进制文件
- .framework中除了有二进制文件之外还有资源文件
- .a 要有 .h 文件以及资源文件配合， .framework 文件可以直接使用。总的来说，`.framework = .a + .h + sourceFile `
- .dylib：动态库的后缀名
- .tbd：text-based stub libraries，本质上就是一个YAML描述的文本文件。[iOS 7 之后取代 .dylib
](https://satanwoo.github.io/2018/12/22/LD-1/)作用是记录动态库的一些信息，包括导出的符号、动态库的架构信息、动态库的依赖信息


<br/>

> 静态库 好处：

> - 模块化，分工合作，提高了代码的复用及核心技术的保密程度

> - 避免少量改动经常导致大量的重复编译连接

> - 也可以重用，注意不是共享使用

> 动态库 好处：

> - 使用动态库，可以将最终可执行文件体积缩小，将整个应用程序分模块，团队合作，进行分工，影响比较小

> - 使用动态库，多个应用程序共享内存中得同一份库文件，节省资源

> - 使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。

> - 应用插件化

> - 软件版本实时模块升级

**注意⚠️:** 

&emsp; 我们在iOS8之后(iOS8之前苹果是不允许开发者使用动态库的)使用CocoaTouchFramework框架制作的动态库在在打包和提交 app 时会被放到 app main bundle 的根目录 中，运行在沙盒里，而不是系统中。换句话说,不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名、打包和加载。不过 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的.

&emsp; 但是苹果系统专属的framework 是共享的（如UIKit）,因为这个框架是提前内置道我们的iPhone设备上的,并没有在我们的app上.

&emsp; 所以我们自己使用CocoaTouchFramework框架制作的动态库实际上相对于系统的动态库是被阉割了,去掉了多个app共享的功能.想一想,毕竟这不是android开源的.


![关系](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc47.png)


<br/>
<br/>

> 动、静态库配置
> - 动态库的 Framework，添加到工程的时候需要在 Embedded Binaries 下面手动添加，意思是嵌入，并不是嵌入 app 可执行文件，而是嵌入 app 的 bundle 文件。当一个 app 通过 Embedded 的方式嵌入一个 app 后，在打包之后解压 ipa 可以在包内看到一个 framework 的文件夹，下面都是与这个应用相关的动态 framework
> - 静态的 Framework，添加到工程的时候需要在 Linked Frameworks and Libraries 添加，这些 Framework 将会被拷贝到 App 的可执行文件中



<br/>

>静态库与分类的联系

<br/>

>framework与库的区别

<br/>

>tbd、XCFramework格式

<br/>

>理解tbd、framework格式与动态库的关系

<br/>

>理解标志-noall_load、-all_load、-ObjC、-force_load的作用
动态库与静态库分发体积与链接体积大小

<br/>

>静态链接过程





<br/>

> <h2 id='静、动态库打包'>静、动态库打包</h2>

<br/>

> <h3 id='静态库.a生成'>静态库.a生成</h3>


静态库: 首先新建一个工程,工程选择的是一个静态库工程不要选择运行时的工程,然后写好代码后,点击运行(这里要选择真机运行还是模拟器运行会生成对应机型的库文件)然后会生成一个`.a`的文件.这个时候想使用这个静态库只需要将生成的`include`文件夹拖进项目文件夹即可.

![40](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc40.png)

<br/>

![选择模拟器或者机型](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc48.png)

<br/>

![模拟器、真机静态库](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc49.png)

比如真机类库的路径是:`‌/Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphoneos`

<br/>

- **查看静态库要暴露的接口头文件**

![接口头文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc53.png)




<br/>

- **设置模拟器支持的架构类型**

&emsp; iPhone 5模拟器正好是i386架构，iPhone 7模拟器 的cpu是 x86_64架构。所以还需要进行一步设置，使模拟器静态库支持i386 、x86_64设置如何查看静态库所支持的架构.如下:

![Build Active Architecture Only设置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc60.png)

1). 设置为NO的时候，会编译支持的所有的版本;

2). 设置为YES的时候，是为Debug的时候速度更快，它只编译当前的architecture 版本



<br/>

- **查看包支持架构类型**

&emsp; 然后就可以点击运行,生成静态库包了. 这时库又分成模拟器库和真机的库,上面使用的是模拟器的库在真机中是没法使用的.真机的库是运行时通过选择`Any iOS Device(arm64)`来生成的.

可以通过命令来查看时模拟器库还是真机库:

```
$ lipo -info xxx.a


//模拟器
$  lipo -info /Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphonesimulator/libStaticSDK.a

Architectures in the fat file: /Users/harleyhuang/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphonesimulator/libStaticSDK.a are: arm64 x86_64 (架构)

//真机
$ lipo -info /Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphoneos/libStaticSDK.a
Non-fat file: /Users/harleyhuang/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphoneos/libStaticSDK.a is architecture: arm64 (架构)

```

有没有看到上面出现的问题?

可以看到模拟器的架构是:arm64 x86_64, 真机的是: arm64 ,当对这2个包进行合并的时候会出现如下错误:

```
fatal error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: xxxxx/Debug-iphoneos/libStaticSDK.a and xxxxx/Debug-iphonesimulator/libStaticSDK.a have the same architectures (arm64) and can't be in the same fat output file
```

怎么解决呢?

![解决架构相同问题](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc54.png)


<br/>


<br/>

- **模拟器库和真机库合并**

&emsp; 将两个库合并为一个通用库，使用终端的lipo命令行来打包。操作如下：
`lipo -create （这里分别拖入两个libStaticSDK.a文件路径） -output /Desktop/libStaticSDK.a`这样在目标路径下就生成了libStaticSDK.a静态库文件如:

```
$ lipo -create /Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphoneos/libStaticSDK.a /Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphonesimulator/libStaticSDK.a -output /Users/xxxx/Desktop/libStaticSDK.a

```

然后在桌面生成一个libStaticSDK.a的文件


<br/>


- **项目使用**


![使用静态库,这个库是模拟器的,在真机中是没法使用的.](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc41.png)

&emsp; 新建工程，将静态库工程中的StaticSDK.h或者刚刚导出的libStaticSDK.a，导入工程。在所需.m文件中导入静态库头文件即可调用相应功能代码.


<br/>
<br/>

> <h4 id='Xcode13没有Products目录解决'>[Xcode13没有Products目录解决](https://juejin.cn/post/7026978788395188237)</h4>

![修改配置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc56.png)






<br/>
<br/>



> <h3 id='静态库.framework生成'>**静态库.framework生成**</h3>

> 新建一个项目

![42](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc42.png)
 <br/>
<br/>


> 静态库项目配置

&emsp; 这时创建的一个工程它默认是动态库,我们要通过设置对它进行设置为静态库, 选择`TARGETS` ——> `Build Settings` ——> `搜索框输入Mach` ——> `Linking中的Mach-o Type 修改为 Static Library`.

&emsp; 在新建的项目中StaticFrameworkSDK的文件夹中有一个自动生成的文件`StaticFrameworkSDK.h`,在我们需要公开功能的头文件都可以导入到此文件中,当我们使用时只需导入`StaticFrameworkSDK.h`就可以了


<br/>

- **导入第三方静态库和待封装的代码配置**

正常导入要打包的文件就可以了

**⚠️注意：导入第三方静态库的时候不要选择添加到target中**

![文件添加](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc57.png)

&emsp; 如果你用到的第三方库需要依赖其他系统库的话，需要在导入第三方静态库之后再link依赖的系统库

![添加其他系统依赖库](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc58.png)

所有文件导入完成后的文件目录,如下:

![导入完成后的目录结构](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc59.png)



<br/>

- **设置需要暴露的StaticFrameworkSDK.h文件**

![暴露头文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc50.png)

需要暴露的头文件放置在Public里, 若是不放则在打包后会爆如下错误:

```
In file included from /Users/harleyhuang/Desktop/Test1/Test1/ViewController.m:14:
/Users/harleyhuang/Desktop/Test1/Test1/Lib/StaticFrameworkSDK.h:19:9: fatal error: 'StaticFrameworkTest.h' file not found
#import "StaticFrameworkTest.h"
        ^~~~~~~~~~~~~~~~~~~~~~~
1 error generated.

```

所以进行如下配置:

在StaticFrameworkSDK.h中(将其中无用的进行删除)导入StaticFrameworkTest.h头文件:

![导入文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc55.png)


<br/>

加入公共头文件

![加入公共文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc64.png)

<br/>

这里写了一个StaticFrameworkTest类,将其导入到StaticFrameworkSDK.h头文件中.

![加入公共文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc65.png)

**注意:** 导入的头文件 `‌#import <StaticFrameworkSDK/StaticFrameworkTest.h>` 不要用`‌#import "StaticFrameworkTest.h"` 这样导入,即使这样可以导入但是导入工程后没有办法看到StaticFrameworkTest类的接口头文件.



<br/>
<br/>


> 编译配置


&emsp; 分别选择 `真机`和`模拟器,cmd+b`进行编译。

**注：编译之前要设置 Deployment Target 你要最低支持的版本，这里要低于真机版本，否则会无法编译。**


![编译配置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc51.png)




<br/>

&emsp; 之后在模拟器环境下，让Xcode进行Build，之后在对应的Build文件夹下的Products文件夹中可以找到生成的framework文件.

&emsp; 这里要说下,在Xcode13里,你在运行以后找不到Products文件下生成的
StaticFrameworkSDK.framework,需要通过下面路径找到:

![Xcode13找Products文件夹](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc61.png)


![](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc44.png)



-  **制作支持各机型的静态库**

![Build Active Architecture Only统一设置为No, 会编译成支持所有的版本](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc62.png)


- Build Active Architecture Only 统一为 NO
- Architectures 和 Valid Architectures 都设置为 armv7、armv7s、arm64、arm64e
- 真机 Command + B 则生成支持 armv7、armv7s、arm64 的动态库，模拟器运行，则生成支持 i386、x86_64 的动态库。
- 补充: Build Active Architecture Only设置为YES的时候，是为Debug的时候速度更快，它只编译当前的architecture 版本

<br/>

- 属性介绍:
	- Architectures：指明选定 Target 要求被编译生成的二进制包所支持的指令集
	- Build Active Architecture Only：指明是否只编译当前连接设备所支持的指令集，如果为 YES，那么只编译出连接设备所对应的指令集；如果为 NO，则编译出所有其它有效的指令集（由 Architectures 和 Valid Architectures决定）
	- Valid Architectures：指明可能支持的指令集并非 Architectures 列表中指明的指令集都会被支持
	- 编译产生的动态库所支持的指令集将由上面三个编译选项所影响，首先一个动态库要成功编译，则需要这三个编译选项的交集不为空。



<br/>


```
示例1：
  Architectures 为armv7、arm64
  Valid Architectures 为armv7、armv7s、arm64
  Build Active Architecture Only 为 debug:YES release:NO
  链接设备:iPhone 6s (arm64架构的设备)
  编译(command + shift + B,保证Build Active Architecture Only 为 debug:YES 生效)
  结果：编译成功，生成的动态库支持的指令集为arm64.因为Architectures和Valid Architectures的交集为armv7、arm64.而armv7、arm64和Build Active Architecture Only(Debug为Yes,则为arm64),所以只有arm64

示例2：
  Architectures 为armv7、arm64
  Valid Architectures 为 armv7s
  Build Active Architecture Only 为 debug:YES release:NO
  链接设备:iPhone 6s (arm64架构的设备)
  编译(command + shift + B,保证Build Active Architecture Only 为 debug:YES 生效)
  结果：编译失败，因为当前是debug模式，在该模式下Build Active Architecture Only  为YES，表示只编译支持该指令集的动态库，
      但是由于Architectures和Build Active Architecture Only的交集中并不存在arm64，故三者的交集为空，故编译失败，无法生成动态库。

示例3：
  Architectures 为armv7、arm64
  Valid Architectures 为armv7、armv7s、arm64
  Build Active Architecture Only 为 debug:NO release:NO
  链接设备:iPhone 6s (arm64架构的设备)
  编译(command + shift + B,保证Build Active Architecture Only 为 debug:NO 生效)
  结果：编译成功，因为当前是debug模式，在该模式下Build Active Architecture Only  为NO，
    表示可以编译的结果可能为当前连接的设备所支持的指令集以及其向上兼容的指令集(armv64、armv7s、armv7)，其和另外两个编译选项的交集为armv7，故所生成的动态库支持的指令集为armv7
```







<br/>
<br/>

- **生成静态包**

&emsp; 选择模拟器iPhone 13 Pro Max和真机 Any iOS Device(arm64 armv7) 分别生成模拟器包和真机包.


⚠️注意：编译时可能会出现三方静态库文件找不到的情况：报"XXXX/XXXX.h file not found "错误，那是因为没有设置Framework Search Paths。
我项目中的三方在MyIMSDK目录下（点击+，将MyIMSDK目录拖进来就可以了）

![Framework Search Paths 设置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc63.png)



&emsp; 当然也可以使用真机环境下进行编译,与[静态库.a生成](#静态库.a生成)生成真机framework一样,将2个库使用终端命令lipo来打包如下:

```
lipo -create （这里分别拖入两个目录下的签名文件路径） -output /Desktop/StaticFrameworkSDK 
```

注意: 签名文件要和库名保持一致.


&emsp; 最后，将生成真机和模拟器的静态库文件StaticFrameworkSDK拷贝到之前生成的带有_CodeSignature 文件夹StaticFrameworkSDK.framework目录下,替换掉原来StaticFrameworkSDK。至此StaticFrameworkSDK.framework就是我们最终生成的通用版静态framework库。

&emsp; 将最终通用库拖进工程,导入`#import <StaticFrameworkSDK/StaticFrameworkSDK.h>`即可调用功能代码

![Framework Search Paths 设置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc67.png)


&emsp; `StaticFrameworkSDK.framework` 我们拷到项目中后发现它并不能展开,然后导致看不到对应的头文件.这是正常的,但是我们通过Cocoapods管理就可以做到看到其脚本,这可能是因为其内部运行了对应的脚本将.h头文件给暴露了出来.


[工程和静态库进行联调](https://www.jianshu.com/p/ca5c0bc69e08)





<br/>
<br/>

> 文件介绍

在framework文件会发现其中有5类文件，如下:

![](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc45.webp)

- `_CodeSignature`中存放的是framework的签名文件。

- Headers中存放的是头文件，需要注意，在编译framework工程时，要将需要暴露的头文件设置为public。

- Info.plist文件是当前framework的配置文件。

- Modules中的modulemap文件用来管理LLVM的module map，定义组件结构。



![路径配置解释](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc46.png)




<br/>

***
<br/>



> <h1 id='动态库'>动态库</h1>


<br/>



> <h2 id='tbd格式'>tbd格式</h2>

![ios_oc38](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc38.png)


<br/>
<br/>
<br/>

> <h2 id='Framewor'>**Framework**</h2>

![Framework意义](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc25.png)

- Embedded Framework

开发中使用的动态库会被放入到ipa下的framework目录下,基于沙盒运行.

不同的App使用相同的动态库,并不会只在系统中存在一份.而是会在多个App总各自打包、签名、加载一份.



<br/>
<br/>
<br/>

> <h2 id='Mach-o格式'>Mach-o格式</h2>


![ios_oc37.png](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc37.png)


<br/>
<br/>
<br/>



> <h2 id=''></h2>


<br/>
<br/>
<br/>

> <h2 id=''></h2>


<br/>
<br/>
<br/>

> <h2 id=''></h2><br/>



<br/>
<br/>
<br/>

> <h2 id=''></h2>

<br/>

![30](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc30.png)

&emsp; 动态库合静态库的继承、查找、链接，其实静态库是**.o文件**的合集，经过一定的转化可以变为动态库.


<br/>

![31](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc31.png)

AFNetworking的静态库

静态库其实就是.o文件的集合


<br/>


![32](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc32.png)

AFNetworking的动态库

&emsp; 动态库其实也是.o文件的集合,只不过是它比静态库要小.小的原因是其把静态态库的MachHeader、Segment、Section整合为一个不是那么臃余了



<br/>
<br/>
<br/>



> <h2 id='动态库打包'>动态库打包</h2>


<br/>

- **创建一个DynamicFrameworkSDK动态库,然后再创建一个Test类文件,将Test文件导入DynamicFrameworkSDK.h文件中,如下:**

![Test文件导入](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc69.png)

头文件导入:

![头文件导入](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc68.png)


&emsp; 动态库frame的打包和[静态库.framework生成](#静态库.framework生成)基本一样,如在动态库打包中需要修改`Mach-o`属性为`Dynamic Library`;


<br/>

- **导出动态库**

&emsp; 使用**Command+B**分别运行真机和模拟器打出真机动态库和模拟器动态库,然后使用 **`lipo -out xxx模拟器库地址 xxx真机库地址 -output /Users/harleyhuang/Desktop/DynamicFrameworkSDK1`** 打出真机和模拟器都能用的动态库.



&emsp; 这里会出现一个问题那就是,若是模拟器动态库和真机动态库的架构都有arm64则会合并时报错如:

```
error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: xxxx/Products/Debug-iphonesimulator/DynamicFrameworkSDK.framework/DynamicFrameworkSDK and xxxx/Products/Debug-iphoneos/DynamicFrameworkSDK.framework/DynamicFrameworkSDK have the same architectures (arm64) and can't be in the same fat output file
```

那么则让模拟器排除arm64架构就可以了,如下图:

![模拟器排除arm64架构](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc70.png)

&emsp; 但是在M1的Mac并且Xcode12版本以上,制作动态库可以不设置,也是可以的.如下:


![配置不设置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc75.png)

<br/>


&emsp; 然后将导出的动态库DynamicFrameworkSDK1拖入真机或者模拟器生成的动态库DynamicFrameworkSDK.framework文件夹内,然后删除其DynamicFrameworkSDK将DynamicFrameworkSDK1改为DynamicFrameworkSDK即可.

如下:

![真机和模拟器的动态库](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc74.png)

&emsp; 但是在项目中会报错:`building for iOS Simulator, but linking in object file built for iOS, for architecture arm64`这是因为Apple M1，Xcode 12模拟器的库需要的是arm64架构；但是很多第三方针对模拟器编译后的库并不包含arm64，因此报错.

解决方法是使用rossetta2运行XCode,具体设置如下:

![rossetta2](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc72.png)


- 将打包好后的通用库拖进工程,在需要的地方进行如下导入:`#import<xxxxFramework/xxxxFramwork.h>`即可调用功能代码,另外还要进行如下配置流程

![嵌入](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc52.png)


**注：默认是`Do not embed`, 需要设置为`Embed & Sign`，否则会报以下错误:**
**dyld: Library not loaded: @rpath/DynamicFramework.framework/DynamicFramework Referenced from: /private/var/containers/Bundle/Application/DF439DDF-5DBC-41E3-842D-26FAB1D5BFEE/YYYTest.app/YYYTest Reason: image not found**

<br/>

![运行效果](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc76.png)





<br/>
<br/>

> **脚本合并真机、模拟器动态库**

- **创建一个脚本**

![script](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc71.png)

脚本文件为:

```
if [ "${ACTION}" = "build" ]
then

INSTALL_DIR=${SRCROOT}/Products/${PROJECT_NAME}.framework

DEVICE_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework

SIMULATOR_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework

if [ -d "${INSTALL_DIR}" ]

then

rm -rf "${INSTALL_DIR}"

fi

mkdir -p "${INSTALL_DIR}"

cp -R "${DEVICE_DIR}/" "${INSTALL_DIR}/"

#ditto "${DEVICE_DIR}/Headers" "${INSTALL_DIR}/Headers"

# 使用lipo命令将其合并成一个通用framework  

# 最后将生成的通用framework放置在工程根目录下新建的Products目录下  

lipo -create "${DEVICE_DIR}/${PROJECT_NAME}" "${SIMULATOR_DIR}/${PROJECT_NAME}" -output "${INSTALL_DIR}/${PROJECT_NAME}"

#open "${DEVICE_DIR}"

#open "${SRCROOT}/Products"

fi
```








[模拟器、真机动态库合并脚本](https://www.cnblogs.com/dins/p/ios-gou-jian-dong-tai-ku.html)

[创建你自己的Framework](https://juejin.cn/post/6844903930439139336)

[Swift Framework静态库制作与发布](https://blog.csdn.net/wmadao11/article/details/102635156)




<br/>
<br/>
<br/>


<br/>

***
<br/>


> <h1 id=''></h1>





<br/>

***
<br/>


> <h1 id=''></h1>




<br/>

***
<br/>


> <h1 id=''></h1>