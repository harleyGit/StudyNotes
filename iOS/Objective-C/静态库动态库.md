> <h2 id=''></h2>
- [**知识预备**](#知识预备)
	- [代码分发方式](#代码分发方式)
	- [各个语言编译流程](#各个语言编译流程)
- [**语言编译流程**](#语言编译流程)
	- [将程序编译成可执行文件的步骤](#将程序编译成可执行文件的步骤)
- [**静态库和动态库**](#静态库和动态库)
	- [设备架构](#设备架构)
	- [Xcode理解](#Xcode理解)
	- [动、静态库知识预备](#动、静态库知识预备)
		- [静态库与动态库的区别](#静态库与动态库的区别)
	- [静、动态库打包](#静、动态库打包)
		- [静态库.a生成](#静态库.a生成)
			- [解决没有Products文件夹](#解决没有Products文件夹)
			- [静态库脚本合并模拟器、真机](#静态库脚本合并模拟器真机)
		- [静态库.framework生成](#静态库.framework生成)
	- [主工程和静态库的联调](#主工程和静态库的联调)
- [**动态库**](#动态库)
	- [tbd格式](#tbd格式)
	- [Framework](#Framework)
	- [Mach-o格式](#Mach-o格式)
	- [动态库打包](#动态库打包)
		- [动态库脚本合并模拟器、真机](#动态库脚本合并模拟器真机)
- [**自动打包**](#自动打包)
	- [上传蒲公英脚本](#上传蒲公英脚本)
- **参考资料**
	- [LLVM&Clang入门](https://juejin.cn/post/6844903748435705864)
	- [iOS深入浅出编译](https://github.com/LeoMobileDeveloper/Blogs/blob/master/Compiler/xcode-compile-deep.md)



<br/>

***
<br/>

> <h1 id='知识预备'>知识预备</h1>

> <h2 id='代码分发方式'>代码分发方式</h2>

![43](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc43.png)

**库可分为开源库和闭源库:**
- 开源库：对外公开源代码, 能看到具体的代码实现, 例如Github上面的第三方开源库都称之为开源库
- 闭源库：不公开源代码, 文件是经过编译后的二进制文件, 看不到具体实现.可分为静态库和动态库

<br/>

> <h2 id='各个语言编译流程'>各个语言编译流程</h2>

![ios各个语言编译流程](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc29.png)



<br/>

***
<br/>


> <h1 id='语言编译流程'>语言编译流程</h1>

<br/>

> <h2 id='将程序编译成可执行文件的步骤'>将程序编译成可执行文件的步骤</h2>

- 将程序编译成可执行文件的步骤

```
cd 项目文件夹

clang -ccc-print-phases main.m 
```


![39](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc39.png)

<br/>

&emsp; MacOS采用的是均为clang编译器，安装路径在Xcode中，其头文件也均在Xcode中默认路径usr/include/c++中，如果需要引用头文件，可以直接将其复制到该路径。[深入浅出iOS编译](https://github.com/LeoMobileDeveloper/Blogs/blob/master/Compiler/xcode-compile-deep.md)


- **经历的步骤是: `源代码=>预处理器=>编译器=>汇编=>机器码=>链接=>可执行文件`**

	- 预处理（Pre-process）：把宏替换，删除注释，展开头文件，产生 .i 文件。
	
	- 编译（Compliling）：把之前的 .i 文件转换成汇编语言，产生 .s文件。
	
	- 汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 .o 文件。
	
	- 链接（Link）：对.o文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 .o 文件进行 link）。



<br/>

> **configure/make/make install的作用-摘录**

- **1). configure命令**

	- 这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure –prefix=/usr 意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的 /usr/local/bin),资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）。
	
	- 同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。

- **2).make([CMake扫盲](https://www.hahack.com/codes/cmake/))**

	- make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。
	
	- 比如某个工程有8个c文件，和3个头文件，我们要写一个makefile来告 诉make命令如何编译和链接这几个文件。我们的规则是：
	
	- 如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。
	如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。
	如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。

- **3).make insatll**

	- 这条命令来进行安装（当然有些软件需要先运行 make check 或 make test 来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。


<br/>



<br/>

***
<br/>


> <h1 id='静态库和动态库'>静态库和动态库</h2>


> <h2 id='设备架构'> 设备架构</h2>

|**模拟器CPU架构**||
|:--|:--|
|CPU类型|模拟器机型|
| i386 | iPhone4s、 iPhone5、iPhone5C |
| x86_64 | iPhone5s模拟器以上|




<br/>


|    **真机CPU架构**||
|:--|:--|
| armv6 | iPhone、iPhone 2、iPhone 3G、iPod Touch |
| armv7 | iPhone3Gs、 iPhone4s |
| armv7s | iPhone5、iPhone5c |
| armv64 | iPhone5s以上真机|



<br/>


|    **CPU架构演进**|||
|:--|:--|:--|
| 年份 | 芯片 | 架构 | 设备 |
| 2013 | A7 | arm64 | iPhone 5S |
| 2014 | A8 | arm64 | iPhone 6/6P |
| 2015 | A9 | arm64 | iPhone 6S/6SP |
| 2016 | A10 | arm64 | iPhone 7/7SP |
| 2017 | A11 | arm64 | iPhone 8/8SP/X |
| 2018 | A12 | arm64e | iPhone XS/XS Max/XR |

<br/>

&emsp; 理论上指令集是向下兼容的，比如连接设备为 arm64，那么是有可能编译出的动态库所支持的指令集为 armv7s 或者是 armv7。但是向下兼容并不是说一个 armv7s 的动态库可以用在 arm64 架构的设备上，如果连接的设备是 arm64 的，而导入的动态库是没有支持 arm64，那么在编译阶段即会报错。


<br/>


> <h2 id='Xcode理解'>Xcode理解</h2>

xcode本质上是大号的脚本，Xcode编译的时候有下面的几个步骤：

```
1.编译产物路径
2.VFS
3.copy -》编译产物路径/headers
4.clang（包括汇编/链接器）-〉 exc（可执行文件）
5. sign（对付好的签名）
6. strip（符号处理）
```

&emsp; xcconfig （控制这个build setting）-> build setting（控制上面的6步的流程）

&emsp;上述的6个步骤需要在 shell环境下进行执行，但是执行的时候肯定需要参数配置吧，那样就在build setting里进行配置:
shell环境 => 环境变量（也就是build setting参数）



> <h2 id=''></h2>



> <h2 id='动、静态库知识预备'>动、静态库知识预备</h2>

<br/>

>静态库与动态库本质

<br/>

> <h3 id='静态库与动态库的区别'>静态库与动态库的区别</h3>

- **静态库：**
	- 在链接时，Xcode会自动从库文件中，筛选出相应的架构，之后合并到主程序的二进制文件中；
	- 在打包时，Xcode会自动忽略库文件中不使用的架构，如会忽略x86_64等模拟器使用的架构；
- **动态库：**
	- 在编译时，Xcode会直接拷贝整个动态framework文件到最终的.ipa中，只有在App真正启动运行时，才会进行动态链接；
	- 但是苹果不允许上传到App Store Connect后台的.ipa包含x86_64等模拟器的架构（报Invalid错误）；所以对于工程中的动态framework，在打Release包时，一般会通过执行命令脚本的方式移除这些Invalid Architectures；
	- 通过CocoaPods集成动态库时，其会自动添加一个shell脚本（[CP] Embed Pods Frameworks），用于移除不需要的架构；
	- 通过Carthage集成动态库时，需要手动配置相关shell脚本，用于移除不需要的架构；

`/usr/local/bin/carthage copy-frameworks`

> 格式:
> - 静态库：
	>- 以.a 和 .framework为文件后缀名
	>- .a库：使用时需要将.h头文件及资源文件（比如图片等）拖入到工程项目中，配置一些header、lib路径之类的；使用起来比较麻烦；
	>- .framework库：Apple平台独有，其本质是将.a库文件、.h头文件及资源文件打包在一起的包文件；使用时直接将其拖到工程项目中即可，或在 General -> Link Binary With Libraries 中添加使用；
- 动态库：
	>- .tdb库：Xcode 7（iOS9）开始使用，之前名称为.dylib；在 General -> Link Binary With Libraries 中添加使用；
	>- .framework库：必须在 General -> Embedded Binaries 中添加使用；

解释:
- .a是一个纯二进制文件
- .framework中除了有二进制文件之外还有资源文件
- .a 要有 .h 文件以及资源文件配合， .framework 文件可以直接使用。总的来说，`.framework = .a + .h + sourceFile `
- .dylib：动态库的后缀名
- .tbd：text-based stub libraries，本质上就是一个YAML描述的文本文件。[iOS 7 之后取代 .dylib
](https://satanwoo.github.io/2018/12/22/LD-1/)作用是记录动态库的一些信息，包括导出的符号、动态库的架构信息、动态库的依赖信息


<br/>

> 静态库 好处：

> - 模块化，分工合作，提高了代码的复用及核心技术的保密程度

> - 避免少量改动经常导致大量的重复编译连接

> - 也可以重用，注意不是共享使用

> 动态库 好处：

> - 使用动态库，可以将最终可执行文件体积缩小，将整个应用程序分模块，团队合作，进行分工，影响比较小

> - 使用动态库，多个应用程序共享内存中得同一份库文件，节省资源

> - 使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。

> - 应用插件化

> - 软件版本实时模块升级

**注意⚠️:** 

&emsp; 我们在iOS8之后(iOS8之前苹果是不允许开发者使用动态库的)使用CocoaTouchFramework框架制作的动态库在在打包和提交 app 时会被放到 app main bundle 的根目录 中，运行在沙盒里，而不是系统中。换句话说,不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名、打包和加载。不过 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的.

&emsp; 但是苹果系统专属的framework 是共享的（如UIKit）,因为这个框架是提前内置道我们的iPhone设备上的,并没有在我们的app上.

&emsp; 所以我们自己使用CocoaTouchFramework框架制作的动态库实际上相对于系统的动态库是被阉割了,去掉了多个app共享的功能.想一想,毕竟这不是android开源的.


![关系](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc47.png)


<br/>
<br/>

> 动、静态库配置
> - 动态库的 Framework，添加到工程的时候需要在 Embedded Binaries 下面手动添加，意思是嵌入，并不是嵌入 app 可执行文件，而是嵌入 app 的 bundle 文件。当一个 app 通过 Embedded 的方式嵌入一个 app 后，在打包之后解压 ipa 可以在包内看到一个 framework 的文件夹，下面都是与这个应用相关的动态 framework
> - 静态的 Framework，添加到工程的时候需要在 Linked Frameworks and Libraries 添加，这些 Framework 将会被拷贝到 App 的可执行文件中



<br/>

>静态库与分类的联系

<br/>

>framework与库的区别

<br/>

>tbd、XCFramework格式

<br/>

>理解tbd、framework格式与动态库的关系

<br/>

>理解标志-noall_load、-all_load、-ObjC、-force_load的作用
动态库与静态库分发体积与链接体积大小

<br/>

>静态链接过程





<br/>

> <h2 id='静、动态库打包'>静、动态库打包</h2>

<br/>

> <h3 id='静态库.a生成'>静态库.a生成</h3>

- **1.新建工程**

&emsp; 静态库: 首先新建一个工程,工程选择的是一个静态库工程不要选择运行时的工程,然后写好代码后,点击运行(这里要选择真机运行还是模拟器运行会生成对应机型的库文件)然后会生成一个`.a`的文件.这个时候想使用这个静态库只需要将生成的`include`文件夹拖进项目文件夹即可.

![建一个Static Libary工程](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc40.png)

<br/>

![选择模拟器或者机型](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc48.png)


<br/>
<br/>


> <h4 id='解决没有Products文件夹'>2.解决没有Products文件夹</h4>

&emsp; [**Xcode13**后看不到Products怎么办?](https://juejin.cn/post/7026978788395188237)因为.a静态库放在Products文件夹中,可以通过如下方法查看:

**方法1**

![查看Products文件夹](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc49_0.png)

<br/>

**方法2**

![修改配置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc56.png)


<br/>
<br/>

- **3.查看静态库所在文件路径:**

![模拟器、真机静态库](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc49.png)

比如真机类库的路径是:`‌/Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphoneos`

<br/>
<br/>

- **4.查看静态库要暴露的接口头文件**

![接口头文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc53.png)



<br/>
<br/>


- **5.设置模拟器支持的架构类型**

&emsp; iPhone 5模拟器正好是i386架构，iPhone 7模拟器 的cpu是 x86_64架构。所以还需要进行一步设置，使模拟器静态库支持i386 、x86_64设置如何查看静态库所支持的架构.如下:

![Build Active Architecture Only设置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc60.png)

1). 设置为NO的时候，会编译支持的所有的版本;

2). 设置为YES的时候，是为Debug的时候速度更快，它只编译当前的architecture 版本



<br/>
<br/>

- **6.查看包支持架构类型**

&emsp; 然后就可以点击运行,生成静态库包了. 这时库又分成模拟器库和真机的库,上面使用的是模拟器的库在真机中是没法使用的.真机的库是运行时通过选择`Any iOS Device(arm64)`来生成的.

可以通过命令来查看时模拟器库还是真机库:

```
$ lipo -info xxx.a


//模拟器
$  lipo -info /Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphonesimulator/libStaticSDK.a

Architectures in the fat file: /Users/harleyhuang/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphonesimulator/libStaticSDK.a are: arm64 x86_64 (架构)

//真机
$ lipo -info /Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphoneos/libStaticSDK.a
Non-fat file: /Users/harleyhuang/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphoneos/libStaticSDK.a is architecture: arm64 (架构)

```

有没有看到上面出现的问题?

可以看到模拟器的架构是:arm64 x86_64, 真机的是: arm64 ,当对这2个包进行合并的时候会出现如下错误:

```
fatal error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: xxxxx/Debug-iphoneos/libStaticSDK.a and xxxxx/Debug-iphonesimulator/libStaticSDK.a have the same architectures (arm64) and can't be in the same fat output file
```

怎么解决呢?

![解决架构相同问题](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc54.png)


<br/>
<br/>

- **7.模拟器库和真机库合并**

&emsp; 将两个库合并为一个通用库，使用终端的lipo命令行来打包。操作如下：
`lipo -create （这里分别拖入两个libStaticSDK.a文件路径） -output /Desktop/libStaticSDK.a`这样在目标路径下就生成了libStaticSDK.a静态库文件如:

```
$ lipo -create /Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphoneos/libStaticSDK.a /Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphonesimulator/libStaticSDK.a -output /Users/xxxx/Desktop/libStaticSDK.a

```

然后在桌面生成一个libStaticSDK.a的文件


<br/>
<br/>

> <h4 id='静态库脚本合并模拟器真机'>8. 静态库脚本合并模拟器、真机</h3>


```
#! /bin/sh
# 先在工程根目录创建好SDK文件夹
mkdir -p ${PROJECT_NAME}_SDK
cd ${PROJECT_NAME}_SDK
mkdir -p ${PROJECT_NAME}
cd ${PROJECT_NAME}
mkdir -p include
mkdir -p lib

#回到工程目录
cd ./../../
#真机build生成的.a文件路径
DEVICE_DIR_A=${BUILD_DIR}/${CONFIGURATION}-iphoneos/lib${PROJECT_NAME}.a
#模拟器build生成的.a文件路径
SIMULATOR_DIR_A=${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/lib${PROJECT_NAME}.a

if [[ -f "${DEVICE_DIR_A}" ]]; then
	say "真机编译完成"
fi

if [[ -f "${SIMULATOR_DIR_A}" ]]; then
	say "模拟器编译完成"
fi

if [[ -f "${DEVICE_DIR_A}" ]] ; then
	if [[ -f "${SIMULATOR_DIR_A}" ]]; then
		lipo -create ${DEVICE_DIR_A} ${SIMULATOR_DIR_A} -output ./${PROJECT_NAME}_SDK/${PROJECT_NAME}/lib/lib${PROJECT_NAME}.a
		#头文件转移大法
		HEADER_FOLDER="${BUILD_DIR}/${CONFIGURATION}-iphoneos/include/${PROJECT_NAME}"
		cp -a ${HEADER_FOLDER}/. ./${PROJECT_NAME}_SDK/${PROJECT_NAME}/include
		open ./
		say "静态库合并成功"
	fi
fi
```

<br/>
<br/>


- **9.项目使用**


![使用静态库,这个库是模拟器的,在真机中是没法使用的.](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc41.png)

&emsp; 新建工程OCTest工程,将静态库工程中的StaticSDK.h和刚刚导出的libStaticSDK.a放入新建的OCTest工程中。在所需.m文件中导入静态库头文件即可调用相应功能代码.

&emsp; **注意:**在把StaticSDK.h和libStaticSDK.a拖入OCTest工程中要勾选**Destination、Added folders、Add to Targets**.


<br/>
<br/>
<br/>



> <h3 id='静态库.framework生成'>静态库.framework生成</h3>

<br/>

**1.新建一个项目**

![新建项目](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc42.png)
 <br/>
<br/>


- **2.静态库项目配置**

&emsp; 这时创建的一个工程它默认是动态库,我们要通过设置对它进行设置为静态库, 选择`TARGETS` ——> `Build Settings` ——> `搜索框输入Mach` ——> `Linking中的Mach-o Type 修改为 Static Library`.

&emsp; 在新建的项目中StaticFrameworkSDK的文件夹中有一个自动生成的文件`StaticFrameworkSDK.h`,在我们需要公开功能的头文件都可以导入到此文件中,当我们使用时只需导入`StaticFrameworkSDK.h`就可以了


<br/>
<br/>

- **3.导入第三方静态库和待封装的代码配置**

正常导入要打包的文件就可以了

**⚠️注意：导入第三方静态库的时候不要选择添加到target中**

![文件添加](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc57.png)

&emsp; 如果你用到的第三方库需要依赖其他系统库的话，需要在导入第三方静态库之后再link依赖的系统库

![添加其他系统依赖库](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc58.png)

所有文件导入完成后的文件目录,如下:

![导入完成后的目录结构](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc59.png)



<br/>
<br/>

- **4.设置需要暴露的StaticFrameworkSDK.h文件**

![暴露头文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc50.png)

&emsp; 需要暴露的头文件放置在Public里, 若是不放则在打包后会爆如下错误:

```
In file included from /Users/harleyhuang/Desktop/Test1/Test1/ViewController.m:14:
/Users/harleyhuang/Desktop/Test1/Test1/Lib/StaticFrameworkSDK.h:19:9: fatal error: 'StaticFrameworkTest.h' file not found
#import "StaticFrameworkTest.h"
        ^~~~~~~~~~~~~~~~~~~~~~~
1 error generated.

```

所以进行如下配置:

&emsp; 在StaticFrameworkSDK.h中(将其中无用的进行删除)导入StaticFrameworkTest.h头文件:

![导入文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc55.png)


<br/>

**5.加入公共头文件**

![加入公共文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc64.png)

<br/>

这里写了一个StaticFrameworkTest类,将其导入到StaticFrameworkSDK.h头文件中.

![加入公共文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc65.png)

**注意:** 导入的头文件 `‌#import <StaticFrameworkSDK/StaticFrameworkTest.h>` 不要用`‌#import "StaticFrameworkTest.h"` 这样导入,即使这样可以导入但是导入工程后没有办法看到StaticFrameworkTest类的接口头文件.如下:

![❌错误放置暴露文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc49_2.png)



<br/>
<br/>


- **6.编译配置**


&emsp; 分别选择 `真机`和`模拟器,cmd+b`进行编译。

**注：编译之前要设置 Deployment Target 你要最低支持的版本，这里要低于真机版本，否则会无法编译。**


![编译配置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc51.png)


<br/>
<br/>

-  **6.1. 制作支持各机型的静态库**

![Build Active Architecture Only统一设置为No, 会编译成支持所有的版本](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc62.png)


- Build Active Architecture Only 统一为 NO
- Architectures 和 Valid Architectures 都设置为 armv7、armv7s、arm64、arm64e
- 真机 Command + B 则生成支持 armv7、armv7s、arm64 的动态库，模拟器运行，则生成支持 i386、x86_64 的动态库。
- 补充: Build Active Architecture Only设置为YES的时候，是为Debug的时候速度更快，它只编译当前的architecture 版本

<br/>

- 属性介绍:
	- Architectures：指明选定 Target 要求被编译生成的二进制包所支持的指令集
	- Build Active Architecture Only：指明是否只编译当前连接设备所支持的指令集，如果为 YES，那么只编译出连接设备所对应的指令集；如果为 NO，则编译出所有其它有效的指令集（由 Architectures 和 Valid Architectures决定）
	- Valid Architectures：指明可能支持的指令集并非 Architectures 列表中指明的指令集都会被支持
	- 编译产生的动态库所支持的指令集将由上面三个编译选项所影响，首先一个动态库要成功编译，则需要这三个编译选项的交集不为空。



<br/>


```
示例1：
  Architectures 为armv7、arm64
  Valid Architectures 为armv7、armv7s、arm64
  Build Active Architecture Only 为 debug:YES release:NO
  链接设备:iPhone 6s (arm64架构的设备)
  编译(command + shift + B,保证Build Active Architecture Only 为 debug:YES 生效)
  结果：编译成功，生成的动态库支持的指令集为arm64.因为Architectures和Valid Architectures的交集为armv7、arm64.而armv7、arm64和Build Active Architecture Only(Debug为Yes,则为arm64),所以只有arm64

示例2：
  Architectures 为armv7、arm64
  Valid Architectures 为 armv7s
  Build Active Architecture Only 为 debug:YES release:NO
  链接设备:iPhone 6s (arm64架构的设备)
  编译(command + shift + B,保证Build Active Architecture Only 为 debug:YES 生效)
  结果：编译失败，因为当前是debug模式，在该模式下Build Active Architecture Only  为YES，表示只编译支持该指令集的动态库，
      但是由于Architectures和Build Active Architecture Only的交集中并不存在arm64，故三者的交集为空，故编译失败，无法生成动态库。

示例3：
  Architectures 为armv7、arm64
  Valid Architectures 为armv7、armv7s、arm64
  Build Active Architecture Only 为 debug:NO release:NO
  链接设备:iPhone 6s (arm64架构的设备)
  编译(command + shift + B,保证Build Active Architecture Only 为 debug:NO 生效)
  结果：编译成功，因为当前是debug模式，在该模式下Build Active Architecture Only  为NO，
    表示可以编译的结果可能为当前连接的设备所支持的指令集以及其向上兼容的指令集(armv64、armv7s、armv7)，其和另外两个编译选项的交集为armv7，故所生成的动态库支持的指令集为armv7
```




<br/>
<br/>

- **6.2. 生成静态包**

&emsp; 选择模拟器iPhone 13 Pro Max和真机 Any iOS Device(arm64 armv7) 分别生成模拟器包和真机包.


⚠️注意：编译时可能会出现三方静态库文件找不到的情况：报"XXXX/XXXX.h file not found "错误，那是因为没有设置Framework Search Paths。
我项目中的三方在MyIMSDK目录下（点击+，将MyIMSDK目录拖进来就可以了）

![Framework Search Paths 设置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc63.png)



&emsp; 当然也可以使用真机环境下进行编译,与[静态库.a生成](#静态库.a生成)生成真机framework一样,将2个库使用终端命令lipo来打包如下:

```
lipo -create （这里分别拖入两个目录下的签名文件路径） -output /Desktop/StaticFrameworkSDK 
```

注意: 签名文件要和库名保持一致.


&emsp; 最后，将生成真机和模拟器的静态库文件StaticFrameworkSDK拷贝到之前生成的带有_CodeSignature 文件夹StaticFrameworkSDK.framework目录下,替换掉原来StaticFrameworkSDK。至此StaticFrameworkSDK.framework就是我们最终生成的通用版静态framework库。

&emsp; 将最终通用库拖进工程,导入`#import <StaticFrameworkSDK/StaticFrameworkSDK.h>`即可调用功能代码

![Framework Search Paths 设置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc67.png)


&emsp; `StaticFrameworkSDK.framework` 我们拷到项目中后发现它并不能展开,然后导致看不到对应的头文件.这是正常的,但是我们通过Cocoapods管理就可以做到看到其脚本,这可能是因为其内部运行了对应的脚本将.h头文件给暴露了出来.





<br/>

&emsp; 之后在模拟器环境下，让Xcode进行Build，之后在对应的Build文件夹下的Products文件夹中可以找到生成的framework文件.

&emsp; 这里要说下,在Xcode13里,你在运行以后找不到Products文件下生成的
StaticFrameworkSDK.framework,需要通过下面路径找到:

![Xcode13找Products文件夹](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc61.png)


![](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc44.png)



<br/>
<br/>

- **7.文件介绍**

在framework文件会发现其中有5类文件，如下:

![](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc45.webp)

- `_CodeSignature`中存放的是framework的签名文件。

- Headers中存放的是头文件，需要注意，在编译framework工程时，要将需要暴露的头文件设置为public。

- Info.plist文件是当前framework的配置文件。

- Modules中的modulemap文件用来管理LLVM的module map，定义组件结构。



![路径配置解释](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc46.png)


<br/>

***
<br/>


> <h2 id='主工程和静态库的联调'>主工程和静态库的联调</h2>

[工程和静态库进行联调](https://www.jianshu.com/p/ca5c0bc69e08)

<br/>

> <h3 id='工程内拖入Framework'>工程内拖入Framework</h3>

- **1.新建主工程StaticLibTest,再建动态库DynamicFramework**

&emsp; 这里需要注意的是把**动态库DynamicFramework**工程关掉留下主工程StaticLibTest打开.

<br/>

- **2.将动态库DynamicFramework中的DynamicFramework.xcodeproj拖入到主工程StaticLibTest中**

![文件放入](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc104.png)

<br/>

- **3.关联动态库和工程**


![关联](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc104_4.png)

效果如下:

![效果](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc104_5.png)


<br/>
<br/>
<br/>

> <h3 id='xcworkspace联调试'>xcworkspace联调试</h3>

<br/>

- **1.创建Workspace项目**

&emsp; 新建一个DLianTiaoTest文件夹,File->New->Workspace，项目命名为DLianTiaoTest，存放在新建的文件夹中。

<br/>

- **2.动态库和主工程添加入xcworkspace中**

![文件放置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc104_0.png)

添加后的效果如下:

![添加效果](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc104_1.png)

<br/>

- **3.将动态库和工程关联起来**

&emsp; **在这之前,请先把动态库跑起来,生成.framework文件,否则无法关联**

![关联](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc104_3.png)


<br/>

- **4.一边开发一边调试动态库**


&emsp; 后续开发中就可以边在framework项目中修改静态库核心代码，边在demo中运行查看效果了。

![效果](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc104_2.png)







<br/>

***
<br/>



> <h1 id='动态库'>动态库</h1>


<br/>



> <h2 id='tbd格式'>tbd格式</h2>

![ios_oc38](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc38.png)


<br/>
<br/>
<br/>

> <h2 id='Framewor'>**Framework**</h2>

![Framework意义](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc25.png)

- Embedded Framework

开发中使用的动态库会被放入到ipa下的framework目录下,基于沙盒运行.

不同的App使用相同的动态库,并不会只在系统中存在一份.而是会在多个App总各自打包、签名、加载一份.



<br/>
<br/>
<br/>

> <h2 id='Mach-o格式'>Mach-o格式</h2>


![ios_oc37.png](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc37.png)


<br/>
<br/>
<br/>



> <h2 id=''></h2>


<br/>
<br/>
<br/>

> <h2 id=''></h2>


<br/>
<br/>
<br/>

> <h2 id=''></h2><br/>



<br/>
<br/>
<br/>

> <h2 id=''></h2>

<br/>

![30](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc30.png)

&emsp; 动态库合静态库的继承、查找、链接，其实静态库是**.o文件**的合集，经过一定的转化可以变为动态库.


<br/>

![31](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc31.png)

AFNetworking的静态库

静态库其实就是.o文件的集合


<br/>


![32](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc32.png)

AFNetworking的动态库

&emsp; 动态库其实也是.o文件的集合,只不过是它比静态库要小.小的原因是其把静态态库的MachHeader、Segment、Section整合为一个不是那么臃余了



<br/>
<br/>
<br/>



> <h2 id='动态库打包'>动态库打包</h2>


<br/>

- **创建一个DynamicFrameworkSDK动态库,然后再创建一个Test类文件,将Test文件导入DynamicFrameworkSDK.h文件中,如下:**

![Test文件导入](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc69.png)

头文件导入:

![头文件导入](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc68.png)


&emsp; 动态库frame的打包和[静态库.framework生成](#静态库.framework生成)基本一样,如在动态库打包中需要修改`Mach-o`属性为`Dynamic Library`;


<br/>

- **导出动态库**

&emsp; 使用**Command+B**分别运行真机和模拟器打出真机动态库和模拟器动态库,然后使用 **`lipo -out xxx模拟器库地址 xxx真机库地址 -output /Users/harleyhuang/Desktop/DynamicFrameworkSDK1`** 打出真机和模拟器都能用的动态库.



&emsp; 这里会出现一个问题那就是,若是模拟器动态库和真机动态库的架构都有arm64则会合并时报错如:

```
error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: xxxx/Products/Debug-iphonesimulator/DynamicFrameworkSDK.framework/DynamicFrameworkSDK and xxxx/Products/Debug-iphoneos/DynamicFrameworkSDK.framework/DynamicFrameworkSDK have the same architectures (arm64) and can't be in the same fat output file
```

那么则让模拟器排除arm64架构就可以了,如下图:

![模拟器排除arm64架构](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc70.png)

&emsp; 但是在M1的Mac并且Xcode12版本以上,制作动态库可以不设置,也是可以的.如下:


![配置不设置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc75.png)

<br/>


&emsp; 然后将导出的动态库DynamicFrameworkSDK1拖入真机或者模拟器生成的动态库DynamicFrameworkSDK.framework文件夹内,然后删除其DynamicFrameworkSDK将DynamicFrameworkSDK1改为DynamicFrameworkSDK即可.

如下:

![真机和模拟器的动态库](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc74.png)

&emsp; 但是在项目中会报错:`building for iOS Simulator, but linking in object file built for iOS, for architecture arm64`这是因为Apple M1，Xcode 12模拟器的库需要的是arm64架构；但是很多第三方针对模拟器编译后的库并不包含arm64，因此报错.

解决方法是使用rossetta2运行XCode,具体设置如下:

![rossetta2](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc72.png)


- 将打包好后的通用库拖进工程,在需要的地方进行如下导入:`#import<xxxxFramework/xxxxFramwork.h>`即可调用功能代码,另外还要进行如下配置流程

![嵌入](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc52.png)


**注：默认是`Do not embed`, 需要设置为`Embed & Sign`，否则会报以下错误:**
**dyld: Library not loaded: @rpath/DynamicFramework.framework/DynamicFramework Referenced from: /private/var/containers/Bundle/Application/DF439DDF-5DBC-41E3-842D-26FAB1D5BFEE/YYYTest.app/YYYTest Reason: image not found**

<br/>

![运行效果](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc76.png)





<br/>
<br/>

> <h3 id='动态库脚本合并模拟器真机'>动态库脚本合并模拟器、真机</h3>

- **创建一个脚本**

![script](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc71.png)

脚本文件为:

```
#! /bin/sh
#创建存放目录
mkdir -p ${PROJECT_NAME}.framework
INSTALL_DIR=./${PROJECT_NAME}.framework

#真机编译产物
DEVICE_DIR=${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework
#模拟器编译产物
SIMULATOR_DIR=${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework

#.framework是目录是文件夹 所以用-d判断 文件用-f
if [[ -d "$DEVICE_DIR" ]]; then
    say "真机编译完成"
fi

if [[ -d "$SIMULATOR_DIR" ]]; then
    say "模拟器编译完成"
fi

if [[ -d "${DEVICE_DIR}" ]] ; then
    if [[ -d "${SIMULATOR_DIR}" ]]; then
        cp -R ${DEVICE_DIR}/ ${INSTALL_DIR}/
        lipo -create "${DEVICE_DIR}/${PROJECT_NAME}" "${SIMULATOR_DIR}/${PROJECT_NAME}" -output "${INSTALL_DIR}/${PROJECT_NAME}"
        open ./
        say "静态库合并成功"
    fi
fi

```



![脚本文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc78.png)

<br/>

&emsp; 先选择模拟器运行Command+B,然后再选择真机运行Command+B,运行时可以发出呻吟哟‼️ 最后打开如下:


![导出后合并的文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc77.png)



- **资料参考:**

	- [模拟器、真机动态库合并脚本](https://www.cnblogs.com/dins/p/ios-gou-jian-dong-tai-ku.html)
	- [创建你自己的Framework](https://juejin.cn/post/6844903930439139336)
	- [Swift Framework静态库制作与发布](https://blog.csdn.net/wmadao11/article/details/102635156)




<br/>
<br/>
<br/>


<br/>

***
<br/>


> <h1 id='自动打包'>自动打包</h1>

<br/>

> <h2 id='上传蒲公英脚本'>上传蒲公英脚本</h2>

```
#!/bin/bash
#安装器打包文件

#start---------------------------------------》


# 工程名
APP_NAME="会议"

# 1.设置配置标识
configuration="Debug"

#2.项目的根目录
cur_dir="/Users/guan/Desktop/github/app/app/IOS/iOS_mobile"
echo $cur_dir

#生成ipa的目录
desk_dir="/Users/guan/Desktop/ipa"
echo $desk_dir

#获取当前时间
CURTIME=`date '+%Y%m%d_%H%M%S'`
prefix_path="${desk_dir}/HuoMiao"
upload_path="${prefix_path}/${configuration}/${CURTIME}"
target_path=$cur_dir

echo "upload_path打包路径:$upload_path"
echo "target_path项目路径:$target_path"

#判断如果不存在upload_path创建,存在先删除再创建
if [ -d "$prefix_path" ]; then
if [ -d "$upload_path" ]; then
rmdir "$upload_path"
mkdir -p "$upload_path"
else
mkdir -p "$upload_path"
fi
else
mkdir -p "$prefix_path"
fi

# 项目名称
target_name="New"
workspace_name="${target_name}.xcworkspace"
scheme="TorchClass"

echo "configuration配置:$configuration"
echo "target_name项目名称:$target_name"
echo "workspace_name工作空间名称:$workspace_name"
echo "scheme名称:$scheme"

# archive包时使用证书、描述文件UUID；ipa包时使用描述文件（描述文件名称）
codeSignIdentity="iPhone Developer: xxx (9DFV2445HW)"
provision_UUID="63f0e245-c34a-4e94-8562-fa2e5ca5a52d.mobileprovision"
provisoning_profile="20211203_dev"

echo "codeSignIdentity开发证书:$codeSignIdentity"
echo "provision_UUID描述文件UUID:$provision_UUID"
echo "provisoning_profile描述文件:$provisoning_profile"

# 指定目录时
cd "$upload_path"
ipa_path="$upload_path"
archive_path="$upload_path/${target_name}.xcarchive"
# 日志路径
log_path="$upload_path/log.txt"
exportOptionsPlist_path="$desk_dir/HuoMiao/ExportOptions.plist"

pwd
echo "ipa_path导出路径:$ipa_path"
echo "archive_path生成路径:$archive_path"
echo "log_path打印路径:$log_path"

# 3 删除旧文件
rm -rf "$log_path"
rm -rf "$archive_path"
rm -rf "$ipa_path"
cd "$target_path"

pwd
# 4 清理构建目录
xcodebuild clean -configuration "$configuration" -alltargets
xcodebuild clean -configuration "$configuration" -alltargets | tee $log_path

echo $scheme
echo $workspace_name
echo $configuration

/usr/bin/security unlock-keychain -p 123456

# 5 归档（其他参数不指定的话，默认用的是.xcworkspace或.xcodeproj文件里的配置）
xcodebuild archive -workspace "$workspace_name" -scheme "$scheme" -configuration "$configuration" -archivePath "$archive_path" CODE_SIGN_IDENTITY="$codeSignIdentity" PROVISIONING_PROFILE="$provision_UUID" | tee $log_path

# 6 导出IPA
xcodebuild -exportArchive -archivePath "$archive_path" -exportPath "$ipa_path" -exportOptionsPlist "$exportOptionsPlist_path" | tee $log_path

# 7 删除项目目录下产生的build文件
rm -rf "$cur_dir/build"

#上传到蒲公英
#蒲公英上的user Key
uKey=“xxxx”
#蒲公英上的API Key
apiKey=“x’x’x’x’x”

#要上传的ipa文件路径
echo $upload_path
 
#执行上传至蒲公英的命令
echo "++++++++++++++upload+++++++++++++"
curl -F "file=@${upload_path}/$APP_NAME.ipa" -F "uKey=${uKey}" -F "_api_key=${apiKey}"
```





<br/>

***
<br/>


> <h1 id=''></h1>




<br/>

***
<br/>


> <h1 id=''></h1>