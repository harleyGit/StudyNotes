> <h2 id=''></h2>
- [**知识预备**](#知识预备)
	- [代码分发方式](#代码分发方式)
	- [各个语言编译流程](#各个语言编译流程)
- [**语言编译流程**](#语言编译流程)
	- [将程序编译成可执行文件的步骤](#将程序编译成可执行文件的步骤)
- [**静态库和动态库**](#静态库和动态库)
	- [设备架构](#设备架构)
	- [动、静态库知识预备](#动、静态库知识预备)
		- [静态库与动态库的区别](#静态库与动态库的区别)
	- [静、动态库打包](#静、动态库打包)
		- [静态库.a生成](#静态库.a生成)
			- [Xcode13没有Products目录解决](#Xcode13没有Products目录解决)
		- [静态库.framework生成](#静态库.framework生成)
- [**动态库**](#动态库)
	- [tbd格式](#tbd格式)
	- [Framework](#Framework)
	- [Mach-o格式](#Mach-o格式)
	- [动态库打包](#动态库打包)



<br/>

***
<br/>

> <h1 id='知识预备'>知识预备</h1>

> <h2 id='代码分发方式'>代码分发方式</h2>

![43](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc43.png)

**库可分为开源库和闭源库:**
- 开源库：对外公开源代码, 能看到具体的代码实现, 例如Github上面的第三方开源库都称之为开源库
- 闭源库：不公开源代码, 文件是经过编译后的二进制文件, 看不到具体实现.可分为静态库和动态库

<br/>

> <h2 id='各个语言编译流程'>各个语言编译流程</h2>

![ios各个语言编译流程](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc29.png)



<br/>

***
<br/>


> <h1 id='语言编译流程'>语言编译流程</h1>

<br/>

> <h2 id='将程序编译成可执行文件的步骤'>将程序编译成可执行文件的步骤</h2>

- 将程序编译成可执行文件的步骤

```
cd 项目文件夹

clang -ccc-print-phases main.m 
```


![39](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc39.png)

经历的步骤是: `源代码=>预处理器=>编译器=>汇编=>机器码=>链接=>可执行文件`


<br/>

***
<br/>


> <h1 id='静态库和动态库'>静态库和动态库</h2>


> <h2 id='设备架构'> 设备架构</h2>

|**模拟器CPU架构**||
|:--|:--|
|CPU类型|模拟器机型|
| i386 | iPhone4s、 iPhone5 |
| x86_64 | iPhone5s、 iPhoneX|




<br/>


|    **真机CPU架构**||
|:--|:--|
| armv6 | iPhone、iPhone 2、iPhone 3G、iPod Touch |
| armv7 | iPhone3Gs、 iPhone4s |
| armv7s | iPhone5、iPhone5c |
| armv64 | iPhone5s、 iPhoneX|



> <h2 id=''></h2>


> <h2 id=''></h2>



> <h2 id='动、静态库知识预备'>动、静态库知识预备</h2>

<br/>

>静态库与动态库本质

<br/>

> <h3 id='静态库与动态库的区别'>静态库与动态库的区别</h3>

> - 加载期: 静态库和动态库是相对编译期和运行期的：静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要改静态库；而动态库在程序编译时并不会被链接到目标代码中，只是在程序运行（启动依赖或者按需加载）时候加载进程序的地址空间的，因为在程序运行期间还需要动态库的存在。

> 格式:
> - 静态库：以.a 和 .framework为文件后缀名
> - 动态库：以.tbd(之前叫.dylib) 和 .framework 为文件后缀名。（系统直接提供给我们的framework都是动态库！）

解释:
- .a是一个纯二进制文件
- .framework中除了有二进制文件之外还有资源文件
- .a 要有 .h 文件以及资源文件配合， .framework 文件可以直接使用。总的来说，`.framework = .a + .h + sourceFile `
- .dylib：动态库的后缀名
- .tbd：text-based stub libraries，本质上就是一个YAML描述的文本文件。[iOS 7 之后取代 .dylib
](https://satanwoo.github.io/2018/12/22/LD-1/)作用是记录动态库的一些信息，包括导出的符号、动态库的架构信息、动态库的依赖信息


<br/>

> 静态库 好处：

> - 模块化，分工合作，提高了代码的复用及核心技术的保密程度

> - 避免少量改动经常导致大量的重复编译连接

> - 也可以重用，注意不是共享使用

> 动态库 好处：

> - 使用动态库，可以将最终可执行文件体积缩小，将整个应用程序分模块，团队合作，进行分工，影响比较小

> - 使用动态库，多个应用程序共享内存中得同一份库文件，节省资源

> - 使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。

> - 应用插件化

> - 软件版本实时模块升级

**注意⚠️:** 

&emsp; 我们在iOS8之后(iOS8之前苹果是不允许开发者使用动态库的)使用CocoaTouchFramework框架制作的动态库在在打包和提交 app 时会被放到 app main bundle 的根目录 中，运行在沙盒里，而不是系统中。换句话说,不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名、打包和加载。不过 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的.

&emsp; 但是苹果系统专属的framework 是共享的（如UIKit）,因为这个框架是提前内置道我们的iPhone设备上的,并没有在我们的app上.

&emsp; 所以我们自己使用CocoaTouchFramework框架制作的动态库实际上相对于系统的动态库是被阉割了,去掉了多个app共享的功能.想一想,毕竟这不是android开源的.



<br/>
<br/>

> 动、静态库配置
> - 动态库的 Framework，添加到工程的时候需要在 Embedded Binaries 下面手动添加，意思是嵌入，并不是嵌入 app 可执行文件，而是嵌入 app 的 bundle 文件。当一个 app 通过 Embedded 的方式嵌入一个 app 后，在打包之后解压 ipa 可以在包内看到一个 framework 的文件夹，下面都是与这个应用相关的动态 framework
> - 静态的 Framework，添加到工程的时候需要在 Linked Frameworks and Libraries 添加，这些 Framework 将会被拷贝到 App 的可执行文件中



<br/>

>静态库与分类的联系

<br/>

>framework与库的区别

<br/>

>tbd、XCFramework格式

<br/>

>理解tbd、framework格式与动态库的关系

<br/>

>理解标志-noall_load、-all_load、-ObjC、-force_load的作用
动态库与静态库分发体积与链接体积大小

<br/>

>静态链接过程





<br/>

> <h2 id='静、动态库打包'>静、动态库打包</h2>

<br/>

> <h3 id='静态库.a生成'>静态库.a生成</h3>


静态库: 首先新建一个工程,工程选择的是一个静态库工程不要选择运行时的工程,然后写好代码后,点击运行(这里要选择真机运行还是模拟器运行会生成对应机型的库文件)然后会生成一个`.a`的文件.这个时候想使用这个静态库只需要将生成的`include`文件夹拖进项目文件夹即可.

![40](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc40.png)

<br/>

![选择模拟器或者机型](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc48.png)

<br/>

![模拟器、真机静态库](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc49.png)

比如真机类库的路径是:`‌/Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphoneos`

<br/>

- **查看静态库要暴露的接口头文件**

![接口头文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc53.png)

<br/>

- **设置模拟器支持的架构类型**

&emsp; iPhone 5模拟器正好是i386架构，iPhone 7模拟器 的cpu是 x86_64架构。所以还需要进行一步设置，使模拟器静态库支持i386 、x86_64设置如何查看静态库所支持的架构.如下:

![支持的架构](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc55.png)


<br/>

- **查看包支持架构类型**

&emsp; 库又分成模拟器库和真机的库,上面使用的是模拟器的库在真机中是没法使用的.真机的库是运行时通过选择`Any iOS Device(arm64)`来生成的.

可以通过命令来查看时模拟器库还是真机库:

```
$ lipo -info xxx.a


//模拟器
$  lipo -info /Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphonesimulator/libStaticSDK.a

Architectures in the fat file: /Users/harleyhuang/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphonesimulator/libStaticSDK.a are: arm64 x86_64 (架构)

//真机
$ lipo -info /Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphoneos/libStaticSDK.a
Non-fat file: /Users/harleyhuang/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphoneos/libStaticSDK.a is architecture: arm64 (架构)

```

有没有看到上面出现的问题?

可以看到模拟器的架构是:arm64 x86_64, 真机的是: arm64 ,当对这2个包进行合并的时候会出现如下错误:

```
fatal error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: xxxxx/Debug-iphoneos/libStaticSDK.a and xxxxx/Debug-iphonesimulator/libStaticSDK.a have the same architectures (arm64) and can't be in the same fat output file
```

怎么解决呢?

![解决架构相同问题](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc54.png)


<br/>

- **模拟器库和真机库合并**

&emsp; 将两个库合并为一个通用库，使用终端的lipo命令行来打包。操作如下：
`lipo -create （这里分别拖入两个libStaticSDK.a文件路径） -output /Desktop/libStaticSDK.a`这样在目标路径下就生成了libStaticSDK.a静态库文件如:

```
$ lipo -create /Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphoneos/libStaticSDK.a /Users/xxxx/Library/Developer/Xcode/DerivedData/StaticSDK-gczvnjclhtamtrbcfscahauqmazt/Build/Products/Debug-iphonesimulator/libStaticSDK.a -output /Users/xxxx/Desktop/libStaticSDK.a

```

然后在桌面生成一个libStaticSDK.a的文件


<br/>


- **项目使用**


![使用静态库,这个库是模拟器的,在真机中是没法使用的.](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc41.png)

&emsp; 新建工程，将静态库工程中的StaticSDK.h或者刚刚导出的libStaticSDK.a，导入工程。在所需.m文件中导入静态库头文件即可调用相应功能代码.


<br/>
<br/>

> <h4 id='Xcode13没有Products目录解决'>[Xcode13没有Products目录解决](https://juejin.cn/post/7026978788395188237)</h4>

![修改配置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc56.png)






<br/>
<br/>

> <h3 id='静态库.framework生成'>静态库.framework生成</h3>

> 新建一个项目

![42](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc42.png)
 <br/>
<br/>


> 静态库项目配置

&emsp; 这时创建的一个工程它默认是动态库,我们要通过设置对它进行设置为静态库, 选择`TARGETS` ——> `Build Settings` ——> `搜索框输入Mach` ——> `Linking中的Mach-o Type 修改为 Static Library`.

&emsp; 在新建的项目中MyStatic的文件夹中有一个自动生成的文件`StaticSDK.h`,在我们需要公开功能的头文件都可以导入到此文件中,当我们使用时只需导入`StaticSDK.h`就可以了


<br/>

- **导入第三方静态库和待封装的代码配置**

正常导入要打包的文件就可以了

**⚠️注意：导入第三方静态库的时候不要选择添加到target中**

![文件添加](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc57.png)

&emsp; 如果你用到的第三方库需要依赖其他系统库的话，需要在导入第三方静态库之后再link依赖的系统库

![添加其他系统依赖库](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc58.png)

所有文件导入完成后的文件目录,如下:

![导入完成后的目录结构](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc59.png)



<br/>

- **设置需要暴露的MyStatic.h文件**

![暴露头文件](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc50.png)

需要暴露的头文件放置在Public里

<br/>
<br/>


> 编译配置


&emsp; 分别选择 `真机`和`模拟器,cmd+b`进行编译。

**注：编译之前要设置 Deployment Target 你要最低支持的版本，这里要低于真机版本，否则会无法编译。**


![编译配置](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc51.png)




<br/>

&emsp; 之后在模拟器环境下，让Xcode进行Build，之后在对应的Build文件夹下的Products文件夹中可以找到生成的framework文件.

![](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc44.webp)

当然也可以使用真机环境下进行编译,与[静态库.a生成](#静态库.a生成)生成真机framework一样,将2个库使用终端命令lipo来打包如下:

```
lipo -create （这里分别拖入两个目录下的签名文件路径） -output /Desktop/MyStaticFramework 
```

注意: 签名文件要和库名保持一致.


&emsp; 最后，将生成的新的签名文件MyStaticFramework拷贝到之前生成的带有_CodeSignature 文件夹的frameWork库的根目录下替换掉原来的库的签名文件。至此该frameWork就是我们最终生成的通用版frameWork库。

&emsp; 将最终通用库拖进工程,导入`#import <MyStaticFramework/MyStaticFramework.h>`即可调用功能代码






<br/>
<br/>

> 文件介绍

在framework文件会发现其中有5类文件，如下:

![](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc45.webp)

- `_CodeSignature`中存放的是framework的签名文件。

- Headers中存放的是头文件，需要注意，在编译framework工程时，要将需要暴露的头文件设置为public。

- Info.plist文件是当前framework的配置文件。

- Modules中的modulemap文件用来管理LLVM的module map，定义组件结构。

&emsp; 新建一个项目，将前面构建的MyStatic.framework文件直接拖入此工程中，在工程的编译选项中，找到Framework Search Paths和Header Search Paths中分别将此framework的路径与头文件的路径进行配置，如下图所示：

![](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc46.webp)


在项目中使用的代码如下:

```
#import "ViewController.h"
#import "MyStatic.framework/Headers/MyStatic.h"

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    NSInteger a = 100;
    NSInteger b = 200;
    NSInteger c = [MyTool add:a another:b];
    [MyLog log:[NSString stringWithFormat:@"%ld", c]];
}


@end
```


&emsp; 运行代码，我们的静态库已经可以正常工作了。但是这样我们会觉得上面的头文件引入方式非常的丑陋，我们可以在工程中新建一个文件夹，将framework包内的头文件拷贝过来，如下图：


![](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc47.webp)

这样你就可以像引用工程内的头文件一样的使用framework中的功能了：

```
#import "ViewController.h"
#import "MyStatic.h"

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    NSInteger a = 100;
    NSInteger b = 200;
    NSInteger c = [MyTool add:a another:b];
    [MyLog log:[NSString stringWithFormat:@"%ld", c]];
}

@end
```





<br/>

***
<br/>



> <h1 id='动态库'>动态库</h1>


<br/>



> <h2 id='tbd格式'>tbd格式</h2>

![ios_oc38](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc38.png)


<br/>
<br/>
<br/>

> <h2 id='Framewor'>**Framework**</h2>

![Framework意义](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc25.png)

- Embedded Framework

开发中使用的动态库会被放入到ipa下的framework目录下,基于沙盒运行.

不同的App使用相同的动态库,并不会只在系统中存在一份.而是会在多个App总各自打包、签名、加载一份.



<br/>
<br/>
<br/>

> <h2 id='Mach-o格式'>Mach-o格式</h2>


![ios_oc37.png](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc37.png)


<br/>
<br/>
<br/>



> <h2 id=''></h2>


<br/>
<br/>
<br/>

> <h2 id=''></h2>


<br/>
<br/>
<br/>

> <h2 id=''></h2><br/>



<br/>
<br/>
<br/>

> <h2 id=''></h2>

<br/>

![30](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc30.png)

&emsp; 动态库合静态库的继承、查找、链接，其实静态库是**.o文件**的合集，经过一定的转化可以变为动态库.


<br/>

![31](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc31.png)

AFNetworking的静态库

静态库其实就是.o文件的集合


<br/>


![32](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc32.png)

AFNetworking的动态库

&emsp; 动态库其实也是.o文件的集合,只不过是它比静态库要小.小的原因是其把静态态库的MachHeader、Segment、Section整合为一个不是那么臃余了



<br/>
<br/>
<br/>



> <h2 id='动态库打包'>动态库打包</h2>

&emsp; 动态库frame的大包和[静态库.framework生成](#静态库.framework生成)基本一样,但还有些小地方是不同的如下:

- 在动态库大包中需要修改`Mach-o`属性为`Dynamic Library`;

- 将打包好后的通用库拖进工程,在需要的地方进行如下导入:`#import<xxxxFramework/xxxxFramwork.h>`即可调用功能代码,另外还要进行如下配置流程

![嵌入](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/ios_oc52.png)


**注：默认是Do not embed, 需要设置为Embed & Sign，否则会报以下错误:**
**dyld: Library not loaded: @rpath/DynamicFramework.framework/DynamicFramework Referenced from: /private/var/containers/Bundle/Application/DF439DDF-5DBC-41E3-842D-26FAB1D5BFEE/YYYTest.app/YYYTest Reason: image not found**




<br/>
<br/>
<br/>


<br/>

***
<br/>


> <h1 id=''></h1>





<br/>

***
<br/>


> <h1 id=''></h1>




<br/>

***
<br/>


> <h1 id=''></h1>