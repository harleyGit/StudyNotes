> <h2 id=''></h2>
- [GCD](#GCD)
	- [3种队列类型](#3种队列类型)
	- [dispatch_once](#dispatch_once)
		- [原理](#原理)
			- [dispatch_function_t](#dispatch_function_t)
	- [并发](#并发)
		- [全局并发队列与普通并发队列区别](#全局并发队列与普通并发队列区别)
		- [dispatch_get_global_queue()](#dispatch_get_global_queue())
	- [线程组和依赖](#线程组和依赖)
		- 	[线程组处理](#线程组处理)
- [时间延迟](#时间延迟)
	- [dispatch_after](#dispatch_after)
	- [dispatch_time_t](#dispatch_time_t)
	- [dispatch_walltime](#dispatch_walltime)
- [线程暂停&恢复](#线程暂停&恢复)
- [**锁**](#锁)
	- [锁分类](#锁分类)
	- [OSSpinLock](#OSSpinLock)
	- [NSLock](#NSLock)
	- [NSCondition](#NSCondition)
	- [递归锁NSRecursiveLock](#递归锁NSRecursiveLock)
	- [对象锁/同步锁 @synchronized](#对象锁/同步锁@synchronized)
	- [dispatch_semaphore](#dispatch_semaphore)
		- [网络请求依次执行  ](#网络请求依次执行)
		- [dispatch_group_enter 使用与讲解](#dispatch_group_enter使用与讲解) 
		- [dispatch_semaphore_t使用](#dispatch_semaphore_t使用)
	- [读写锁pthread_rwlock](#读写锁pthread_rwlock)
	- [pthread_mutex](#pthread_mutex)
	- [dispatch_barrier_async](dispatch_barrier_async)
	- [pthread_rwlock互斥锁](#pthread_rwlock互斥锁)
- [**避免死锁**](#避免死锁)
	- [pthread_mutex_trylock](#pthread_mutex_trylock)
	- [CPU乱序执行](#CPU乱序执行)
- [**NSOperation**](#NSOperation)
	- [操作和操作队列](#操作和操作队列)
	- [NSOperation常用属性和方法](#NSOperation常用属性和方法)
	- [NSOperationQueue常用属性和方法](#NSOperationQueue常用属性和方法)
	- [属性](#属性)
	- [创建队列](#创建队列)
	- [操作加入到队列中](#操作加入到队列中)
	- [NSOperation、NSOperationQueue使用方法](#NSOperation、NSOperationQueue使用方法)
	- [NSInvocationOperation使用](#NSInvocationOperation使用)
	- 	[子程使用NSInvocationOperation](#子程使用NSInvocationOperation)
	- 	[NSBlockOperation](#NSBlockOperation)
	- [	自定义继承自NSOperation子类](#自定义继承自NSOperation子类)
	- [线程安全](#线程安全)
	- [常驻线程](#常驻线程)
	- 	[依赖](#依赖)
	- [多任务(任务是异步)](#多任务(任务是异步))
	- [并发](#并发)
- [**内存问题**](#内存问题)
- **资料**
	- [GCD(III)-Harley](https://www.cnblogs.com/EchoHG/p/8664846.html)
	- [GCD](https://www.cnblogs.com/EchoHG/p/8609685.html)
	- [dispatch_once的坑及注意点](https://juejin.cn/post/6844903558224035848)
	- [**多线程**](https://meniny.cn/posts/iOS_Primer_017/)
	- [开源的Parse源码(GCD玩的出神入化)](https://github.com/ChenYilong/ParseSourceCodeStudy)
	- **[NSOperation、NSOperationQueue』详尽总结](https://www.jianshu.com/p/4b1d77054b35)**
	- [**NSOperation**](https://www.jianshu.com/p/d8caf596d5d0)
	- [**NSOperation的进阶使用**](https://juejin.cn/post/6844903721097248782#heading-34)
	- [iOS 入门 017: 多线程](https://meniny.cn/posts/iOS_Primer_017/)


<br/><br/><br/>

***
<br/>

><h1 id='GCD'>GCD</h1>
> GCD和NSOperaiton 
 - 能用GCD的地方就用GCD 尽量减少NSOperation的使用,因为GCD在多核CPU上线程切换的时间比较短 效率相对高些；
 - NSOperation是建立在GCD之上的，虽然使用起来比较复杂，但是在线程并发管理、优先级、上有着GCD无法比拟的优势。

<br/><br/>
> <h2 id='3种队列类型'>3种队列类型</h2>

- **`The main queue`**: 与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个串行队列。

- **`Global queues`**: 全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。可以调用dispatch_get_global_queue函数传入优先级来访问队列。

- **`用户队列`**: 用户队列 (GCD并不这样称呼这种队列, 但是没有一个特定的名字来形容这种队列，所以我们称其为用户队列) 是用函数 dispatch_queue_create 创建的队列. 这些队列是串行的。正因为如此，它们可以用来完成同步机制, 有点像传统线程中的mutex。

&emsp;  这个有没有开启新线程，需要看这种队列和dispatch_async和dispatch_sync的搭配，请看[这里](https://www.cnblogs.com/EchoHG/p/8609685.html)

![3种队列和2种任务(同步、异步)的搭配](https://upload-images.jianshu.io/upload_images/2959789-74ba672570998f83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<br/>

![GCD分类](./../../Pictures/ios_oc1_30.webp)

<br/><br/>
> <h2 id='dispatch_once'>dispatch_once</h2>
介绍:dispatch_once能保证任务只会被执行一次，即使同时多线程调用也是线程安全的。常用于创建单例、swizzeld method等功能

<br/>

- **dispatch_once 如何保证只执行一次？**
	- dispatch_once 依赖于 dispatch_once_t 变量和底层的 os_unfair_lock 机制。其内部实现是基于原子操作 (Atomic Operation) 和 内存屏障 (Memory Barrier) 的：
	- dispatch_once 需要传入一个 dispatch_once_t 变量，该变量的初始值是 0。
	- dispatch_once 内部使用了原子操作（如 compare-and-swap 或 os_unfair_lock），确保多个线程同时访问时不会发生竞态条件（Race Condition）。
	- 当 dispatch_once 被调用时，它会检查 dispatch_once_t 变量是否已被设置：
	- 如果是 0，则执行代码块，并将变量设置为非零值（通常是 1）。
	- 如果不是 0，则直接跳过，保证代码块不会被重复执行。


<br/>

**使用**

```
static dispatch_once_t onceToken;
dispatch_once(&once_token, ^{
	//创建单例、method swizzled或其他任务
})
```

<br/><br/>
> <h3 id='原理'>原理</h3>

```
//调用dispatch_once_f来处理
void dispatch_once(dispatch_once_t *val, dispatch_block_t block) {
    dispatch_once_f(val, block, _dispatch_Block_invoke(block));
}
```

dispatch_once封装调用了dispatch_once_f函数，其中通过_dispatch_Block_invoke来执行block任务，它的定义如下：

```objective-c
//invoke是指触发block的具体实现，感兴趣的可以看一下Block_layout的结构体
//
_dispatch_Block_invoke 函数是 Grand Central Dispatch (GCD) 框架内部使用的函数，其目的是执行传递给它的块（block）中的代码。
//在 GCD 中，块是一种封装了一段代码的结构，它可以在后台线程或其他队列中异步执行。
//"invoke" 意味着执行或调用。所以，_dispatch_Block_invoke 的作用是调用传递给它的块中的代码，实现异步执行。
//在你的代码中通常不需要直接调用这个函数，而是由 GCD 在后台进行管理和调度。
#define _dispatch_Block_invoke(bb) \
        ((dispatch_function_t)((struct Block_layout *)bb)->invoke)
```

接着看一下具体的实现函数dispatch_once_f：

```c
void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func) {
	// volatileg关键字编辑的变量vval，告诉编译器此指针指向的值随时可能被其他线程改变，从而使得编译器不对此指针进行代码编译优化。
	// 指针的最大的作用就是间接的改变变量的值
	struct _dispatch_once_waiter_s * volatile *vval =
	(struct _dispatch_once_waiter_s**)val;
	
	// 初始化一个结构体
	struct _dispatch_once_waiter_s dow = { NULL, 0 };
	
	// 声明辅助变量
	struct _dispatch_once_waiter_s *tail, *tmp;
	// 声明信号变量
	_dispatch_thread_semaphore_t sema;
	
	// 内置函数 原子比较交换函数 __sync_bool_compare_and_swap
	// 判断vval与NULL是否相等，如果相等就返回YES，并将&dow的值赋给vval
	// 当dispatch_once第一次执行时，predicate也即val为0,地址并不为NULL，但是将0转成链表的时候vval为NULL，那么此“原子比较交换函数”将返回YES并将vval指向值赋值为&dow，即为“等待中”
	//_dispatch_client_callout其内部做了一些判定，但实际上是调用了func而已。到此，block中的用户代码执行完毕。
	// #1
	if (dispatch_atomic_cmpxchg(vval, NULL, &dow, acquire)) {
		dispatch_atomic_acquire_barrier();//这是一个空的宏函数，大概是注释的作用吧
	
		// 其实质是执行block
		_dispatch_client_callout(ctxt, func);
	
		// cpuid指令等待，使得其他线程的【读取到未初始化值的】预执行能被判定为猜测未命中，从而使得这些线程能够进入dispatch_once_f里的另一个分支从而进行等待
		dispatch_atomic_maximally_synchronizing_barrier();
	
		dispatch_atomic_release_barrier(); //这是一个空的宏函数，大概是注释的作用吧
	
		// dispatch_atomic_xchg 其将第二个参数的值赋给第一个参数（解引用指针），然后返回第一个参数被赋值前的解引用值：
		// vval = &dow;
		// old = vval;
		// vval = DISPATCH_ONCE_DONE;// 置block完成标记，是置成NULL吗
		// tmp = old;
		tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE, relaxed);
		tail = &dow;
	
		// tmp = 旧的vval = dow
		// vval = dow;
		// 接下来是对信号量链的处理：
		// 1.在block执行过程中，没有其他线程进入本函数来等待，则vval指向值保持为&dow，即tmp被赋值为&dow，即下方while循环不会被执行，此分支结束。
		// 2.在block执行过程中，有其他线程进入本函数来等待进入另一个分支，那么会构造一个信号量链表（vval指向值变为信号量链的头部，链表的尾部为&dow），此时就会当前分支进入while循环，在此while循环中，遍历链表，逐个signal每个信号量，然后结束循环。
		while (tail != tmp) {
			while (!tmp->dow_next) {
				// 此句是为了提示cpu减少额外处理，提升性能，节省电力。
				dispatch_hardware_pause();
			}
			sema = tmp->dow_sema;
			tmp = (struct _dispatch_once_waiter_s*)tmp->dow_next;
			_dispatch_thread_semaphore_signal(sema);
		}
	} else {
		// #2
		// 当执行block分支#1未完成，且有线程再进入本函数时，将进入线程等待分支：
		// 先调用_dispatch_get_thread_semaphore创建一个信号量，此信号量被赋值给dow.dow_sema。
		// 然后进入一个无限for循环，假如发现vval的指向值已经为DISPATCH_ONCE_DONE，即“完成”，则直接break，然后调用_dispatch_put_thread_semaphore函数销毁信号量并退出函数
		// _dispatch_get_thread_semaphore内部使用的是“有即取用，无即创建”策略来获取信号量。
		dow.dow_sema = _dispatch_get_thread_semaphore();
		tmp = *vval;
	
	// 然后进入一个无限for循环
	for (;;) {
		tmp = *vval;
		// 假如发现vval的指向值已经为DISPATCH_ONCE_DONE，即“完成”，则直接break
		// 然后调用_dispatch_put_thread_semaphore函数销毁信号量并退出函数。
		if (tmp == DISPATCH_ONCE_DONE) {
			break;
		}
		dispatch_atomic_store_barrier();// 注释作用
	
		/*
		假如vval的解引用值并非DISPATCH_ONCE_DONE，则进行一个“原子比较并交换”操作（此操作可以避免两个等待线程同时操作链表带来的问题）
		假如此时vval指向值已不再是tmp（这种情况发生在多个线程同时进入线程等待分支#2，并交错修改链表）则for循环重新开始，再尝试重新获取一次vval来进行同样的操作；若指向值还是tmp，则将vval的指向值赋值为&dow，此时val->dow_next值为NULL，可能会使得block执行分支#1进行while等待（如前述），紧接着执行dow.dow_next = tmp这句来增加链表节点（同时也使得block执行分支#1的while等待结束），然后等待在信号量上，当block执行分支#1完成并遍历链表来signal时，唤醒、释放信号量，然后一切就完成了。
		*/
		// 此操作可以避免两个等待线程同时操作链表带来的问题
		// 判断vval与tmp是否相等，如果相等就返回YES，并将&dow的值赋给vval
		if (dispatch_atomic_cmpxchg(vval, tmp, &dow)) {
			dow.dow_next = tmp;
			_dispatch_thread_semaphore_wait(dow.dow_sema);
		}
	}
	// _dispatch_put_thread_semaphore内部使用的是“销毁旧的，存储新的”策略来缓存信号量
	_dispatch_put_thread_semaphore(dow.dow_sema);
}
```

<br/><br/>
> <h3 id='dispatch_function_t'>dispatch_function_t</h3>
&emsp; **dispatch_function_t** 是一个函数指针类型。具体来说，dispatch_function_t 是一个指向函数的指针，该函数的签名为 void (*dispatch_function_t)(void *);。

&emsp; 这个函数指针类型主要用于指定 GCD 任务执行时的代码块。当你使用 GCD 提交一个任务时，可以将一个函数或块传递给 GCD，用于在后台线程或其他队列中执行。这个函数或块的类型就是 dispatch_function_t，它接受一个 void * 类型的参数，通常用于传递上下文或其他数据。

<br/>
示例用法可能如下：

```
void myDispatchFunction(void *context) {
    // 执行任务的代码
}

// 创建一个 dispatch_function_t 类型的指针
dispatch_function_t myFunctionPointer = &myDispatchFunction;

// 提交任务给 GCD，指定要执行的函数或块
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    myFunctionPointer(someContext); // 这里传递了上下文参数
});
```

在这个例子中，myDispatchFunction 是一个符合 dispatch_function_t 类型的函数，然后通过将它的指针传递给 GCD，你可以在后台线程中执行相应的代码。

<br/><br/>

**dispatch_function_t**
<br/>

由上面的代码可知dispatch_once的流程图大致如下：

![ios_oc1_99.png](./../../Pictures/ios_oc1_99.png)

&emsp; 首先看一下dispatch_once中用的的原子性操作dispatch_atomic_cmpxchg(vval, NULL, &dow, acquire)，它的宏定义展开之后会将$dow赋值给vval，如果vval的初始值为NULL，返回YES,否则返回NO。

&emsp; 首次调用dispatch_once时，因为外部传入的dispatch_once_t变量值为nil，故vval会为NULL，故if判断成立。然后调用_dispatch_client_callout执行block，然后在block执行完成之后将vval的值更新成DISPATCH_ONCE_DONE表示任务已完成。最后遍历链表的节点并调用_dispatch_thread_semaphore_signal来唤醒等待中的信号量；

&emsp; 当其他线程同时也调用dispatch_once时，因为if判断是原子性操作，故只有一个线程进入到if分支中，其他线程会进入else分支。在else分支中会判断block是否已完成，如果已完成则跳出循环；否则就是更新链表并调用_dispatch_thread_semaphore_wait阻塞线程，等待if分支中的block完成后再唤醒当前等待的线程。

<br/>

**总结篇**

&emsp; dispatch_once用原子性操作block执行完成标记位，同时用信号量确保只有一个线程执行block，等block执行完再唤醒所有等待中的线程。

<br/><br/><br/>
> <h2 id='并发'>并发</h2>
&emsp; 在 iOS 并发编程技术中，GCD 的使用率是最高的。所以，在这篇文章中，我就以 GCD 为例和你说说多线程的并发问题。


&emsp; GCD（Grand Central Dispatch）是由苹果公司开发的一个多核编程解决方案。它提供的一套简单易用的接口，极大地方便了并发编程。同时，它还可以完成对复杂的线程创建、释放时机的管理。但是，GCD 带来这些便利的同时，也带来了资源使用上的风险。

<br/><br/>
> <h2 id='全局并发队列'>全局并发队列</h2>


**全局并发队列`dispatch_get_global_queue`:** 是并发队列的一种形式，所以它是**并发队列**,因此你可以使用它来执行多个任务并发地。

全局并发队列是系统提供的一组并发队列，可供应用程序使用，以便在多个任务之间并行执行。这些全局队列根据优先级分为不同的队列，包括高、中、低三个优先级。

```
dispatch_queue_t dispatch_get_global_queue(
    long identifier,
    unsigned long flags
);
```

- identifier 参数用于指定全局队列的优先级，通常取值为：

```
DISPATCH_QUEUE_PRIORITY_HIGH
DISPATCH_QUEUE_PRIORITY_DEFAULT
DISPATCH_QUEUE_PRIORITY_LOW
DISPATCH_QUEUE_PRIORITY_BACKGROUND

flags 参数是保留字段，目前应该始终为0。
```

<br/>

在iOS中，每个应用程序运行在自己的沙盒中，具有独立的进程和资源。因此，一个应用程序中获取的全局队列不会与其他应用程序共享。

所以，抖音APP和头条APP在获取全局队列时，它们获取的是各自应用程序内部的全局队列实例，而不是共享同一个全局队列。这意味着它们的任务互不干扰，各自运行在独立的上下文中。

<br/><br/>

**疑问1:** 若是在一个app里全局队列是共享的,那么这个共享是数据共享吗? 若不是那是什么共享?

<br/>

这里的共享不涉及数据的共享，而是指多个应用程序都可以使用相同的全局并发队列。这样，无论哪个应用程序请求该队列，都会得到同一个全局队列的引用，而不是每个应用程序都有自己独立的全局队列。

这样的设计有助于系统资源的有效利用，因为全局队列是系统级别的，可以服务于多个应用程序的并发任务需求。每个应用程序都可以获取对全局队列的引用，并使用它来执行并发任务。

总之，共享在这里是指系统层面上的资源共用，而不是特定的数据共享。这样的共享设计使得系统能够更好地管理并发任务，提高资源利用率。


<br/><br/>

**疑问2:** 这个全局队列可以理解为是系统分配管理的,比如抖音app里的一个全局队列不使用了,然后头条app需要一个全局队列,那么这个全局队列就被系统分配给头条app使用吗? 

<br/>


全局队列是由系统管理的，而不是由应用程序管理。全局队列是基于系统的调度算法和优先级系统的。当一个应用程序请求获取一个全局队列时，它获取的是系统中相应优先级的全局队列实例，而不是与其他应用程序共享同一个实例。

具体来说，如果一个应用程序使用了一个全局队列，然后该队列中的任务执行完毕，这个应用程序释放了对该队列的引用，那么该队列就变得空闲。当另一个应用程序请求获取相同优先级的全局队列时，系统可能会重用之前空闲的全局队列实例，但这不是一个直接的共享机制。每个应用程序都能获取到自己的队列实例，它们之间是相互独立的。

若某一个应用程序获取了一个全局队列,因为每个应用程序都运行在自己的沙盒中，具有独立的进程和资源。因此，一个应用程序中获取的全局队列中的数据和状态是不会与其他应用程序共享的,各自运行在独立的上下文中。

在总体上，全局队列的管理是由系统自动进行的，而不是由应用程序显式控制的。这有助于系统根据需求和资源自动调整队列的行为，以实现更有效的并发处理。



<br/><br/>
> <h2 id='全局并发队列与普通并发队列区别'>全局并发队列与普通并发队列区别</h2>
- **全局并发队列：**
	- 系统提供： 全局并发队列是系统在应用程序运行时提供的一组队列，可以通过 dispatch_get_global_queue 函数获取。
	- 优先级： 全局队列按照优先级划分，有高、默认、低和后台四个优先级。
	- 标签： 全局队列具有一个标签，用于标识其优先级。例如，DISPATCH_QUEUE_PRIORITY_DEFAULT 对应的全局队列标签是 "com.apple.root.default-qos"。
	- 共享： 全局队列是系统级别的，可能被多个应用程序共享。

示例：

```
dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_async(globalQueue, ^{
    // 执行异步任务
});
```

<br/><br/>

**普通并发队列：**
- 开发者创建： 普通并发队列是由开发者创建的队列，可以通过 dispatch_queue_create 函数自定义。
- 优先级： 与全局队列不同，普通队列不会按照系统定义的优先级划分，而是由开发者在创建队列时指定。
- 标签： 普通队列可以由开发者指定一个标签，用于标识队列的用途。
- 不共享： 普通队列是应用程序级别的，只能在当前应用程序内使用。

示例：

```
dispatch_queue_t customQueue = dispatch_queue_create("com.example.myqueue", DISPATCH_QUEUE_CONCURRENT);
dispatch_async(customQueue, ^{
    // 执行异步任务
});
```


**总结：**
- 全局并发队列是系统提供的，按照优先级分组，是共享的。
- 普通并发队列是由开发者创建的，可以根据需要指定优先级和标签，是应用程序私有的。


选择使用全局队列还是自定义队列通常取决于任务的性质和开发者的需求。全局队列适用于一般的并发任务，而自定义队列则允许更灵活地管理任务的执行。

<br/><br/>
> <h3 id='dispatch_get_global_queue()'>dispatch_get_global_queue()</h3>

&emsp; 例如，在进行数据读写操作时，总是需要一段时间来等待磁盘响应的，如果在这个时候通过 GCD 发起了一个任务，那么 GCD 就会本着最大化利用 CPU 的原则，会在等待磁盘响应的这个空档，再创建一个新线程来保证能够充分利用 CPU。

<br/>

&emsp; 而如果 GCD 发起的这些新任务，都是类似于数据存储这样需要等待磁盘响应的任务的话，那么随着任务数量的增加，GCD 创建的新线程就会越来越多，从而导致内存资源越来越紧张，等到磁盘开始响应后，再读取数据又会占用更多的内存。结果就是，失控的内存占用会引起更多的内存问题。

<br/>

&emsp; 这种情况最典型的场景就是数据库读写操作。[FMDB](https://github.com/ccgus/fmdb)是一个开源的第三方数据库框架，通过 FMDatabaseQueue 这个核心类，将与读写数据库相关的磁盘操作都放到一个串行队列里执行，从而避免了线程创建过多导致系统资源紧张的情况。


```

NSLog(@"11111------->>Post 线程请求： %@", [NSThread currentThread]);

dispatch_async(dispatch_get_global_queue(), ^{
	//网络请求，耗时操作
	NSLog(@"22222------->>Post 线程请求： %@", [NSThread currentThread]);
	
	dispatch_async(dispatch_get_main_queue(), ^{
	        //网络请求到数据，进入主线程，开始把数据放到UI上
	        NSLog(@"~~~~222------->>Post 线程请求： %@", [NSThread currentThread]);
	
	    });

});

```

打印结果：

```

2018-12-03 10:52:00.338757+0800 TaiChi_iOS[12042:777252] 11111------->>Post 线程请求： <NSThread: 0x281ebef00>{number = 1, name = main}
2018-12-03 10:52:00.618865+0800 TaiChi_iOS[12042:777252] 22222------->>Post 线程请求： <NSThread: 0x281ebef00>{number = 1, name = main}
2018-12-03 10:52:00.629733+0800 TaiChi_iOS[12042:777252] ~~~~222------->>Post 线程请求： <NSThread: 0x281ebef00>{number = 1, name = main}

```

`结论：`dispatch_get_global_queue()这个线程队列，开启线程队列会视情况而定，有时会开启线程有时不会开启线程。

<br/>

为了能够支持以后可能更大的并发量，下面我将其中“已读”功能的数据库操作改成 FMDatabaseQueue。这样，我就可以将并行队列转化为串行队列来执行，避免大并发读写磁盘操作造成内存问题，改写代码如下：

```
// 标记文章已读
- (RACSignal *)markFeedItemAsRead:(NSUInteger)iid fid:(NSUInteger)fid{
    @weakify(self);
    return [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {
        @strongify(self);
        // 改写成 FMDatabaseQueue 串行队列进行数据库操作
        FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:self.feedDBPath];
        [queue inDatabase:^(FMDatabase *db) {
            FMResultSet *rs = [FMResultSet new];
            // 读取文章数据
            if (fid == 0) {
                rs = [db executeQuery:@"select * from feeditem where isread = ? and iid >= ? order by iid desc", @(0), @(iid)];
            } else {
                rs = [db executeQuery:@"select * from feeditem where isread = ? and iid >= ? and fid = ? order by iid desc", @(0), @(iid), @(fid)];
            }
            NSUInteger count = 0;
            while ([rs next]) {
                count++;
            }
            // 更新文章状态为已读
            if (fid == 0) {
                [db executeUpdate:@"update feeditem set isread = ? where iid >= ?", @(1), @(iid)];
            } else {
                [db executeUpdate:@"update feeditem set isread = ? where iid >= ? and fid = ?", @(1), @(iid), @(fid)];
            }
            
            [subscriber sendNext:@(count)];
            [subscriber sendCompleted];
            [db close];
        }];
        return nil;
    }];
}
```

如代码所示，你只需要将数据库的操作放到 FMDatabaseQueue 的 inDatabase 方法入参 block 中，就可以在 FMDatabaseQueue 维护的串行队列里排队等待执行了.

<br/><br/><br/>
> <h2 id='线程组和依赖'>线程组和依赖</h2>  
- **`dispatch_group常用方法：`**
	- `dispatch_group_enter` :通知 group,下个任务要放入 group 中执行了
	- `dispatch_group_leave`: 通知 group,任务成功完成,要移除,与 enter成对出现
	- `dispatch_group_wait`: 在任务组完成时调用，或者任务组超时是调用（完成指的是enter和leave次数一样多）
	- `dispatch_group_notify`: 只要任务全部完成了,就会在最后调用


[**dispatch_group_enter和dispatch_group_leave 网络请求嵌套**](https://www.jianshu.com/p/71fbc0415b5d)


<br/><br/>
> <h3 id='线程组处理'>线程组处理</h3>

```
{
    // 创建队列组
    dispatch_group_t group =  dispatch_group_create();
    // 创建并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
 
    // 开子线程，任务1
    dispatch_group_async(group, queue, ^{
        [NSData dataWithContentsOfURL:[NSURL URLWithString:@"https://img-blog.csdn.net/20180421152137506"]];
        NSLog(@"任务1 完成，线程：%@", [NSThread currentThread]);
    });
 
    // 开子线程，任务2
    dispatch_group_async(group, queue, ^{
        [NSData dataWithContentsOfURL:[NSURL URLWithString:@"https://img-blog.csdn.net/20170112145924755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGVyb193cWI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"]];
        NSLog(@"任务2 完成，线程：%@", [NSThread currentThread]);
    });
 
    // 全部完成
    dispatch_group_notify(group, queue, ^{
        dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@"全部完成，线程：%@", [NSThread currentThread]);
        });
    });
}
```

输出结果：

```
AsyTaskTest[5963:308229] 任务1 完成，线程：<NSThread: 0x604000263380>{number = 3, name = (null)}

AsyTaskTest[5963:308228] 任务2 完成，线程：<NSThread: 0x60400007c4c0>{number = 4, name = (null)}

AsyTaskTest[5963:308103] 全部完成，线程：<NSThread: 0x604000070600>{number = 1, name = main}

```

<br/><br/>
> <h2 id='时间延迟'>时间延迟</h2>
<br/>

> <h3 id='dispatch_after'>dispatch_after</h3>
&emsp;  `dispatch_after`是在指定的时间将任务加入到队列中，而不是在指定的时间执行，如果所在的队列上有耗时任务在执行，那么时间上可能出现误差。

```
void  dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);
```

```

NSLog(@"2秒后开始执行");
dispatch_after( dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(),^{
    NSLog(@"等2秒，开始执行任务");
    sleep(2);
    NSLog(@"任务执行完成");
} );

```

输出：

```
2019-05-14 11:51:26.890458+0800 Genealogy[1897:44256] 2秒后开始执行

2019-05-14 11:51:35.784266+0800 Genealogy[1897:44256] 等2秒，开始执行任务

2019-05-14 11:51:40.692939+0800 Genealogy[1897:44256] 任务执行完成
```

<br/><br/>
> <h3 id='dispatch_time_t'>dispatch_time_t</h3>
`dispatch_time_t`:用来指定时间，传入的是dispatch_time_t类型的值，通过dispatch_time和dispatch_walltime函数生成;

<br/>

`dispatch_time_t
dispatch_time(dispatch_time_t when, int64_t delta);`


`dispatch_time_t when`:时间点;
`int64_t delta`时间长度;

&emsp;  函数的作用就是获取时间点经过时间长度之后的时间点。第一个参数我们经常使用的是DISPATCH_TIME_NOW，表示现在这个时间点。第二个参数表示的时间长度使用数组* NSEC_PER_SEC的方式获得。

- `NSEC_PER_SEC` 表示秒

- `NSEC_PER_MSEC` 表示毫秒

- `NSEC_PER_USEC` 表示微秒

<br/>

- **dispatch_queue_t queue**: 任务添加的队列;

<br/><br/>
> <h3 id='dispatch_walltime'>dispatch_walltime</h3>

```
dispatch_time_t
dispatch_walltime(const struct timespec *_Nullable when, int64_t delta);

const struct timespec *_Nullable when`:  一个struct timespec类型的值;
int64_t delta`:  以纳秒为单位的延迟时间;
```


```

//设置时间点为2秒后
NSTimeInterval iT = [[NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]] timeIntervalSince1970];

struct timespec time;
time.tv_sec = (NSInteger)iT;
//比时间点再晚10秒
dispatch_time_t timer = dispatch_walltime(&time, 10*NSEC_PER_SEC);
NSLog(@"12秒后开始任务");
dispatch_after(timer, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
    NSLog(@"任务开始");
    
    sleep(1);

    NSLog(@"任务完成");
});

```


输出：

```
2019-05-14 12:06:25.194589+0800 Genealogy[2330:55634] 6秒后开始任务`

2019-05-14 12:06:33.000349+0800 Genealogy[2330:55725] 任务开始

2019-05-14 12:06:34.003165+0800 Genealogy[2330:55725] 任务完成
```

<br/><br/>
> <h3 id='线程暂停&恢复'>线程暂停&恢复</h3>

[Parse的底层多线程处理思路](https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-ios-sdk介绍)

当追加大量处理到Dispatch Queue时，在追加处理的过程中，有时希望不执行已追加的处理。

在这种情况下，只要挂起Dispatch Queue即可。当可以执行时再恢复。

```
dispatch_suspend(queue);
```


**dispatch_resume** 函数恢复指定的 Dispatch Queue . 这些函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中.但尚未执行的处理在此之后停止执行。而恢复则使得这些处理能够继续执行。

分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。因为忘记恢复分派源的状态而产生bug是常见的事儿。恢复的方法是调用 dispatch_resume :

```
dispatch_resume (source);
```

<br/><br/><br/>

***
<br/>

>## <h1 id='锁'>[锁](https://blog.csdn.net/ssy_1992/article/details/104822090)</h1>

[13种线程锁](https://juejin.cn/post/6844903716265394184#heading-1)

<br/>
> <h2 id='锁分类'>锁分类</h2>
iOS的线程锁主要可以分为两大类:**互斥锁** 和 **自旋锁**，其他锁都是这两种锁的延伸和扩展。

- **互斥锁:**
	- [NSLock](#NSLock): 是「非」递归互斥锁, 使用了pthread_mutex_t封装的互斥锁
	- [NSCondition](#NSCondition): 使用pthread_mutex_t封装的互斥锁;
	- [NSConditionLock](#NSConditionLock): 有条件的互斥锁;
	- [NSRecursiveLock](#递归锁NSRecursiveLock): 互斥锁中的递归锁;
	- [@synchronized](#对象锁/同步锁@synchronized): 底层实现是个递归锁;
	- [pthread_mutex](#pthread_mutex): 

<br/>

- **自旋锁:**
	- [pthread_rwlock](#读写锁pthread_rwlock): 读写锁;



互斥锁：属于sleep-waiting类型的锁，线程A获取到锁，在释放锁之前，其他线程都获取不到锁。

- **互斥锁也分为两种：**
	- 递归锁：可重入锁，同一个线程在锁释放前可再次获取锁，即可以递归调用
	- 非递归锁：不可重入，必须等锁释放后才能再次获取锁。


自旋锁：线程A获取到锁，在释放锁之前，线程B又来获取锁，此时获取不到，线程B就会不断的进入循环，一直检查锁是否已被释放，如果释放，则能获取到锁。


<br/><br/>

**区别:**

- 互斥锁：当线程获取锁但没有获取到时，线程会进入休眠状态，等锁被释放时，线程会被唤醒，同时获取到锁，继续执行任务，互斥锁会改变线程的状态。线程从sleep（加锁）—>running（解锁）的过程中，有上下文的切换，cpu的抢占，信号的发送等开销。

- 自旋锁：当线程获取锁但没获取到时，不会进入休眠，而是一直循环，线程始终处于活跃状态，不会改变线程状态，也就是忙等。线程一直是running(加锁—>解锁)，死循环检测锁的标志位。递归调用自旋锁一定会死锁。

- 对比：互斥锁的起始原始开销要高于自旋锁，但是基本是一劳永逸，临界区持锁时间的大小并不会对互斥锁的开销造成影响，而自旋锁是死循环检测，加锁全程消耗cpu，起始开销虽然低于互斥锁，但是随着持锁时间，加锁的开销是线性增长。

<br/><br/>

**使用场景:**

- 互斥锁会改变线程的状态，使得内核不断的调度线程资源，因此效率上比自旋锁要低很多，不适合使用自旋锁的场景都使用互斥锁。

- 自旋锁在线程的等待过程中是活跃的，避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。因此自旋锁适合用于短时间内的轻量级锁定，主要用在临界区持锁时间非常短且CPU资源不紧张的情况下。

<br/><br/>
> <h2 id='OSSpinLock'>OSSpinLock</h2>
&emsp; OSSpinLock:自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适。


<br/>

**OSSpinLock的优先级反转:**

&emsp; 比如两个线程 A 和 B，优先级 A < B。当 A 获取锁访问共享资源时，B 尝试获取锁，那么 B 就会进入忙等状态，忙等时间越长对 CPU 资源的占用越大；而由于 A 的优先级低于 B，A 无法与高优先级的线程争夺 CPU 资源，从而导致任务迟迟完成不了, 无法释放lock.

解决优先级反转的方法有“优先级天花板”和“优先级继承”，它们的核心操作都是提升当前正在访问共享资源的线程的优先级。

OSSpinLock 因为优先级反转这个问题导致很多开源库都放弃使用了,**而苹果的开发工程师已经停用了OSSpinLock, 在iOS10时OSSpinLock被标记为Deprecated**.

<br/><br/>
> <h2 id='NSLock'>NSLock</h2>
NSLock是**非递归互斥锁。**

NSLocking只定义了加锁（获取锁）`-lock`，和解锁（释放锁）`-unlock`两个接口。NSLock、NSConditionLock、NSRecursiveLock、NSCondition都实现了这个协议

```objective-c
@protocol NSLocking

- (void)lock;
- (void)unlock;

@end
```

`-lock`和`-unlock`必须在相同的线程调用，也就是说，他们必须在同一个线程中成对调用，否则会产生未知结果

NSLock是使用了`pthread_mutex_t`封装的互斥锁。

<br/>

**案例:**

```
#import <Foundation/Foundation.h>

@interface MyObject : NSObject

@property (nonatomic, strong) NSLock *myLock;
@property (nonatomic, assign) NSInteger sharedValue;

- (void)updateSharedValue;

@end

@implementation MyObject

- (instancetype)init {
    self = [super init];
    if (self) {
        _myLock = [[NSLock alloc] init];
        _sharedValue = 0;
    }
    return self;
}

- (void)updateSharedValue {
    // 使用 NSLock 进行加锁
    [self.myLock lock];
    
    // 在这里执行需要同步的操作
    NSInteger tempValue = self.sharedValue;
    tempValue++;
    [NSThread sleepForTimeInterval:1]; // 模拟耗时操作
    self.sharedValue = tempValue;
    
    // 解锁
    [self.myLock unlock];
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        MyObject *myObject = [[MyObject alloc] init];
        
        // 创建两个线程同时修改 sharedValue
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            [myObject updateSharedValue];
            NSLog(@"Thread 1: Updated sharedValue to %ld", (long)myObject.sharedValue);
        });
        
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            [myObject updateSharedValue];
            NSLog(@"Thread 2: Updated sharedValue to %ld", (long)myObject.sharedValue);
        });
        
        // 等待所有线程执行完成
        dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            // 所有线程执行完成后，输出最终的 sharedValue
            NSLog(@"Final sharedValue: %ld", (long)myObject.sharedValue);
        });
    }
    return 0;
}
```

&emsp; 在这个例子中，MyObject 类包含了一个 NSLock 对象（myLock），以及一个需要同步访问的共享资源 sharedValue。updateSharedValue 方法使用 NSLock 对共享资源进行加锁和解锁，确保在同一时刻只有一个线程可以修改 sharedValue。

&emsp; 需要注意的是，在实际开发中，可以使用更高级别的同步机制，如 @synchronized 关键字、dispatch_semaphore_t 等，根据具体的需求选择合适的同步方式。

<br/><br/>

**拓展:** 
下面是对NSLock的简化版本,如下:

```
#import <pthread.h>

@interface NSLock : NSObject

- (void)lock;
- (void)unlock;

@end

@implementation NSLock {
    pthread_mutex_t _mutex;
}

- (instancetype)init {
    self = [super init];
    if (self) {
        pthread_mutex_init(&_mutex, NULL);
    }
    return self;
}

- (void)lock {
    pthread_mutex_lock(&_mutex);
}

- (void)unlock {
    pthread_mutex_unlock(&_mutex);
}

- (void)dealloc {
    pthread_mutex_destroy(&_mutex);
}

@end

```
&emsp; 这里，NSLock 内部维护了一个 _mutex 成员变量，它是一个 pthread_mutex_t 类型的变量。在 init 方法中，通过 pthread_mutex_init 进行初始化，而在 dealloc 方法中通过 pthread_mutex_destroy 进行清理。

&emsp; lock 方法调用了 pthread_mutex_lock，该函数会阻塞调用线程，直到它获得了互斥锁。如果互斥锁已经被其他线程锁定，那么当前线程会被阻塞，直到锁被释放为止。

&emsp; unlock 方法调用了 pthread_mutex_unlock，它用于释放互斥锁，允许其他线程获得锁。

&emsp; 总体来说，NSLock 利用了 pthread_mutex_t 的基本功能，提供了一个高级别的 Objective-C 接口，使得在多线程环境中更容易管理锁。在实际使用中，你可以选择使用更高级别的同步机制，如 @synchronized 关键字、dispatch_semaphore_t，或者 NSRecursiveLock，根据具体需求来选择适当的锁类型。


<br/><br/>
> <h2 id='NSCondition'>NSCondition</h2>
NSCondition也是使用了pthread_mutex_t封装的互斥锁，和NSLock中一模一样，同时还使用了pthread_cond_t。它和NSLock的区别是：

NSLock在获取不到锁的时候自动使线程进入休眠，锁被释放后线程又自动被唤醒
NSCondition可以使我们更加灵活的控制线程状态，在任何需要的时候使线程进入休眠或唤醒它。

- [condition lock]：一般用于多线程同时访问、修改同一个数据源，保证在同一 时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到 unlock ，才可访问
- [condition unlock]：与lock 同时使用
- [condition wait]：让当前线程处于等待状态
- [condition signal]：CPU发信号告诉线程不用在等待，可以继续执行

<br/><br/>
> <h2 id='NSConditionLock'>NSConditionLock</h2>
NSConditionLock条件锁就是有特定条件的锁，说白了就是「有条件的互斥锁」。

- 1).只读属性condition，保存锁当前的条件（所谓的条件condition就是个NSInteger）
- 2).-lockWhenCondition:：获取锁，如果condition与属性相等，则可以获得锁，否则阻塞线程，等待被唤醒
- 3).-unlockWithCondition:释放锁，并修改condition属性

基本用法：

```
// 主线程
self.conditionLock = [[NSConditionLock alloc] init];
    
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    NSLog(@"进入线程1");
    // 当 lock.condition = 2 时，能够获取到锁，否则休眠等待
    [self.conditionLock lockWhenCondition:2];
    NSLog(@"执行任务1");
    sleep(1);
    [self.lock unlock];
    NSLog(@"退出线程1");
});
    
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    NSLog(@"进入线程2");
    [self.conditionLock lockWhenCondition:1];
    NSLog(@"执行任务2");
    sleep(5);
    // 将 lock.condition 修改为2，线程1就能获得锁了
    [self.conditionLock unlockWithCondition:2];
    NSLog(@"退出线程2");
});
    
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    NSLog(@"进入线程3");
    [self.lock lock];
    NSLog(@"执行任务3");
    sleep(2);
    // 将 lock.condition 修改为1，线程2就能获得锁了
    [self.conditionLock unlockWithCondition:1];
    NSLog(@"退出线程3");
});
```

打印结果：

```
2020-04-24 16:20:44.901816+0800 lock[48829:11985930] 进入线程3
2020-04-24 16:20:44.901816+0800 lock[48829:11985929] 进入线程2
2020-04-24 16:20:44.901860+0800 lock[48829:11985931] 进入线程1
2020-04-24 16:20:44.902052+0800 lock[48829:11985930] 执行任务3
2020-04-24 16:20:46.906596+0800 lock[48829:11985930] 退出线程3
2020-04-24 16:20:46.906618+0800 lock[48829:11985929] 执行任务2
2020-04-24 16:20:51.908623+0800 lock[48829:11985931] 执行任务1
2020-04-24 16:20:51.908629+0800 lock[48829:11985929] 退出线程2
2020-04-24 16:20:52.913340+0800 lock[48829:11985931] 退出线程1
```

- [xxx lockWhenCondition:A条件]：表示如果没有其他线程获得该锁，但是该锁内部的 condition不等于A条件，它依然不能获得锁，仍然等待。如果内部的condition等于A条件，并 且没有其他线程获得该锁，则进入代码区，同时设置它获得该锁，其他任何线程都将等待它代码 的完成，直至它解锁。

- -tryLockWhenCondition:，即使在未来某个时间点可以满足条件，它只根据当前condition获取锁，无论能否获取到锁，该线程都会继续向下执行，不会阻塞。

- -lockWhenCondition:beforeDate: 就是要在超时之前，并且满足条件才能获取到锁，返回YES，否则返回NO。同时如果被锁定(已获得锁)，并超过该时间也不再阻塞线程。

- NSCondition使用了一个单一条件，而NSConditionLock似乎把这个条件暴露为参数给我们使用，并且可以是不同的条件。

<br/><br/>
> <h2 id='递归锁NSRecursiveLock'>递归锁NSRecursiveLock</h2>

NSRecursiveLock是互斥锁中的递归锁，可被 同一线程多次获取，而不会产生死锁。什么意思呢，一个线程已经获得了锁，开始执行受锁保护的代码（锁还未释放），如果这段代码调用了其他函数，而被调用的函数又要获取这个锁，此时已然可以获得锁并正常执行，而不会死锁。

基本用法：

```
- (void)testLock{
    self.lock = [[NSRecursiveLock alloc] init];
    [NSThread detachNewThreadSelector:@selector(testLock1) toTarget:self withObject:nil];
    [NSThread detachNewThreadSelector:@selector(testLock3) toTarget:self withObject:nil];
}

- (void)testLock1 {
    [self.lock lock];
    NSLog(@"testLock1");
    [self testLock2];
    [self.lock unlock];
    NSLog(@"testLock1: unlock");
}

- (void)testLock2 {
    [self.lock lock];
    NSLog(@"testLock2");
    [self.lock unlock];
    NSLog(@"testLock2: unlock");
}

- (void)testLock3 {
    [self.lock lock];
    NSLog(@"testLock3: %@", [NSThread currentThread]);
    [self.lock unlock];
    NSLog(@"testLock3: unlock");
}
```

与NSLock相比，NSRecursiveLock也实现了NSLocking协议，并定义了两个方法，这些接口的使用和NSLock是完全相同的。唯一不同的就是NSRecursiveLock可递归调用，而NSLock如果想上面描述的场景使用的话就会死锁。

实际上NSRecursiveLock可以递归，只是给锁设置了一个递归属性，具体的实现是在pthread中实现的.有兴趣的童鞋可以研究下pthread或者POSIX

<br/><br/>
> <h2 id='对象锁/同步锁@synchronized'>对象锁/同步锁 @synchronized</h2>
@synchronized(id)的使用应该是较多的，它底层实现是个递归锁，不会产生死锁，且不需要手动去加锁解锁，使用起来比较方便

<br/><br/>
> <h2 id='dispatch_semaphore'>dispatch_semaphore</h2>
信号量semaphore是一种更高级的同步机制，互斥锁可以说是semaphore在仅取值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。

&emsp; dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。

- 信号量的初始值，可以用来控制线程并发访问的最大数量
- 信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步
- GCD的信号量是对系统内核信号量的一层封装，要想更深入的了解，可以去研究一下Linux内核的信号量。

```objective-c
//如果信号量的初始值为负，是不正确的
//表示最多开启value个线程
dispatch_semaphore_create(long value)
// 如果信号量的值 > 0，就让信号量的值减1，然后继续往下执行代码
// 如果信号量的值 <= 0，就会休眠等待，直到信号量的值变成>0，就让信号量的值减1，然后继续往下执行代码
// DISPATCH_TIME_FOREVER线程堵塞等待时间，该值表示一直等待；若为1，则表示超时等待1s，1s后继续执行代码
// 返回值，如果，==0表示线程未超时； >0，线程超时。
dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);
// 让信号量的值+1
dispatch_semaphore_signal(self.semaphore);
```


<br/><br/>
> <h3 id="网络请求依次执行">网络请求依次执行</h3>
<br/>

> <h4 id="dispatch_group_enter使用">dispatch_group_enter使用</h4>
我们就可以使用dispatch_group_enter了,在执行了多段之后再在 notify 中执行另一个,类似于栅栏的效果.但是如果是网络请求,需要达到网络请求嵌套的效果,A网络请求完之后再请求 B,需要添加dispatch_group_wait,让线程等待 A 执行完成之后再执行 B.

```objective-c
// A 请求数据
- (void)loadADataFinished:(void(^)(BOOL success))finished;
// B 请求数据
- (void)loadBDataFinished:(void(^)(BOOL success))finished;
// C 请求数据
- (void)loadCDataFinished:(void(^)(BOOL success))finished;

// 请求是否全部完成
- (void)finishedDataFinished:(void(^)(BOOL success))finished{
  dispatch_group_t group = dispatch_group_create(); 
  dispatch_group_enter(group);
  [self loadADataFinished:^(BOOL success){
    if (success){
      dispatch_group_leave(group);
    }else{
      finished(NO);
    }
  }];
  dispatch_group_enter(group);
  [self loadBDataFinished:^(BOOL success){
    if (success){
      dispatch_group_leave(group);
    }else{
      finished(NO);
    }
  }]; 

 dispatch_group_wait(group, DISPATCH_TIME_FOREVER);// A,B同时执行, 执行完才会执行下面的 C
 dispatch_group_enter(group);
 [self loadCDataFinished:^(BOOL success){
    if (success){
      dispatch_group_leave(group);
    }else{
      finished(NO);
    }
  }]; 
 
  //  group 中的任务都成功完成后,才会返回 YES
  dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        finished(YES);
   });
}
```

> <h4 id="dispatch_semaphore_t使用"> dispatch_semaphore_t使用</h4>
在我们的项目中,在一个 VC 中会有多个网络请求A,B.现在要实现的是:A 请求数据成功之后,再执行 B 的网络请求.这时候因为网络请求是异步的,所以我们要达到效果,需要在子线程中加入信号量dispatch_semaphore_t,在网络请求内部标记信号量,请求完成之后将信号量清为 0.

```objective-c
// A 请求数据
- (void)loadADataFinished:(void(^)(BOOL success))finished;
// B 请求数据
- (void)loadBDataFinished:(void(^)(BOOL success))finished;

dispatch_async(dispatch_get_global_queue(0, 0), ^{

        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
         [self loadADataFinished:^(BOOL success){
            if (success){ 
              }else{
                 finished(NO);
             }
              dispatch_semaphore_signal(semaphore);
         }]; 
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // A请求完成之后,请求 B
         [self loadBDataFinished:^(BOOL success){
            if (success){ 
              }else{
                 finished(NO);
             }
              dispatch_semaphore_signal(semaphore);
         }];  
});
```

<br/><br/>
> <h2 id='读写锁pthread_rwlock'>读写锁 pthread_rwlock</h2>
读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为 在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者(与CPU数相关)，但不能同时既有读者又有写者。在读写锁保持期间也是抢占失效的。

一次只有一个线程可以占有写模式的读写锁, 但是可以有多个线程同时占有读模式的读写锁。正是因为这个特性pthread_rwlock 适合于对数据结构的读次数比写次数多得多的情况。因为, 读模式锁定时可以共享, 以写模式锁住时意味着独占, 所以读写锁又叫共享-独占锁。

<br/>
- 使用时需要导入头文件#import <pthread.h>，iOS中的读写安全方案需要注意一下场景：
	- 同一时间，只能有1个线程进行写的操作
	- 同一时间，允许有多个线程进行读的操作
	- 同一时间，不允许既有写的操作，又有读的操作

<br/><br/>
> <h2 id='pthread_mutex'>pthread_mutex</h2>
mutex叫做”互斥锁”，等待锁的线程会处于休眠状态。需要导入头文件#import <pthread.h> 使用步骤。

简单使用：

```objective-c
@property (assign, nonatomic) pthread_mutex_t mutex;
@property (assign, nonatomic) pthread_cond_t cond;
@property (strong, nonatomic) NSMutableArray *data;

#pragma mark - mutex

- (void)testMutex{
    
    // 初始化属性
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    // 初始化锁
    pthread_mutex_init(&_mutex, &attr);
    // 销毁属性
    pthread_mutexattr_destroy(&attr);

    // 初始化条件
    pthread_cond_init(&_cond, NULL);

    self.data = [NSMutableArray array];

    
    [self otherTest];
}

- (void)otherTest {
    [[[NSThread alloc] initWithTarget:self selector:@selector(removeData) object:nil] start];

    [[[NSThread alloc] initWithTarget:self selector:@selector(addData) object:nil] start];
}

// 线程1
// 删除数组中的元素
- (void)removeData{
    pthread_mutex_lock(&_mutex);
    NSLog(@"remove - begin");

    if (self.data.count == 0) {
        // 等待
        pthread_cond_wait(&_cond, &_mutex);
    }

    [self.data removeLastObject];
    NSLog(@"删除了元素");

    pthread_mutex_unlock(&_mutex);
}

// 线程2
// 往数组中添加元素
- (void)addData{
    pthread_mutex_lock(&_mutex);

    sleep(1);

    [self.data addObject:@"Test"];
    NSLog(@"添加了元素");

    // 激活一个等待该条件的线程
    pthread_cond_signal(&_cond);
    
    pthread_mutex_unlock(&_mutex);
    NSLog(@"add - end");
}

- (void)dealloc{
    pthread_mutex_destroy(&_mutex);
    pthread_cond_destroy(&_cond);

}
```

PTHREAD_MUTEX_RECURSIVE 和 PTHREAD_MUTEX_DEFAULT，这两个属性会创建不同类型的锁，当然也会有不同的打印结果。

<br/><br/>
> <h2 id='dispatch_barrier_async'>dispatch_barrier_async</h2>
- 读写锁场景：
	- 同一时间，只能有1个线程进行写的操作
	- 同一时间，允许有多个线程进行读的操作
	- 同一时间，不允许既有写的操作，又有读的操作

<br/>

上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作，iOS中的实现方案用**‌dispatch_barrier_async**：

```

@property (nonatomic, copy) NSString *text;
@property (nonatomic, strong) dispatch_queue_t concurrentQueue;



- (void) testAction {
    
    [self testMethod2];
    
}


//读写锁测试
- (void) testMethod2 {
    NSLog(@"读写锁测试------------------------------------>");
    
    /**
     读写锁场景：
     
     同一时间，只能有1个线程进行写的操作
     
     同一时间，允许有多个线程进行读的操作
     
     同一时间，不允许既有写的操作，又有读的操作
     上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作，iOS中的实现方案有：
     */
    
    self.concurrentQueue = dispatch_queue_create("aaa", DISPATCH_QUEUE_CONCURRENT);
    // 测试代码,模拟多线程情况下的读写
    for (int i = 0; i<10; i++) {
        NSLog(@"🍎 🍎 🍎 写操作1");
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            self.text = [NSString stringWithFormat:@"噼里啪啦--%d",i];
        });
        
    }
    
    for (int i = 0; i<50; i++) {

        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            NSLog(@"读 %@ %@",[self text],[NSThread currentThread]);
        });
        
    }
    
    
    for (int i = 10; i<20; i++) {
        NSLog(@"🍐 🍐 🍐 写操作2");

        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            self.text = [NSString stringWithFormat:@"噼里啪啦--%d",i];
        });
        
    }
}

// 写操作,栅栏函数是不允许并发的,所以"写操作"是单线程进入的,根据log可以看出来
- (void)setText:(NSString *)text {
    
    __weak typeof(self) weakSelf = self;
    NSLog(@"🌰 🌰 🌰 ------》〉写操作");

    dispatch_barrier_sync(self.concurrentQueue, ^{
        __strong typeof(weakSelf) strongSelf = weakSelf;
        strongSelf->_text = text;
        NSLog(@"写操作 %@ %@",text,[NSThread currentThread]);
        // 模拟耗时操作,1个1个执行,没有并发
        sleep(1);
    });
}
// 读操作,这个是可以并发的,log在很快时间打印完
- (NSString *)text {
    
    __block NSString * t = nil ;
    __weak typeof(self) weakSelf = self;
    NSLog(@"🍊 🍊 🍊 读操作1");

    dispatch_sync(self.concurrentQueue, ^{
        __strong typeof(weakSelf) strongSelf = weakSelf;
        NSLog(@"🍍 🍍 🍍 读操作1");

        t = strongSelf->_text;
        // 模拟耗时操作,瞬间执行完,说明是多个线程并发的进入的
        sleep(1);
        
    });
    return t;
    
}


```

打印：

```
2021-06-01 21:23:42.050578+0800 OCTest[49150:1874181] 读写锁测试------------------------------------>
2021-06-01 21:23:42.050872+0800 OCTest[49150:1874181] 🍎 🍎 🍎 写操作1
2021-06-01 21:23:42.051131+0800 OCTest[49150:1874181] 🍎 🍎 🍎 写操作1
2021-06-01 21:23:42.051168+0800 OCTest[49150:1875102] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.051374+0800 OCTest[49150:1874181] 🍎 🍎 🍎 写操作1
2021-06-01 21:23:42.051447+0800 OCTest[49150:1875240] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.051493+0800 OCTest[49150:1875102] 写操作 噼里啪啦--0 <NSThread: 0x600002005680>{number = 4, name = (null)}
2021-06-01 21:23:42.051602+0800 OCTest[49150:1874181] 🍎 🍎 🍎 写操作1
2021-06-01 21:23:42.051671+0800 OCTest[49150:1875241] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.052223+0800 OCTest[49150:1874181] 🍎 🍎 🍎 写操作1
2021-06-01 21:23:42.052290+0800 OCTest[49150:1875242] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.052553+0800 OCTest[49150:1874181] 🍎 🍎 🍎 写操作1
2021-06-01 21:23:42.052642+0800 OCTest[49150:1875243] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.052926+0800 OCTest[49150:1874181] 🍎 🍎 🍎 写操作1
2021-06-01 21:23:42.052992+0800 OCTest[49150:1875244] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.053249+0800 OCTest[49150:1874181] 🍎 🍎 🍎 写操作1
2021-06-01 21:23:42.053349+0800 OCTest[49150:1875245] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.059369+0800 OCTest[49150:1874181] 🍎 🍎 🍎 写操作1
2021-06-01 21:23:42.059459+0800 OCTest[49150:1875246] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.059518+0800 OCTest[49150:1874181] 🍎 🍎 🍎 写操作1
2021-06-01 21:23:42.059570+0800 OCTest[49150:1875247] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.059764+0800 OCTest[49150:1874181] 🍐 🍐 🍐 写操作2
2021-06-01 21:23:42.059770+0800 OCTest[49150:1875248] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.059808+0800 OCTest[49150:1875249] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.059899+0800 OCTest[49150:1874181] 🍐 🍐 🍐 写操作2
2021-06-01 21:23:42.059919+0800 OCTest[49150:1875251] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.059938+0800 OCTest[49150:1875250] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.059977+0800 OCTest[49150:1875252] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060023+0800 OCTest[49150:1875253] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060034+0800 OCTest[49150:1875254] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060085+0800 OCTest[49150:1874181] 🍐 🍐 🍐 写操作2
2021-06-01 21:23:42.060098+0800 OCTest[49150:1875255] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060133+0800 OCTest[49150:1875256] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060181+0800 OCTest[49150:1875257] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060220+0800 OCTest[49150:1875258] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060282+0800 OCTest[49150:1875259] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060295+0800 OCTest[49150:1875260] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060346+0800 OCTest[49150:1875261] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060403+0800 OCTest[49150:1874181] 🍐 🍐 🍐 写操作2
2021-06-01 21:23:42.060405+0800 OCTest[49150:1875263] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060413+0800 OCTest[49150:1875262] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060456+0800 OCTest[49150:1875264] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060489+0800 OCTest[49150:1875265] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060584+0800 OCTest[49150:1875266] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060644+0800 OCTest[49150:1875267] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060683+0800 OCTest[49150:1874181] 🍐 🍐 🍐 写操作2
2021-06-01 21:23:42.060689+0800 OCTest[49150:1875268] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060719+0800 OCTest[49150:1875269] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060760+0800 OCTest[49150:1875270] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060799+0800 OCTest[49150:1875271] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060826+0800 OCTest[49150:1875272] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060879+0800 OCTest[49150:1875273] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060910+0800 OCTest[49150:1875274] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.060941+0800 OCTest[49150:1874181] 🍐 🍐 🍐 写操作2
2021-06-01 21:23:42.060959+0800 OCTest[49150:1875275] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061002+0800 OCTest[49150:1875276] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061048+0800 OCTest[49150:1875277] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061077+0800 OCTest[49150:1875278] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061115+0800 OCTest[49150:1875279] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061187+0800 OCTest[49150:1874181] 🍐 🍐 🍐 写操作2
2021-06-01 21:23:42.061221+0800 OCTest[49150:1875281] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061320+0800 OCTest[49150:1875282] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061327+0800 OCTest[49150:1875283] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061156+0800 OCTest[49150:1875280] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061346+0800 OCTest[49150:1875284] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061405+0800 OCTest[49150:1875285] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061434+0800 OCTest[49150:1875286] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061474+0800 OCTest[49150:1875287] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061510+0800 OCTest[49150:1875288] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061574+0800 OCTest[49150:1875290] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061547+0800 OCTest[49150:1875289] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061636+0800 OCTest[49150:1875291] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061671+0800 OCTest[49150:1875292] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061755+0800 OCTest[49150:1875293] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061819+0800 OCTest[49150:1875294] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061645+0800 OCTest[49150:1874181] 🍐 🍐 🍐 写操作2
2021-06-01 21:23:42.061802+0800 OCTest[49150:1875295] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061935+0800 OCTest[49150:1875297] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.061899+0800 OCTest[49150:1875296] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.062126+0800 OCTest[49150:1875298] 🍊 🍊 🍊 读操作1
2021-06-01 21:23:42.062160+0800 OCTest[49150:1875299] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.062192+0800 OCTest[49150:1874181] 🍐 🍐 🍐 写操作2
2021-06-01 21:23:42.062200+0800 OCTest[49150:1875300] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.062247+0800 OCTest[49150:1875301] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.062274+0800 OCTest[49150:1875302] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:42.062444+0800 OCTest[49150:1874181] 🍐 🍐 🍐 写操作2
2021-06-01 21:23:43.055129+0800 OCTest[49150:1875102] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:43.055269+0800 OCTest[49150:1875240] 写操作 噼里啪啦--1 <NSThread: 0x600002042a80>{number = 7, name = (null)}
2021-06-01 21:23:44.059101+0800 OCTest[49150:1875240] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:44.059136+0800 OCTest[49150:1875244] 写操作 噼里啪啦--5 <NSThread: 0x600002000e80>{number = 8, name = (null)}
2021-06-01 21:23:45.062779+0800 OCTest[49150:1875244] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:45.062808+0800 OCTest[49150:1875243] 写操作 噼里啪啦--4 <NSThread: 0x60000200aa40>{number = 9, name = (null)}
2021-06-01 21:23:46.066867+0800 OCTest[49150:1875243] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:46.066941+0800 OCTest[49150:1875241] 写操作 噼里啪啦--2 <NSThread: 0x60000201ba80>{number = 10, name = (null)}
2021-06-01 21:23:47.072205+0800 OCTest[49150:1875241] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:47.072235+0800 OCTest[49150:1875242] 写操作 噼里啪啦--3 <NSThread: 0x600002052400>{number = 11, name = (null)}
2021-06-01 21:23:48.075550+0800 OCTest[49150:1875242] 🌰 🌰 🌰 ------》〉写操作
2021-06-01 21:23:48.075615+0800 OCTest[49150:1875245] 写操作 噼里啪啦--6 <NSThread: 0x60000200d840>{number = 12, name = (null)}
2021-06-01 21:23:49.079437+0800 OCTest[49150:1875246] 写操作 噼里啪啦--7 <NSThread: 0x60000200ad40>{number = 13, name = (null)}
2021-06-01 21:23:50.083392+0800 OCTest[49150:1875247] 写操作 噼里啪啦--8 <NSThread: 0x60000200d840>{number = 14, name = (null)}
2021-06-01 21:23:51.084361+0800 OCTest[49150:1875268] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:52.085362+0800 OCTest[49150:1875268] 读 噼里啪啦--8 <NSThread: 0x60000200ab40>{number = 15, name = (null)}
2021-06-01 21:23:52.085422+0800 OCTest[49150:1875301] 写操作 噼里啪啦--12 <NSThread: 0x60000200d040>{number = 16, name = (null)}
2021-06-01 21:23:53.086301+0800 OCTest[49150:1875302] 写操作 噼里啪啦--13 <NSThread: 0x600002051e00>{number = 17, name = (null)}
2021-06-01 21:23:54.087017+0800 OCTest[49150:1875253] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:54.087032+0800 OCTest[49150:1875251] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:55.092658+0800 OCTest[49150:1875251] 读 噼里啪啦--13 <NSThread: 0x6000020533c0>{number = 18, name = (null)}
2021-06-01 21:23:55.092658+0800 OCTest[49150:1875253] 读 噼里啪啦--13 <NSThread: 0x60000200d8c0>{number = 19, name = (null)}
2021-06-01 21:23:55.092684+0800 OCTest[49150:1875248] 写操作 噼里啪啦--9 <NSThread: 0x60000200acc0>{number = 20, name = (null)}
2021-06-01 21:23:56.096441+0800 OCTest[49150:1875276] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:56.096442+0800 OCTest[49150:1875278] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:56.096441+0800 OCTest[49150:1875275] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:56.096438+0800 OCTest[49150:1875249] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:57.101096+0800 OCTest[49150:1875276] 读 噼里啪啦--9 <NSThread: 0x60000207a100>{number = 23, name = (null)}
2021-06-01 21:23:57.101100+0800 OCTest[49150:1875249] 读 噼里啪啦--9 <NSThread: 0x600002043900>{number = 22, name = (null)}
2021-06-01 21:23:57.101108+0800 OCTest[49150:1875278] 读 噼里啪啦--9 <NSThread: 0x60000201b580>{number = 24, name = (null)}
2021-06-01 21:23:57.101100+0800 OCTest[49150:1875275] 读 噼里啪啦--9 <NSThread: 0x60000200acc0>{number = 21, name = (null)}
2021-06-01 21:23:57.101141+0800 OCTest[49150:1875300] 写操作 噼里啪啦--11 <NSThread: 0x60000200d880>{number = 25, name = (null)}
2021-06-01 21:23:58.102176+0800 OCTest[49150:1875299] 写操作 噼里啪啦--10 <NSThread: 0x60000201a540>{number = 26, name = (null)}
2021-06-01 21:23:59.104168+0800 OCTest[49150:1875292] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104179+0800 OCTest[49150:1875274] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104169+0800 OCTest[49150:1875277] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104234+0800 OCTest[49150:1875293] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104235+0800 OCTest[49150:1875294] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104239+0800 OCTest[49150:1875295] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104240+0800 OCTest[49150:1875259] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104251+0800 OCTest[49150:1875298] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104262+0800 OCTest[49150:1875260] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104280+0800 OCTest[49150:1875267] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104294+0800 OCTest[49150:1875258] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104301+0800 OCTest[49150:1875266] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104313+0800 OCTest[49150:1875291] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104171+0800 OCTest[49150:1875261] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104345+0800 OCTest[49150:1875289] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104348+0800 OCTest[49150:1875265] 🍍 🍍 2021-06-01 21:23:59.104423+0800 OCTest[49150:1875257] 🍍 🍍 🍍 读操作1
🍍 读操作1
2021-06-01 21:23:59.104382+0800 OCTest[49150:1875272] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104388+0800 OCTest[49150:1875263] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104427+0800 OCTest[49150:1875262] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104427+0800 OCTest[49150:1875296] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104435+0800 OCTest[49150:1875288] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104464+0800 OCTest[49150:1875264] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104497+0800 OCTest[49150:1875297] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104504+0800 OCTest[49150:1875256] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104507+0800 OCTest[49150:1875255] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104510+0800 OCTest[49150:1875269] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104551+0800 OCTest[49150:1875273] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104569+0800 OCTest[49150:1875250] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104573+0800 OCTest[49150:1875287] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104572+0800 OCTest[49150:1875252] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104584+0800 OCTest[49150:1875270] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104607+0800 OCTest[49150:1875254] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104608+0800 OCTest[49150:1875285] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104619+0800 OCTest[49150:1875286] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104664+0800 OCTest[49150:1875280] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104619+0800 OCTest[49150:1875282] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104675+0800 OCTest[49150:1875271] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104667+0800 OCTest[49150:1875283] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104732+0800 OCTest[49150:1875279] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104683+0800 OCTest[49150:1875281] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104712+0800 OCTest[49150:1875284] 🍍 🍍 🍍 读操作1
2021-06-01 21:23:59.104682+0800 OCTest[49150:1875290] 🍍 🍍 🍍 读操作1
2021-06-01 21:24:00.105580+0800 OCTest[49150:1875293] 读 噼里啪啦--10 <NSThread: 0x6000020075c0>{number = 28, name = (null)}
2021-06-01 21:24:00.105592+0800 OCTest[49150:1875292] 读 噼里啪啦--10 <NSThread: 0x60000201c680>{number = 27, name = (null)}
2021-06-01 21:24:00.105594+0800 OCTest[49150:1875294] 读 噼里啪啦--10 <NSThread: 0x600002053ec0>{number = 29, name = (null)}
2021-06-01 21:24:00.105626+0800 OCTest[49150:1875259] 读 噼里啪啦--10 <NSThread: 0x60000200d8c0>{number = 30, name = (null)}
2021-06-01 21:24:00.105657+0800 OCTest[49150:1875295] 读 噼里啪啦--10 <NSThread: 0x60000201e380>{number = 31, name = (null)}
2021-06-01 21:24:00.105678+0800 OCTest[49150:1875277] 读 噼里啪啦--10 <NSThread: 0x600002078a00>{number = 32, name = (null)}
2021-06-01 21:24:00.105699+0800 OCTest[49150:1875274] 读 噼里啪啦--10 <NSThread: 0x600002000e40>{number = 33, name = (null)}
2021-06-01 21:24:00.106405+0800 OCTest[49150:1875298] 读 噼里啪啦--10 <NSThread: 0x60000201e240>{number = 34, name = (null)}
2021-06-01 21:24:00.106839+0800 OCTest[49150:1875260] 读 噼里啪啦--10 <NSThread: 0x60000200d5c0>{number = 35, name = (null)}
2021-06-01 21:24:00.107150+0800 OCTest[49150:1875258] 读 噼里啪啦--10 <NSThread: 0x60000201aa00>{number = 36, name = (null)}
2021-06-01 21:24:00.107471+0800 OCTest[49150:1875289] 读 噼里啪啦--10 <NSThread: 0x600002007a00>{number = 37, name = (null)}
2021-06-01 21:24:00.107824+0800 OCTest[49150:1875291] 读 噼里啪啦--10 <NSThread: 0x600002007800>{number = 38, name = (null)}
2021-06-01 21:24:00.107992+0800 OCTest[49150:1875261] 读 噼里啪啦--10 <NSThread: 0x60000201abc0>{number = 39, name = (null)}
2021-06-01 21:24:00.108320+0800 OCTest[49150:1875252] 读 噼里啪啦--10 <NSThread: 0x60000201be80>{number = 40, name = (null)}
2021-06-01 21:24:00.108564+0800 OCTest[49150:1875287] 读 噼里啪啦--10 <NSThread: 0x600002007a00>{number = 41, name = (null)}
2021-06-01 21:24:00.109351+0800 OCTest[49150:1875266] 读 噼里啪啦--10 <NSThread: 0x60000200c400>{number = 44, name = (null)}
2021-06-01 21:24:00.109350+0800 OCTest[49150:1875256] 读 噼里啪啦--10 <NSThread: 0x600002000cc0>{number = 42, name = (null)}
2021-06-01 21:24:00.109361+0800 OCTest[49150:1875269] 读 噼里啪啦--10 <NSThread: 0x60000201b340>{number = 43, name = (null)}
2021-06-01 21:24:00.109727+0800 OCTest[49150:1875297] 读 噼里啪啦--10 <NSThread: 0x60000201b0c0>{number = 45, name = (null)}
2021-06-01 21:24:00.110234+0800 OCTest[49150:1875288] 读 噼里啪啦--10 <NSThread: 0x60000200d600>{number = 48, name = (null)}
2021-06-01 21:24:00.109838+0800 OCTest[49150:1875264] 读 噼里啪啦--10 <NSThread: 0x600002007640>{number = 46, name = (null)}
2021-06-01 21:24:00.110236+0800 OCTest[49150:1875296] 读 噼里啪啦--10 <NSThread: 0x60000201bcc0>{number = 47, name = (null)}
2021-06-01 21:24:00.110339+0800 OCTest[49150:1875255] 读 噼里啪啦--10 <NSThread: 0x60000200d780>{number = 49, name = (null)}
2021-06-01 21:24:00.110921+0800 OCTest[49150:1875273] 读 噼里啪啦--10 <NSThread: 0x600002000dc0>{number = 51, name = (null)}
2021-06-01 21:24:00.110915+0800 OCTest[49150:1875250] 读 噼里啪啦--10 <NSThread: 0x600002051fc0>{number = 50, name = (null)}
2021-06-01 21:24:00.110934+0800 OCTest[49150:1875257] 读 噼里啪啦--10 <NSThread: 0x6000020077c0>{number = 52, name = (null)}
2021-06-01 21:24:00.113876+0800 OCTest[49150:1875263] 读 噼里啪啦--10 <NSThread: 0x6000020074c0>{number = 55, name = (null)}
2021-06-01 21:24:00.113849+0800 OCTest[49150:1875265] 读 噼里啪啦--10 <NSThread: 0x600002052940>{number = 54, name = (null)}
2021-06-01 21:24:00.113963+0800 OCTest[49150:1875272] 读 噼里啪啦--10 <NSThread: 0x600002000d40>{number = 57, name = (null)}
2021-06-01 21:24:00.113920+0800 OCTest[49150:1875262] 读 噼里啪啦--10 <NSThread: 0x600002079f40>{number = 56, name = (null)}
2021-06-01 21:24:00.113849+0800 OCTest[49150:1875267] 读 噼里啪啦--10 <NSThread: 0x60000207a6c0>{number = 53, name = (null)}
2021-06-01 21:24:00.119015+0800 OCTest[49150:1875285] 读 噼里啪啦--10 <NSThread: 0x60000201e480>{number = 59, name = (null)}
2021-06-01 21:24:00.119016+0800 OCTest[49150:1875271] 读 噼里啪啦--10 <NSThread: 0x60000200d740>{number = 60, name = (null)}
2021-06-01 21:24:00.119015+0800 OCTest[49150:1875286] 读 噼里啪啦--10 <NSThread: 0x600002051d00>{number = 58, name = (null)}
2021-06-01 21:24:00.119033+0800 OCTest[49150:1875280] 读 噼里啪啦--10 <NSThread: 0x600002079f80>{number = 61, name = (null)}
2021-06-01 21:24:00.119056+0800 OCTest[49150:1875270] 读 噼里啪啦--10 <NSThread: 0x600002001540>{number = 62, name = (null)}
2021-06-01 21:24:00.119073+0800 OCTest[49150:1875282] 读 噼里啪啦--10 <NSThread: 0x60000200d800>{number = 63, name = (null)}
2021-06-01 21:24:00.119088+0800 OCTest[49150:1875254] 读 噼里啪啦--10 <NSThread: 0x60000207a0c0>{number = 64, name = (null)}
2021-06-01 21:24:00.119491+0800 OCTest[49150:1875283] 读 噼里啪啦--10 <NSThread: 0x60000201c6c0>{number = 65, name = (null)}
2021-06-01 21:24:00.119494+0800 OCTest[49150:1875281] 读 噼里啪啦--10 <NSThread: 0x600002000dc0>{number = 66, name = (null)}
2021-06-01 21:24:00.119555+0800 OCTest[49150:1875290] 读 噼里啪啦--10 <NSThread: 0x60000201ad00>{number = 67, name = (null)}
2021-06-01 21:24:00.119707+0800 OCTest[49150:1875279] 读 噼里啪啦--10 <NSThread: 0x600002002040>{number = 68, name = (null)}
2021-06-01 21:24:00.119911+0800 OCTest[49150:1875102] 写操作 噼里啪啦--14 <NSThread: 0x600002005680>{number = 4, name = (null)}
2021-06-01 21:24:00.119914+0800 OCTest[49150:1875284] 读 噼里啪啦--10 <NSThread: 0x60000201b580>{number = 69, name = (null)}
2021-06-01 21:24:01.121618+0800 OCTest[49150:1875240] 写操作 噼里啪啦--15 <NSThread: 0x600002042a80>{number = 7, name = (null)}
2021-06-01 21:24:02.122389+0800 OCTest[49150:1875244] 写操作 噼里啪啦--16 <NSThread: 0x600002000e80>{number = 8, name = (null)}
2021-06-01 21:24:03.124373+0800 OCTest[49150:1875243] 写操作 噼里啪啦--17 <NSThread: 0x60000200aa40>{number = 9, name = (null)}
2021-06-01 21:24:04.125953+0800 OCTest[49150:1875241] 写操作 噼里啪啦--18 <NSThread: 0x60000201ba80>{number = 10, name = (null)}
2021-06-01 21:24:05.131037+0800 OCTest[49150:1875242] 写操作 噼里啪啦--19 <NSThread: 0x600002052400>{number = 11, name = (null)}


```

读写序列图:

![multithread1.png](./../../Pictures/multithread1.png)

根据上面的打印，我们重点关注写的打印：写操作 噼里啪啦--1 和 🍍 字样，其他的都是烟雾弹。我们再结合上面的线程时序图可以看到，一般都是等到栅栏都完成后再执行其他的。所以一般都是先写前10个，再是读，然后接着写。
<br/>

下面贴上一个AFN的实现 , requestHeaderModificationQueue是一个由AFHTTPRequestSerializer创建的并发队列, 使用这个并发队列对一个NSMutableDictionary实现了多读单写的锁.

```
self.requestHeaderModificationQueue = dispatch_queue_create("requestHeaderModificationQueue", DISPATCH_QUEUE_CONCURRENT);

```

![multithread0.png](./../../Pictures/multithread0.png)

<br/><br/><br/>
> <h2 id='pthread_rwlock互斥锁'>pthread_rwlock互斥锁</h2>

**使用pthread_rwlock 互斥锁（会休眠）:**
![multithread2.png](./../../Pictures/multithread2.png)

```objective-c
#import <pthread.h>

@property (assign, nonatomic) pthread_rwlock_t lock;


- (void) testAction {
    
    [self testMethod3];
    
}


//读写互斥锁测试
- (void) testMethod3 {
    // 初始化锁
        pthread_rwlock_init(&_lock, NULL);
        
        dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
        
        for (int i = 0; i < 5; i++) {
            dispatch_async(queue, ^{
                [self read];
            });
            dispatch_async(queue, ^{
                [self write];
            });
        }
}

- (void)read {
    //读锁
    pthread_rwlock_rdlock(&_lock);
    
    sleep(1);
    NSLog(@"🍎 🍎 %s", __func__);
    
    pthread_rwlock_unlock(&_lock);
}

- (void)write
{
    //写锁
    pthread_rwlock_wrlock(&_lock);
    
    sleep(1);
    NSLog(@"🍊 🍊 %s", __func__);
    
    pthread_rwlock_unlock(&_lock);
}
```

打印：

```sh
021-06-01 22:30:57.268204+0800 OCTest[50381:1928202] 🍎 🍎 -[ViewController read]
2021-06-01 22:30:58.272268+0800 OCTest[50381:1928423] 🍊 🍊 -[ViewController write]
2021-06-01 22:30:59.275954+0800 OCTest[50381:1928424] 🍎 🍎 -[ViewController read]
2021-06-01 22:31:00.280702+0800 OCTest[50381:1928425] 🍊 🍊 -[ViewController write]
2021-06-01 22:31:01.283694+0800 OCTest[50381:1928426] 🍎 🍎 -[ViewController read]
2021-06-01 22:31:02.284539+0800 OCTest[50381:1928427] 🍊 🍊 -[ViewController write]
2021-06-01 22:31:03.285518+0800 OCTest[50381:1928428] 🍎 🍎 -[ViewController read]
2021-06-01 22:31:04.286463+0800 OCTest[50381:1928429] 🍊 🍊 -[ViewController write]
2021-06-01 22:31:05.287468+0800 OCTest[50381:1928430] 🍎 🍎 -[ViewController read]
2021-06-01 22:31:06.288403+0800 OCTest[50381:1928431] 🍊 🍊 -[ViewController write]
```

<br/><br/><br/>

***
<br/>

> <h1 id='避免死锁'>避免死锁</h1>

&emsp; 很常见的场景是，同一线程重复获取锁导致的死锁，这种情况可以使用递归锁来处理，pthread_mutex_t使用pthread_mutex_init_recursive()方法初始化就能拥有递归锁的特性。

<br/>
> <h2 id='pthread_mutex_trylock'>pthread_mutex_trylock</h2>

使用pthread_mutex_trylock()等尝试获取锁的方法能有效的避免死锁的情况，在 YYCache 源码中有一段处理就比较精致：

```objective-c
while (!finish) {
        if (pthread_mutex_trylock(&_lock) == 0) {
            ...
            finish = YES;
            ...
            pthread_mutex_unlock(&_lock);
        } else {
            usleep(10 * 1000); //10 ms
        }
    }
```

&emsp; 这段代码除了避免潜在的死锁情况外，还做了一个10ms的挂起操作然后循环尝试，而不是直接让线程空转浪费过多的 CPU 资源。

虽然挂起线程“浪费了”互斥锁的空转期，增加了唤醒线程的资源消耗，降低了锁的性能，但是考虑到 YYCache 此处的业务是修剪内存，并非是对锁性能要求很高的业务，并且修剪的任务量可能比较大，出现线程竞争的几率较大，所以这里放弃线程空转直接挂起线程是一个不错的处理方式。

<br/><br/>
> <h2 id='CPU乱序执行'>CPU乱序执行</h2>
&emsp; CPU 也可能为了提高效率而去交换指令的顺序，导致加锁的代码也不安全，解决这类问题可以使用内存屏障，CPU 越过内存屏障后会刷新寄存器对变量的分配。

OC 实现单例模式的方法：

```objective-c
void
_dispatch_once(dispatch_once_t *predicate,
		DISPATCH_NOESCAPE dispatch_block_t block)
{
	if (DISPATCH_EXPECT(*predicate, ~0l) != ~0l) {
		dispatch_once(predicate, block);
	} else {
		dispatch_compiler_barrier();
	}
	DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~0l);
}
```


&emsp; 其中就能看到内存屏障的宏：#define dispatch_compiler_barrier()  __asm__ __volatile__("" ::: "memory")；还有一个分支预测减少指令跳转的优化宏（减少跳转指令能提高 CPU 流水线执行的效率）：#define DISPATCH_EXPECT(x, v) __builtin_expect((x), (v))。

<br/><br/><br/>

***
<br/>

> <h1 id='NSOperation'>NSOperation</h1>
> <h2 id='操作和操作队列'>操作和操作队列</h2>
- **`操作(Operation)`**
	- 执行操作,换句话说就是你在线程中执行的那段代码。
	- 在 GCD 中是放在 block 中的。在 NSOperation 中，我们使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。
<br/>

- **`操作队列(Operation Queues)`**
	- 这里的队列指操作队列，即用来存放操作的队列。不同于 **GCD 中的调度队列 FIFO（先进先出）的原则**。

	- NSOperationQueue对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的**优先级决定**（优先级是操作对象自身的属性）。

	- NSOperation操作队列通过设置**最大并发操作数（maxConcurrentOperationCount）来控制并发、串行.**GCD是通过**async和sync**来进行并发和串行的。

	- NSOperationQueue 为我们提供了两种不同类型的队列：**主队列和自定义队列**。主队列运行在主线程之上，而自定义队列在后台执行。

<br/><br/>
> <h2 id='NSOperation常用属性和方法'>NSOperation 常用属性和方法</h2>
**a. 取消操作方法**

```
//可取消操作，实质是标记 isCancelled 状态。
- (void)cancel; 
```

<br/>

**b. 判断操作状态方法**

```objective-c
- (BOOL)isFinished; 判断操作是否已经结束。

- (BOOL)isCancelled; 判断操作是否已经标记为取消。

- (BOOL)isExecuting; 判断操作是否正在在运行。

- (BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。
```

<br/>

**c. 操作同步**

```objective-c
- (void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。

- (void)setCompletionBlock:(void (^)(void))block;completionBlock 会在当前操作执行完毕时执行 completionBlock。

- (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。

- (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。

@property (readonly, copy) NSArray<NSOperation *> *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。
```

<br/><br/>
> <h2 id='NSOperationQueue常用属性和方法'>NSOperationQueue常用属性和方法</h2>
**a. 取消/暂停/恢复操作**

```objective-c
- (void)cancelAllOperations; 可以取消队列的所有操作。

- (BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。

- (void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。
```

<br/>

**b. 操作同步**

```objective-c
- (void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕
```

<br/>

**c. 添加/获取操作**

```objective-c
- (void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。

- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束

- (NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。

- (NSUInteger)operationCount; 当前队列中的操作数。
```

<br/>

d. 获取队列  

```objective-c
+ (id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。
+ (id)mainQueue; 获取主队列。
```

<br/>

- **注意：**
	- a. 这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。
	- b. 暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。

<br/><br/>
> <h2 id='属性'>属性</h2>
- 队列优先级
	- 	**`queuePriority`:**

```objective-c
typedef NS_ENUM(NSInteger, NSOperationQueuePriority){
	NSOperationQueuePriorityVeryLow = -8L,
	NSOperationQueuePriorityLow = -4L,
	NSOperationQueuePriorityNormal = 0,
	NSOperationQueuePriorityHigh = 4,
	NSOperationQueuePriorityVeryHigh = 8
}
```

<br/>

- 控制串行执行、并发执行
	- `maxConcurrentOperationCount`：控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。

<br/>

- completionBlock
	completionBlock	可读可写，当 finished 的值更改为 YES 时，将执行该代码块。
	completionBlock通常是一个子线程执行.因此，不应该使用这个块来做刷新UI。
	finished=YES可能因为它被取消或者因为它完成任务而结束；在编写代码块时，应该考虑到这一点。
	completionBlock 类似于GCD的函数  dispatch_block_notify() ，监听 dispatch_block 完成时 dispatch_queue 调用 notification_block
	
<br/><br/>
> <h2 id='NSOperation、NSOperationQueue使用方法'>NSOperation、NSOperationQueue使用方法</h2>
&emsp;  `NSOperation` 需要配合 `NSOperationQueue` 来实现多线程。因为默认情况下，`NSOperation` 单独使用时是系统的同步执行操作，配合 NSOperationQueue 可以实现异步执行。

<br/>

- `NSOperation实现多线程的步骤为：`
	- 创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。
	- 创建队列：创建 NSOperationQueue 对象。
	- 将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。

之后系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。

<br/><br/>

`NSOperation的创建操作:`

&emsp; NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。

①.  使用子类 NSInvocationOperation;

②.  使用子类 NSBlockOperation;

③.  自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作;

&emsp; 在不使用 NSOperationQueue，单独使用 NSOperation 的情况下系统同步执行操作，下面我们学习以下操作的三种创建方式。

<br/><br/>
> <h2 id='创建队列'>创建队列</h2>
NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。

**主队列:凡是添加到主队列中的操作，都会放到主线程中执行。**

```objective-c
// 主队列获取方法
NSOperationQueue *queue = [NSOperationQueue mainQueue];
``` 

<br/>

- 自定义队列（非主队列）
	- a. 添加到这种队列中的操作，就会自动放到子线程中执行。
	- b. 同时包含了：串行、并发功能。

```
// 自定义队列创建方法
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
```

<br/><br/>
> <h2 id='操作加入到队列中'>操作加入到队列中</h2>
上边我们说到 NSOperation 需要配合 NSOperationQueue 来实现多线程。

那么我们需要将创建好的操作加入到队列中去。总共有两种方法：

- **第1种**

```objective-c
- (void)addOperation:(NSOperation *)op;
```

需要先创建操作，再将创建好的操作加入到创建好的队列中去:

```objective-c
//使用 addOperation: 将操作加入到操作队列中
- (void)addOperationToQueue {

    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.创建操作
    // 使用 NSInvocationOperation 创建操作1
    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];

    // 使用 NSInvocationOperation 创建操作2
    NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil];

    // 使用 NSBlockOperation 创建操作3
    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i < 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@"3---%@", [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op3 addExecutionBlock:^{
        for (int i = 0; i < 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@"4---%@", [NSThread currentThread]); // 打印当前线程
        }
    }];

    // 3.使用 addOperation: 添加所有操作到队列中
    [queue addOperation:op1]; // [op1 start]
    [queue addOperation:op2]; // [op2 start]
    [queue addOperation:op3]; // [op3 start]
}





- (void)task1 {
    for (int i = 0; i < 2; i++) {
        [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程
    }
}

- (void)task2 {
    for (int i = 0; i < 2; i++) {
        [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
        NSLog(@"2---%@", [NSThread currentThread]); // 打印当前线程
    }
}
```

**结论：** 使用 NSOperation 子类创建操作，并使用 addOperation: 将操作加入到操作队列后能够开启新线程，进行并发执行。

<br/>

- **第2种**

```objective-c
- (void)addOperationWithBlock:(void (^)(void))block;
```

无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。

```
//使用 addOperationWithBlock: 将操作加入到操作队列中
- (void)addOperationWithBlockToQueue {
    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.使用 addOperationWithBlock: 添加操作到队列中
    [queue addOperationWithBlock:^{
        for (int i = 0; i < 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i < 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@"2---%@", [NSThread currentThread]); // 打印当前线程
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i < 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@"3---%@", [NSThread currentThread]); // 打印当前线程
        }
    }];
}
```

打印结果:

```
<-------------------------NSOperationAndQueue 线程结束-------------------------->
2018-03-31 15:50:11.654251+0800 StruggleSwift[14012:571793] 1---<NSThread: 0x60c00046d380>{number = 3, name = (null)}
2018-03-31 15:50:11.654251+0800 StruggleSwift[14012:572064] 3---<NSThread: 0x60400026dbc0>{number = 5, name = (null)}
2018-03-31 15:50:11.654251+0800 StruggleSwift[14012:570833] 2---<NSThread: 0x60c00046d3c0>{number = 4, name = (null)}
2018-03-31 15:50:13.659610+0800 StruggleSwift[14012:571793] 1---<NSThread: 0x60c00046d380>{number = 3, name = (null)}
2018-03-31 15:50:13.659623+0800 StruggleSwift[14012:570833] 2---<NSThread: 0x60c00046d3c0>{number = 4, name = (null)}
2018-03-31 15:50:13.659623+0800 StruggleSwift[14012:572064] 3---<NSThread: 0x60400026dbc0>{number = 5, name = (null)}
```

**结论：使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。**

<br/><br/>
> <h3 id=' NSInvocationOperation使用'> NSInvocationOperation使用</h3>
 在主线程使用NSInvocationOperation:
 
```objective-c

/**
 * 使用子类 NSInvocationOperation
 */
- (void)useInvocationOperation {
    
    // 1.创建 NSInvocationOperation 对象
    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];
    
    // 2.调用 start 方法开始执行操作
    [op start];
}

/**
 * 任务1
 */
- (void)task1 {
    for (int i = 0; i < 2; i++) {
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);     // 打印当前线程
    }
}

```

输出：

```sh
2019-05-20 14:22:37.467721+0800 YSC-NSOperation-demo[3051:82251] 1---<NSThread: 0x600001d62680>{number = 1, name = main}

2019-05-20 14:22:39.469215+0800 YSC-NSOperation-demo[3051:82251] 1---<NSThread: 0x600001d62680>{number = 1, name = main}
```
&emsp;  在没有使用NSOperationQueue、在主线程中单独使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。

<br/><br/>
> <h3 id='子程使用NSInvocationOperation'>子程使用NSInvocationOperation</h3>

```objective-c
// 在其他线程使用子类 NSInvocationOperation
[NSThread detachNewThreadSelector:@selector(useInvocationOperation) toTarget:self withObject:nil];


/**
 * 使用子类 NSInvocationOperation
 */
- (void)useInvocationOperation {
    
    // 1.创建 NSInvocationOperation 对象
    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];
    
    // 2.调用 start 方法开始执行操作
    [op start];
}

/**
 * 任务1
 */
- (void)task1 {
    for (int i = 0; i < 2; i++) {
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@"1---%@", [NSThread currentThread]);     // 打印当前线程
    }
}
```

输出：

 ```
019-05-20 14:34:38.696854+0800 YSC-NSOperation-demo[3197:87716] 1---<NSThread: 0x600001980600>{number = 3, name = (null)}
 
2019-05-20 14:34:40.701441+0800 YSC-NSOperation-demo[3197:87716] 1---<NSThread: 0x600001980600>{number = 3, name = (null)}
```

&emsp; 在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。

<br/><br/>
> <h2 id='NSBlockOperation'>NSBlockOperation</h2>

```objective-c
//    在当前线程使用 NSBlockOperation
[self useBlockOperation];


/**
 * 使用子类 NSBlockOperation
 */
- (void)useBlockOperation {
    
    // 1.创建 NSBlockOperation 对象
    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i < 2; i++) {
            [NSThread sleepForTimeInterval:2];          // 模拟耗时操作
            NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程
        }
    }];
    
    // 2.调用 start 方法开始执行操作
    [op start];
}
```

输出：

```
2019-05-20 17:02:04.186312+0800 YSC-NSOperation-demo[21633:174028] 1---<NSThread: 0x600001554140>{number = 1, name = main}

2019-05-20 17:02:06.187878+0800 YSC-NSOperation-demo[21633:174028] 1---<NSThread: 0x600001554140>{number = 1, name = main}
```

&emsp;  在没有使用 NSOperationQueue、在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。

&emsp;  与 NSInvocationOperation 使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。

<br/>

```objective-c
//使用 NSBlockOperation 的 AddExecutionBlock: 方法
[self useBlockOperationAddExecutionBlock];


/**
 * 使用子类 NSBlockOperation
 * 调用方法 AddExecutionBlock:
 */
- (void)useBlockOperationAddExecutionBlock {
    
    // 1.创建 NSBlockOperation 对象
    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i < 2; i++) {
            [NSThread sleepForTimeInterval:2];          // 模拟耗时操作
            NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程
        }
    }];
    
    // 2.添加额外的操作
    [op addExecutionBlock:^{
        for (int i = 0; i < 2; i++) {
            [NSThread sleepForTimeInterval:2];          // 模拟耗时操作
            NSLog(@"2---%@", [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i < 2; i++) {
            [NSThread sleepForTimeInterval:2];          // 模拟耗时操作
            NSLog(@"3---%@", [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i < 2; i++) {
            [NSThread sleepForTimeInterval:2];          // 模拟耗时操作
            NSLog(@"4---%@", [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i < 2; i++) {
            [NSThread sleepForTimeInterval:2];          // 模拟耗时操作
            NSLog(@"5---%@", [NSThread currentThread]); // 打印当前线程
        }
    }];
    // 3.调用 start 方法开始执行操作
    [op start];
}

```

输出：

```
2019-05-20 17:18:39.602123+0800 YSC-NSOperation-demo[22041:183103] 3---<NSThread: 0x60000138af00>{number = 1, name = main}

2019-05-20 17:18:39.602129+0800 YSC-NSOperation-demo[22041:183155] 1---<NSThread: 0x6000013d0140>{number = 4, name = (null)}

2019-05-20 17:18:39.602128+0800 YSC-NSOperation-demo[22041:183154] 2---<NSThread: 0x6000013d9440>{number = 5, name = (null)}

2019-05-20 17:18:39.602130+0800 YSC-NSOperation-demo[22041:183162] 4---<NSThread: 0x6000013d4700>{number = 3, name = (null)}

2019-05-20 17:18:41.602619+0800 YSC-NSOperation-demo[22041:183155] 1---<NSThread: 0x6000013d0140>{number = 4, name = (null)}

2019-05-20 17:18:41.602619+0800 YSC-NSOperation-demo[22041:183103] 3---<NSThread: 0x60000138af00>{number = 1, name = main}

2019-05-20 17:18:41.602619+0800 YSC-NSOperation-demo[22041:183154] 2---<NSThread: 0x6000013d9440>{number = 5, name = (null)}

2019-05-20 17:18:41.602619+0800 YSC-NSOperation-demo[22041:183162] 4---<NSThread: 0x6000013d4700>{number = 3, name = (null)}

2019-05-20 17:18:43.603699+0800 YSC-NSOperation-demo[22041:183162] 5---<NSThread: 0x6000013d4700>{number = 3, name = (null)}

2019-05-20 17:18:45.604132+0800 YSC-NSOperation-demo[22041:183162] 5---<NSThread: 0x6000013d4700>{number = 3, name = (null)}

```


&emsp;  NSBlockOperation 还提供了一个方法 addExecutionBlock:，通过`addExecutionBlock: `就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。

&emsp; 如果添加的操作多的话，blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到 blockOperationWithBlock: 中的操作一定会在当前线程中执行。（可以使用 addExecutionBlock: 多添加几个操作试试）。

&emsp;  使用子类 NSBlockOperation，并调用方法 AddExecutionBlock: 的情况下，blockOperationWithBlock:方法中的操作 和 addExecutionBlock: 中的操作是在不同的线程中异步执行的。

&emsp;  而且，这次执行结果中 blockOperationWithBlock:方法中的操作也不是在当前线程（主线程）中执行的。从而印证了blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行。

&emsp;  一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。

<br/><br/>
> <h2 id='自定义继承自NSOperation子类'>自定义继承自NSOperation子类</h2>

&emsp; 如果使用子类 NSInvocationOperation、NSBlockOperation 不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 main 或者 start 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性 isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。

```objective-c
#import <Foundation/Foundation.h>

@interface SSOperation : NSOperation

@end

#import "SSOperation.h"

@implementation SSOperation

- (void)main {
    if (!self.isCancelled) {
        for (int i = 0; i < 2; i++) {
            [NSThread sleepForTimeInterval:2];
            NSLog(@"1---%@", [NSThread currentThread]);
        }
    }
}

@end



//使用自定义继承自 NSOperation 的子类
- (void)useCustomOperation {
    // 1.创建 YSCOperation 对象
    SSOperation *op = [[SSOperation alloc] init];
    // 2.调用 start 方法开始执行操作
    [op start];
}
```

打印结果：

```
2018-03-31 15:28:51.454084+0800 StruggleSwift[13256:546120] 1---<NSThread: 0x6000000696c0>{number = 1, name = main}
2018-03-31 15:28:56.701260+0800 StruggleSwift[13256:546120] 1---<NSThread: 0x6000000696c0>{number = 1, name = main}
<-------------------------NSOperationAndQueue 线程结束-------------------------->
```

**结论:在没有使用 NSOperationQueue、在主线程单独使用自定义继承自 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。**

<br/><br/>
> <h2 id='线程安全'>线程安全</h2>
从多个线程中使用一个NSOperationQueue对象是安全的，无需创建额外的锁来同步对该对象的访问。

操作队列使用调度框架来启动其操作的执行。因此，操作总是在单独的线程上执行，而不管它们是被指定为同步的还是异步的。

<br/>

```objective-c
NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(taskOne) object: nil];

- (void) taskOne {
            for();
}

NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{

}];

NSOperationQueue *operation = [[NSOperationQueue alloc] init];

[operation addOperation: op1];
[operation addOperation: op2];

```

<br/>

**`- (void) addOperationWithBlock:(void (^)(void))block {}`**

```objective-c
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperationWithBlock:^{
      
}];
```

<br/><br/>
> <h2 id='常驻线程'>常驻线程</h2>

&emsp; 在 AFNetworking 2.0 中，把每个请求都封装成了单独的 NSOperationQueue，再由 NSOperationQueue 根据当前的 CPU 数量和系统负载来控制并发。那么，为什么 AFNetworking 2.0 没有为每个请求创建一个线程，而只是创建了一个队列，用来接收 NSOperationQueue 的回调呢？

&emsp; FMDB 只通过 FMDatabaseQueue 开启了一个线程队列，来串行地操作数据库。这又是为什么呢？

<br/>
&emsp; 这大概就是因为多线程技术有坑。特别是 UIKit 干脆就做成了线程不安全，只能在主线程上操作。

&emsp; 而写 UIKit、AFNetworking、FMDB 这些库的“大神”们，并不是解决不了多线程技术可能会带来的问题，而相反正是因为他们非常清楚这些可能存在的问题，所以为避免使用者滥用多线程，亦或是出于性能考虑，而选择了使用单一线程来保证这些基础库的稳定可用。

&emsp; 举一个在开发中可能遇到的一个例子：以照片处理为例，当选择一张照片后，你希望能够看到不同滤镜处理后的效果。如果这些效果图都是在一个队列里串行处理的话，那么你就得等着这些滤镜一个一个地来处理。这么做的话，不仅会影响用户体验，也没能充分利用硬件资源，可以说是把高端手机当作低端机来用了。换句话说就是，用户花大价钱升级了手机硬件，操作 App 的体验却没有得到提升。

&emsp; 所以，我们不能因为多线程技术有坑就不去用，正确的方法应该是更多地去了解多线程会有哪些问题，如果我们能够事先预见到那些问题的话，那么避免这些问题的发生也就不在话下了。

&emsp; 接下来，我们就一起来看看多线程技术常见的两个大坑，常驻线程和并发问题，分别是从何而来，以及如何避免吧。

<br/>

&emsp; 常驻线程，指的就是那些不会停止，一直存在于内存中的线程。在 AFNetworking 2.0 专门创建了一个线程来接收 NSOperationQueue 的回调，这个线程其实就是一个常驻线程。接下来，我们就看看常驻线程这个问题是如何引起的，以及是否有对应的解决方案。

在AFNetworking 2.0 创建常驻线程的代码，来看一下这个线程是怎么创建的：

```objective-c
+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        // 先用 NSThread 创建了一个线程
        [[NSThread currentThread] setName:@"AFNetworking"];
        // 使用 run 方法添加 runloop
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}
```

AFNetworking 2.0 先用 NSThread 创建了一个线程，并使用 NSRunLoop 的 run 方法给这个新线程添加了一个 runloop。

<br/>

通过 NSRunLoop 添加 runloop 的方法有三个：
- run 方法。通过 run 方法添加的 runloop ，会不断地重复调用 runMode:beforeDate: 方法，来保证自己不会停止。
- runUntilDate: 和 runMode:beforeDate 方法。这两个方法添加的 runloop，可以通过指定时间来停止 runloop。

但是若是过多的创建常驻线程，不但不能提高 CPU 的利用率，反而会降低程序的执行效率。常驻线程是很耗费资源的。

<br/>

&emsp; 既然常线程是个坑，那为什么 **AFNetworking 2.0 库还要这么做呢？**

&emsp; 其实，这个问题的根源在于 AFNetworking 2.0 使用的是 NSURLConnection，而 NSURLConnection 的设计上存在些缺陷。接下来，我和你说说它的设计上有哪些缺陷，了解了这些缺陷后你也就能够理解当时 AFNetworking 2.0 为什么明知常驻线程有坑，还是使用了常驻线程。这样，你以后再碰到类似的情况时，也可以跟 AFNetworking 2.0 一样使用常线程去解决问题，只要不滥用常驻线程就可以了。

&emsp; NSURLConnection 发起请求后，所在的线程需要一直存活，以等待接收 NSURLConnectionDelegate 回调方法。但是，网络返回的时间不确定，所以这个线程就需要一直常驻在内存中。既然这样，AFNetworking 2.0 为什么没有在主线程上完成这个工作，而一定要新创建一个线程来做呢？


&emsp; 这是因为主线程还要处理大量的 UI 和交互工作，为了减少对主线程的影响，所以 AFNetworking 2.0 就新建了一个常驻线程，用来处理所有的请求和回调。AFNetworking 2.0 的线程设计如下图所示：

![ios_oc1_21.webp](./../../Pictures/ios_oc1_21.webp)

&emsp; 通过上面的分析我们可以知道，如果不是因为 NSURLConnection 的请求必须要有一个一直存活的线程来接收回调，那么 AFNetworking 2.0 就不用创建一个常驻线程出来了。虽然说，在一个 App 里网络请求这个动作的占比很高，但也有很多不需要网络的场景，所以线程一直常驻在内存中，也是不合理的。

<br/><br/>
&emsp; AFNetworking 在 3.0 版本时，使用苹果公司新推出的 NSURLSession 替换了 NSURLConnection，从而避免了常驻线程这个坑。NSURLSession 可以指定回调 NSOperationQueue，这样请求就不需要让线程一直常驻在内存里去等待回调了。实现代码如下：

```objective-c
self.operationQueue = [[NSOperationQueue alloc] init];
self.operationQueue.maxConcurrentOperationCount = 1;
self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];
```

&emsp; 从上面的代码可以看出，NSURLSession 发起的请求，可以指定回调的 delegateQueue，不再需要在当前线程进行代理方法的回调。所以说，NSURLSession 解决了 NSURLConnection 的线程回调问题。

<br/>

&emsp; 如果你需要确实需要保活线程一段时间的话，可以选择使用 NSRunLoop 的另外两个方法 runUntilDate: 和 runMode:beforeDate，来指定线程的保活时长。让线程存活时间可预期，总比让线程常驻，至少在硬件资源利用率这点上要更加合理。

或者，你还可以使用 CFRunLoopRef 的 CFRunLoopRun 和 CFRunLoopStop 方法来完成 runloop 的开启和停止，达到将线程保活一段时间的目的。

<br/><br/>
> <h2 id='依赖'>依赖</h2>
- **操作依赖:**
	- `- (void) addDependency:(NSOperation *)op`  :添加依赖，使当前操作依赖于操作 op 的完成;
	- `- (void) removeDependency:(NSOperation *)op`  :移除依赖，取消当前操作对操作 op 的依赖;
	- `@property(readonly, copy) NSArray<NSOperation *> *dependencies;` :  在当前操作开始执行之前完成执行的所有操作对象数组.

```objective-c
{
    // 创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
 
    // 任务1
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        [NSData dataWithContentsOfURL:[NSURL URLWithString:@"https://img-blog.csdn.net/20180421152137506"]];
        NSLog(@"任务1 完成，线程：%@", [NSThread currentThread]);
    }];
 
    // 任务2
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        [NSData dataWithContentsOfURL:[NSURL URLWithString:@"https://img-blog.csdn.net/20170112145924755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGVyb193cWI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"]];
        NSLog(@"任务2 完成，线程：%@", [NSThread currentThread]);
    }];
 
    // 添加操作依赖，注意不能循环依赖
    [op1 addDependency:op2];
 
    op1.completionBlock = ^{
        NSLog(@"全部完成，线程：%@", [NSThread currentThread]);
    };
 
    // 添加操作到队列
    [queue addOperation:op1];
    [queue addOperation:op2];
}


```

输出结果：

```
AsyTaskTest[6009:309365] 任务2 完成，线程：<NSThread: 0x600000277c80>{number = 3, name = (null)}

AsyTaskTest[6009:309362] 任务1 完成，线程：<NSThread: 0x60400046c0c0>{number = 4, name = (null)}

AsyTaskTest[6009:309364] 全部完成，线程：<NSThread: 0x600000277d40>{number = 5, name = (null)}


```


<br/><br/>
> <h2 id='多任务(任务是异步)'>多任务(任务是异步)</h2>
若是直接使用上述的线程组来执行，可能会出问题，如下问题的模拟：

```objective-c
{
    NSURLSession *session = [NSURLSession sharedSession];
 
    // 创建队列组
    dispatch_group_t group =  dispatch_group_create();
    // 创建并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
 
    // 任务1
    dispatch_group_async(group, queue, ^{
        NSURLSessionDataTask *task1 = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.apple.com/105/media/us/imac-pro/2018/d0b63f9b_f0de_4dea_a993_62b4cb35ca96/hero/large.mp4"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            NSLog(@"任务1 完成，线程：%@", [NSThread currentThread]);
        }];
        [task1 resume];
    });
 
    // 任务2
    dispatch_group_async(group, queue, ^{
        NSURLSessionDataTask *task2 = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.apple.com/105/media/us/imac-pro/2018/d0b63f9b_f0de_4dea_a993_62b4cb35ca96/thumbnails/erin-sarofsky/large.mp4"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            NSLog(@"任务2 完成，线程：%@", [NSThread currentThread]);
        }];
        [task2 resume];
    });
 
    // 全部完成
    dispatch_group_notify(group, queue, ^{
        dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@"全部完成，线程：%@", [NSThread currentThread]);
        });
    });
}
 
! 输出结果：

AsyTaskTest[6048:310326] 全部完成，线程：<NSThread: 0x60000007f480>{number = 1, name = main}

AsyTaskTest[6048:310361] 任务2 完成，线程：<NSThread: 0x604000468a80>{number = 3, name = (null)}

AsyTaskTest[6048:310364] 任务1 完成，线程：<NSThread: 0x60400046a900>{number = 4, name = (null)}

```

- 通过dispatch_group_enter、dispatch_group_leave解决异步问题：

```
{
    NSURLSession *session = [NSURLSession sharedSession];
 
    // 创建队列组
    dispatch_group_t group = dispatch_group_create();
 
    // 任务1
    dispatch_group_enter(group);
    NSURLSessionDataTask *task1 = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.apple.com/105/media/us/imac-pro/2018/d0b63f9b_f0de_4dea_a993_62b4cb35ca96/hero/large.mp4"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        NSLog(@"任务1 完成，线程：%@", [NSThread currentThread]);
        dispatch_group_leave(group);
    }];
    [task1 resume];
 
    // 任务2
    dispatch_group_enter(group);
    NSURLSessionDataTask *task2 = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.apple.com/105/media/us/imac-pro/2018/d0b63f9b_f0de_4dea_a993_62b4cb35ca96/thumbnails/erin-sarofsky/large.mp4"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        NSLog(@"任务2 完成，线程：%@", [NSThread currentThread]);
        dispatch_group_leave(group);
    }];
    [task2 resume];
 
    // 全部完成
    dispatch_group_notify(group, dispatch_get_main_queue(), ^(){
        NSLog(@"全部完成，线程：%@", [NSThread currentThread]);
    });

    /*或者这样做
    dispatch_group_wait(taskGroup, DISPATCH_TIME_FOREVER);

        dispatch_async(dispatch_get_main_queue(), ^{

        //执行mainTask

    });
    */
}

```
 
输出结果：

```
AsyTaskTest[6102:311543] 任务2 完成，线程：<NSThread: 0x60400046bd00>{number = 3, name = (null)}

AsyTaskTest[6102:311539] 任务1 完成，线程：<NSThread: 0x60400046c700>{number = 4, name = (null)}

AsyTaskTest[6102:311509] 全部完成，线程：<NSThread: 0x60400007cdc0>{number = 1, name = main}

```

- 使用信号量+线程组来处理

```

{
    // 初始化信号量
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
 
    NSURLSession *session = [NSURLSession sharedSession];
 
    // 创建队列组
    dispatch_group_t group =  dispatch_group_create();
    // 创建并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
 
    // 任务1
    dispatch_group_async(group, queue, ^{
        NSURLSessionDataTask *task1 = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.apple.com/105/media/us/imac-pro/2018/d0b63f9b_f0de_4dea_a993_62b4cb35ca96/hero/large.mp4"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            NSLog(@"任务1 完成，线程：%@", [NSThread currentThread]);
            // 发送信号，使信号量+1
            dispatch_semaphore_signal(semaphore);
        }];
        [task1 resume];
    });
    // 信号量等于0时会一直等待，大于0时正常执行，并让信号量-1
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
 
    // 任务2
    dispatch_group_async(group, queue, ^{
        NSURLSessionDataTask *task2 = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.apple.com/105/media/us/imac-pro/2018/d0b63f9b_f0de_4dea_a993_62b4cb35ca96/thumbnails/erin-sarofsky/large.mp4"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            NSLog(@"任务2 完成，线程：%@", [NSThread currentThread]);
            dispatch_semaphore_signal(semaphore);
        }];
        [task2 resume];
    });
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
 
    // 全部完成
    dispatch_async(dispatch_get_main_queue(), ^{
        NSLog(@"全部完成，线程：%@", [NSThread currentThread]);
    });
}

```
 
输出结果：

```
AsyTaskTest[6149:312567] 任务1 完成，线程：<NSThread: 0x600000468040>{number = 3, name = (null)}

AsyTaskTest[6149:312567] 任务2 完成，线程：<NSThread: 0x600000468040>{number = 3, name = (null)}

AsyTaskTest[6149:312507] 全部完成，线程：<NSThread: 0x60000007d680>{number = 1, name = main}
 
```

<br/><br/>

***
<br/>

> <h2 id='内存问题'>内存问题</h2>

&emsp; 创建线程的过程，需要用到物理内存，CPU 也会消耗时间。而且，新建一个线程，系统还需要为这个进程空间分配一定的内存作为线程堆栈。堆栈大小是 4KB 的倍数。在 iOS 开发中，主线程堆栈大小是 1MB，新创建的子线程堆栈大小是 512KB。

&emsp; 除了内存开销外，线程创建得多了，CPU 在切换线程上下文时，还会更新寄存器，更新寄存器的时候需要寻址，而寻址的过程还会有较大的 CPU 消耗。

&emsp; 所以，线程过多时内存和 CPU 都会有大量的消耗，从而导致 App 整体性能降低，使得用户体验变成差。CPU 和内存的使用超出系统限制时，甚至会造成系统强杀。这种情况对用户和 App 的伤害就更大了。