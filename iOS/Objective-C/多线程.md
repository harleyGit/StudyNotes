> <h2 id=''></h2>
- [GCD](#GCD)
	- [dispatch_once](#dispatch_once)
		- [原理](#原理)
	- [并发](#并发)
	- [线程组和依赖](#线程组和依赖)
		- 	[线程组处理](#线程组处理)
- [**锁**](#锁)
	- [OSSpinLock](#OSSpinLock)
	- [dispatch_semaphore](#dispatch_semaphore)
- [**NSOperation**](#NSOperation)
	- [常驻线程](#常驻线程)
	- 	[依赖](#依赖)
	- [	多任务(任务是异步)](#多任务(任务是异步))
	- [并发](#并发)
- [**内存问题**](#内存问题)
- **资料**
	- [GCD](https://www.cnblogs.com/EchoHG/p/8609685.html)
	- [dispatch_once的坑及注意点](https://juejin.cn/post/6844903558224035848)


<br/>
<br/>

***
<br/>
<br/>


><h1 id='GCD'>GCD</h1>

<br/>


![GCD](./../../Pictures/ios_oc105.png)

<br/>

![GCD分类](./../../Pictures/ios_oc1_30.webp)


<br/>

><h2 id='dispatch_once'>dispatch_once</h2>

介绍:dispatch_once能保证任务只会被执行一次，即使同时多线程调用也是线程安全的。常用于创建单例、swizzeld method等功能


<br/>

**使用**

```
static dispatch_once_t onceToken;
dispatch_once(&once_token, ^{
	//创建单例、method swizzled或其他任务
})
```



<br/>
<br/>

> <h3 id='原理'>原理</h3>

```
//调用dispatch_once_f来处理
void dispatch_once(dispatch_once_t *val, dispatch_block_t block) {
    dispatch_once_f(val, block, _dispatch_Block_invoke(block));
}
```

dispatch_once封装调用了dispatch_once_f函数，其中通过_dispatch_Block_invoke来执行block任务，它的定义如下：

```
//invoke是指触发block的具体实现，感兴趣的可以看一下Block_layout的结构体
#define _dispatch_Block_invoke(bb) \
        ((dispatch_function_t)((struct Block_layout *)bb)->invoke)
```

接着看一下具体的实现函数dispatch_once_f：


```
void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func) {
	// volatileg关键字编辑的变量vval，告诉编译器此指针指向的值随时可能被其他线程改变，从而使得编译器不对此指针进行代码编译优化。
	// 指针的最大的作用就是间接的改变变量的值
    struct _dispatch_once_waiter_s * volatile *vval =
            (struct _dispatch_once_waiter_s**)val;
    
    // 初始化一个结构体
    struct _dispatch_once_waiter_s dow = { NULL, 0 };
    
    // 声明辅助变量
    struct _dispatch_once_waiter_s *tail, *tmp;
    // 声明信号变量
    _dispatch_thread_semaphore_t sema;

	// 内置函数 原子比较交换函数 __sync_bool_compare_and_swap
	// 判断vval与NULL是否相等，如果相等就返回YES，并将&dow的值赋给vval
	// 当dispatch_once第一次执行时，predicate也即val为0,地址并不为NULL，但是将0转成链表的时候vval为NULL，那么此“原子比较交换函数”将返回YES并将vval指向值赋值为&dow，即为“等待中”
	//_dispatch_client_callout其内部做了一些判定，但实际上是调用了func而已。到此，block中的用户代码执行完毕。
	// #1
    if (dispatch_atomic_cmpxchg(vval, NULL, &dow, acquire)) {
		    dispatch_atomic_acquire_barrier();//这是一个空的宏函数，大概是注释的作用吧

		// 其实质是执行block
        _dispatch_client_callout(ctxt, func);

        // cpuid指令等待，使得其他线程的【读取到未初始化值的】预执行能被判定为猜测未命中，从而使得这些线程能够进入dispatch_once_f里的另一个分支从而进行等待
        dispatch_atomic_maximally_synchronizing_barrier();
        
        dispatch_atomic_release_barrier(); //这是一个空的宏函数，大概是注释的作用吧
    
		// dispatch_atomic_xchg 其将第二个参数的值赋给第一个参数（解引用指针），然后返回第一个参数被赋值前的解引用值：
		// vval = &dow;
		// old = vval;
		// vval = DISPATCH_ONCE_DONE;// 置block完成标记，是置成NULL吗
		// tmp = old;
        tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE, relaxed);
        tail = &dow;
        
        // tmp = 旧的vval = dow
		// vval = dow;
		// 接下来是对信号量链的处理：
		// 1.在block执行过程中，没有其他线程进入本函数来等待，则vval指向值保持为&dow，即tmp被赋值为&dow，即下方while循环不会被执行，此分支结束。
		// 2.在block执行过程中，有其他线程进入本函数来等待进入另一个分支，那么会构造一个信号量链表（vval指向值变为信号量链的头部，链表的尾部为&dow），此时就会当前分支进入while循环，在此while循环中，遍历链表，逐个signal每个信号量，然后结束循环。
        while (tail != tmp) {
            while (!tmp->dow_next) {
		        // 此句是为了提示cpu减少额外处理，提升性能，节省电力。
                dispatch_hardware_pause();
            }
            sema = tmp->dow_sema;
            tmp = (struct _dispatch_once_waiter_s*)tmp->dow_next;
            _dispatch_thread_semaphore_signal(sema);
        }
    } else {
	    // #2
	    // 当执行block分支#1未完成，且有线程再进入本函数时，将进入线程等待分支：
	    // 先调用_dispatch_get_thread_semaphore创建一个信号量，此信号量被赋值给dow.dow_sema。
	    // 然后进入一个无限for循环，假如发现vval的指向值已经为DISPATCH_ONCE_DONE，即“完成”，则直接break，然后调用_dispatch_put_thread_semaphore函数销毁信号量并退出函数
	    // _dispatch_get_thread_semaphore内部使用的是“有即取用，无即创建”策略来获取信号量。
        dow.dow_sema = _dispatch_get_thread_semaphore();
        tmp = *vval;
        
        // 然后进入一个无限for循环
        for (;;) {
        tmp = *vval;
        // 假如发现vval的指向值已经为DISPATCH_ONCE_DONE，即“完成”，则直接break
        // 然后调用_dispatch_put_thread_semaphore函数销毁信号量并退出函数。
        if (tmp == DISPATCH_ONCE_DONE) {
            break;
        }
        dispatch_atomic_store_barrier();// 注释作用
        
        /*
         假如vval的解引用值并非DISPATCH_ONCE_DONE，则进行一个“原子比较并交换”操作（此操作可以避免两个等待线程同时操作链表带来的问题）
         假如此时vval指向值已不再是tmp（这种情况发生在多个线程同时进入线程等待分支#2，并交错修改链表）则for循环重新开始，再尝试重新获取一次vval来进行同样的操作；若指向值还是tmp，则将vval的指向值赋值为&dow，此时val->dow_next值为NULL，可能会使得block执行分支#1进行while等待（如前述），紧接着执行dow.dow_next = tmp这句来增加链表节点（同时也使得block执行分支#1的while等待结束），然后等待在信号量上，当block执行分支#1完成并遍历链表来signal时，唤醒、释放信号量，然后一切就完成了。
         */
        // 此操作可以避免两个等待线程同时操作链表带来的问题
        // 判断vval与tmp是否相等，如果相等就返回YES，并将&dow的值赋给vval
        if (dispatch_atomic_cmpxchg(vval, tmp, &dow)) {
            dow.dow_next = tmp;
            _dispatch_thread_semaphore_wait(dow.dow_sema);
        }
    }
    // _dispatch_put_thread_semaphore内部使用的是“销毁旧的，存储新的”策略来缓存信号量
    _dispatch_put_thread_semaphore(dow.dow_sema);
}
```


<br/>

由上面的代码可知dispatch_once的流程图大致如下：

![ios_oc1_99.png](./../../Pictures/ios_oc1_99.png)

&emsp; 首先看一下dispatch_once中用的的原子性操作dispatch_atomic_cmpxchg(vval, NULL, &dow, acquire)，它的宏定义展开之后会将$dow赋值给vval，如果vval的初始值为NULL，返回YES,否则返回NO。


&emsp; 首次调用dispatch_once时，因为外部传入的dispatch_once_t变量值为nil，故vval会为NULL，故if判断成立。然后调用_dispatch_client_callout执行block，然后在block执行完成之后将vval的值更新成DISPATCH_ONCE_DONE表示任务已完成。最后遍历链表的节点并调用_dispatch_thread_semaphore_signal来唤醒等待中的信号量；

&emsp; 当其他线程同时也调用dispatch_once时，因为if判断是原子性操作，故只有一个线程进入到if分支中，其他线程会进入else分支。在else分支中会判断block是否已完成，如果已完成则跳出循环；否则就是更新链表并调用_dispatch_thread_semaphore_wait阻塞线程，等待if分支中的block完成后再唤醒当前等待的线程。


<br/>

**总结篇**

&emsp; dispatch_once用原子性操作block执行完成标记位，同时用信号量确保只有一个线程执行block，等block执行完再唤醒所有等待中的线程。






<br/>
<br/>
<br/>


><h2 id='并发'>并发</h2>


&emsp; 在 iOS 并发编程技术中，GCD 的使用率是最高的。所以，在这篇文章中，我就以 GCD 为例和你说说多线程的并发问题。


&emsp; GCD（Grand Central Dispatch）是由苹果公司开发的一个多核编程解决方案。它提供的一套简单易用的接口，极大地方便了并发编程。同时，它还可以完成对复杂的线程创建、释放时机的管理。但是，GCD 带来这些便利的同时，也带来了资源使用上的风险。


&emsp; 例如，在进行数据读写操作时，总是需要一段时间来等待磁盘响应的，如果在这个时候通过 GCD 发起了一个任务，那么 GCD 就会本着最大化利用 CPU 的原则，会在等待磁盘响应的这个空档，再创建一个新线程来保证能够充分利用 CPU。

&emsp; 而如果 GCD 发起的这些新任务，都是类似于数据存储这样需要等待磁盘响应的任务的话，那么随着任务数量的增加，GCD 创建的新线程就会越来越多，从而导致内存资源越来越紧张，等到磁盘开始响应后，再读取数据又会占用更多的内存。结果就是，失控的内存占用会引起更多的内存问题。


&emsp; 这种情况最典型的场景就是数据库读写操作。[FMDB](https://github.com/ccgus/fmdb)是一个开源的第三方数据库框架，通过 FMDatabaseQueue 这个核心类，将与读写数据库相关的磁盘操作都放到一个串行队列里执行，从而避免了线程创建过多导致系统资源紧张的情况。


<br/>


为了能够支持以后可能更大的并发量，下面我将其中“已读”功能的数据库操作改成 FMDatabaseQueue。这样，我就可以将并行队列转化为串行队列来执行，避免大并发读写磁盘操作造成内存问题，改写代码如下：

```
// 标记文章已读
- (RACSignal *)markFeedItemAsRead:(NSUInteger)iid fid:(NSUInteger)fid{
    @weakify(self);
    return [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {
        @strongify(self);
        // 改写成 FMDatabaseQueue 串行队列进行数据库操作
        FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:self.feedDBPath];
        [queue inDatabase:^(FMDatabase *db) {
            FMResultSet *rs = [FMResultSet new];
            // 读取文章数据
            if (fid == 0) {
                rs = [db executeQuery:@"select * from feeditem where isread = ? and iid >= ? order by iid desc", @(0), @(iid)];
            } else {
                rs = [db executeQuery:@"select * from feeditem where isread = ? and iid >= ? and fid = ? order by iid desc", @(0), @(iid), @(fid)];
            }
            NSUInteger count = 0;
            while ([rs next]) {
                count++;
            }
            // 更新文章状态为已读
            if (fid == 0) {
                [db executeUpdate:@"update feeditem set isread = ? where iid >= ?", @(1), @(iid)];
            } else {
                [db executeUpdate:@"update feeditem set isread = ? where iid >= ? and fid = ?", @(1), @(iid), @(fid)];
            }
            
            [subscriber sendNext:@(count)];
            [subscriber sendCompleted];
            [db close];
        }];
        return nil;
    }];
}
```

如代码所示，你只需要将数据库的操作放到 FMDatabaseQueue 的 inDatabase 方法入参 block 中，就可以在 FMDatabaseQueue 维护的串行队列里排队等待执行了.



<br/>
<br/>
<br/>


> <h2 id='线程组和依赖'>线程组和依赖</h2>  

<br/>

<h3 id='线程组处理'>线程组处理</h3>

```
{
    // 创建队列组
    dispatch_group_t group =  dispatch_group_create();
    // 创建并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
 
    // 开子线程，任务1
    dispatch_group_async(group, queue, ^{
        [NSData dataWithContentsOfURL:[NSURL URLWithString:@"https://img-blog.csdn.net/20180421152137506"]];
        NSLog(@"任务1 完成，线程：%@", [NSThread currentThread]);
    });
 
    // 开子线程，任务2
    dispatch_group_async(group, queue, ^{
        [NSData dataWithContentsOfURL:[NSURL URLWithString:@"https://img-blog.csdn.net/20170112145924755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGVyb193cWI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"]];
        NSLog(@"任务2 完成，线程：%@", [NSThread currentThread]);
    });
 
    // 全部完成
    dispatch_group_notify(group, queue, ^{
        dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@"全部完成，线程：%@", [NSThread currentThread]);
        });
    });
}
```

<br/>

输出结果：

```
AsyTaskTest[5963:308229] 任务1 完成，线程：<NSThread: 0x604000263380>{number = 3, name = (null)}

AsyTaskTest[5963:308228] 任务2 完成，线程：<NSThread: 0x60400007c4c0>{number = 4, name = (null)}

AsyTaskTest[5963:308103] 全部完成，线程：<NSThread: 0x604000070600>{number = 1, name = main}

```



<br/>
<br/>
<br/>

***
<br/>

> <h1 id='锁'>锁</h1>

<br/>
<br/>

> <h2 id='OSSpinLock'>OSSpinLock</h2>

&emsp; OSSpinLock:自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适。


<br/>
<br/>

> <h2 id='dispatch_semaphore'>dispatch_semaphore</h2>

&emsp; dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。




<br/>
<br/>

> <h2 id=''></h2>



<br/>
<br/>

> <h2 id=''></h2>







<br/>
<br/>
<br/>

***
<br/>




> <h1 id='NSOperation'>NSOperation</h1>

&emsp; 在 AFNetworking 2.0 中，把每个请求都封装成了单独的 NSOperationQueue，再由 NSOperationQueue 根据当前的 CPU 数量和系统负载来控制并发。那么，为什么 AFNetworking 2.0 没有为每个请求创建一个线程，而只是创建了一个队列，用来接收 NSOperationQueue 的回调呢？

&emsp; FMDB 只通过 FMDatabaseQueue 开启了一个线程队列，来串行地操作数据库。这又是为什么呢？

<br/>


&emsp; 这大概就是因为多线程技术有坑。特别是 UIKit 干脆就做成了线程不安全，只能在主线程上操作。

&emsp; 而写 UIKit、AFNetworking、FMDB 这些库的“大神”们，并不是解决不了多线程技术可能会带来的问题，而相反正是因为他们非常清楚这些可能存在的问题，所以为避免使用者滥用多线程，亦或是出于性能考虑，而选择了使用单一线程来保证这些基础库的稳定可用。


举一个在开发中可能遇到的一个例子：以照片处理为例，当选择一张照片后，你希望能够看到不同滤镜处理后的效果。如果这些效果图都是在一个队列里串行处理的话，那么你就得等着这些滤镜一个一个地来处理。这么做的话，不仅会影响用户体验，也没能充分利用硬件资源，可以说是把高端手机当作低端机来用了。换句话说就是，用户花大价钱升级了手机硬件，操作 App 的体验却没有得到提升。

所以，我们不能因为多线程技术有坑就不去用，正确的方法应该是更多地去了解多线程会有哪些问题，如果我们能够事先预见到那些问题的话，那么避免这些问题的发生也就不在话下了。

接下来，我们就一起来看看多线程技术常见的两个大坑，常驻线程和并发问题，分别是从何而来，以及如何避免吧。


<br/>
<br/>


> <h2 id='常驻线程'>常驻线程</h2>

&emsp; 常驻线程，指的就是那些不会停止，一直存在于内存中的线程。在 AFNetworking 2.0 专门创建了一个线程来接收 NSOperationQueue 的回调，这个线程其实就是一个常驻线程。接下来，我们就看看常驻线程这个问题是如何引起的，以及是否有对应的解决方案。

在AFNetworking 2.0 创建常驻线程的代码，来看一下这个线程是怎么创建的：

```
+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        // 先用 NSThread 创建了一个线程
        [[NSThread currentThread] setName:@"AFNetworking"];
        // 使用 run 方法添加 runloop
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}
```

AFNetworking 2.0 先用 NSThread 创建了一个线程，并使用 NSRunLoop 的 run 方法给这个新线程添加了一个 runloop。


<br/>


通过 NSRunLoop 添加 runloop 的方法有三个：
- run 方法。通过 run 方法添加的 runloop ，会不断地重复调用 runMode:beforeDate: 方法，来保证自己不会停止。
- runUntilDate: 和 runMode:beforeDate 方法。这两个方法添加的 runloop，可以通过指定时间来停止 runloop。

但是若是过多的创建常驻线程，不但不能提高 CPU 的利用率，反而会降低程序的执行效率。常驻线程是很耗费资源的。



<br/>

&emsp; 既然常线程是个坑，那为什么 **AFNetworking 2.0 库还要这么做呢？**

&emsp; 其实，这个问题的根源在于 AFNetworking 2.0 使用的是 NSURLConnection，而 NSURLConnection 的设计上存在些缺陷。接下来，我和你说说它的设计上有哪些缺陷，了解了这些缺陷后你也就能够理解当时 AFNetworking 2.0 为什么明知常驻线程有坑，还是使用了常驻线程。这样，你以后再碰到类似的情况时，也可以跟 AFNetworking 2.0 一样使用常线程去解决问题，只要不滥用常驻线程就可以了。

&emsp; NSURLConnection 发起请求后，所在的线程需要一直存活，以等待接收 NSURLConnectionDelegate 回调方法。但是，网络返回的时间不确定，所以这个线程就需要一直常驻在内存中。既然这样，AFNetworking 2.0 为什么没有在主线程上完成这个工作，而一定要新创建一个线程来做呢？


&emsp; 这是因为主线程还要处理大量的 UI 和交互工作，为了减少对主线程的影响，所以 AFNetworking 2.0 就新建了一个常驻线程，用来处理所有的请求和回调。AFNetworking 2.0 的线程设计如下图所示：

![ios_oc1_21.webp](./../../Pictures/ios_oc1_21.webp)

&emsp; 通过上面的分析我们可以知道，如果不是因为 NSURLConnection 的请求必须要有一个一直存活的线程来接收回调，那么 AFNetworking 2.0 就不用创建一个常驻线程出来了。虽然说，在一个 App 里网络请求这个动作的占比很高，但也有很多不需要网络的场景，所以线程一直常驻在内存中，也是不合理的。


<br/>
<br/>


&emsp; AFNetworking 在 3.0 版本时，使用苹果公司新推出的 NSURLSession 替换了 NSURLConnection，从而避免了常驻线程这个坑。NSURLSession 可以指定回调 NSOperationQueue，这样请求就不需要让线程一直常驻在内存里去等待回调了。实现代码如下：

```
self.operationQueue = [[NSOperationQueue alloc] init];
self.operationQueue.maxConcurrentOperationCount = 1;
self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];
```

&emsp; 从上面的代码可以看出，NSURLSession 发起的请求，可以指定回调的 delegateQueue，不再需要在当前线程进行代理方法的回调。所以说，NSURLSession 解决了 NSURLConnection 的线程回调问题。


<br/>

&emsp; 如果你需要确实需要保活线程一段时间的话，可以选择使用 NSRunLoop 的另外两个方法 runUntilDate: 和 runMode:beforeDate，来指定线程的保活时长。让线程存活时间可预期，总比让线程常驻，至少在硬件资源利用率这点上要更加合理。


或者，你还可以使用 CFRunLoopRef 的 CFRunLoopRun 和 CFRunLoopStop 方法来完成 runloop 的开启和停止，达到将线程保活一段时间的目的。








<br/>
<br/>

> <h2 id='依赖'>依赖</h2>


```
{
    // 创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
 
    // 任务1
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        [NSData dataWithContentsOfURL:[NSURL URLWithString:@"https://img-blog.csdn.net/20180421152137506"]];
        NSLog(@"任务1 完成，线程：%@", [NSThread currentThread]);
    }];
 
    // 任务2
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        [NSData dataWithContentsOfURL:[NSURL URLWithString:@"https://img-blog.csdn.net/20170112145924755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGVyb193cWI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"]];
        NSLog(@"任务2 完成，线程：%@", [NSThread currentThread]);
    }];
 
    // 添加操作依赖，注意不能循环依赖
    [op1 addDependency:op2];
 
    op1.completionBlock = ^{
        NSLog(@"全部完成，线程：%@", [NSThread currentThread]);
    };
 
    // 添加操作到队列
    [queue addOperation:op1];
    [queue addOperation:op2];
}


```

输出结果：

```
AsyTaskTest[6009:309365] 任务2 完成，线程：<NSThread: 0x600000277c80>{number = 3, name = (null)}

AsyTaskTest[6009:309362] 任务1 完成，线程：<NSThread: 0x60400046c0c0>{number = 4, name = (null)}

AsyTaskTest[6009:309364] 全部完成，线程：<NSThread: 0x600000277d40>{number = 5, name = (null)}


```




<br/>
<br/>



><h2 id='多任务(任务是异步)'>多任务(任务是异步)</h2>


若是直接使用上述的线程组来执行，可能会出问题，如下问题的模拟：

```
{
    NSURLSession *session = [NSURLSession sharedSession];
 
    // 创建队列组
    dispatch_group_t group =  dispatch_group_create();
    // 创建并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
 
    // 任务1
    dispatch_group_async(group, queue, ^{
        NSURLSessionDataTask *task1 = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.apple.com/105/media/us/imac-pro/2018/d0b63f9b_f0de_4dea_a993_62b4cb35ca96/hero/large.mp4"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            NSLog(@"任务1 完成，线程：%@", [NSThread currentThread]);
        }];
        [task1 resume];
    });
 
    // 任务2
    dispatch_group_async(group, queue, ^{
        NSURLSessionDataTask *task2 = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.apple.com/105/media/us/imac-pro/2018/d0b63f9b_f0de_4dea_a993_62b4cb35ca96/thumbnails/erin-sarofsky/large.mp4"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            NSLog(@"任务2 完成，线程：%@", [NSThread currentThread]);
        }];
        [task2 resume];
    });
 
    // 全部完成
    dispatch_group_notify(group, queue, ^{
        dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@"全部完成，线程：%@", [NSThread currentThread]);
        });
    });
}
 
! 输出结果：

AsyTaskTest[6048:310326] 全部完成，线程：<NSThread: 0x60000007f480>{number = 1, name = main}

AsyTaskTest[6048:310361] 任务2 完成，线程：<NSThread: 0x604000468a80>{number = 3, name = (null)}

AsyTaskTest[6048:310364] 任务1 完成，线程：<NSThread: 0x60400046a900>{number = 4, name = (null)}

```

- 通过dispatch_group_enter、dispatch_group_leave解决异步问题：

```
{
    NSURLSession *session = [NSURLSession sharedSession];
 
    // 创建队列组
    dispatch_group_t group = dispatch_group_create();
 
    // 任务1
    dispatch_group_enter(group);
    NSURLSessionDataTask *task1 = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.apple.com/105/media/us/imac-pro/2018/d0b63f9b_f0de_4dea_a993_62b4cb35ca96/hero/large.mp4"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        NSLog(@"任务1 完成，线程：%@", [NSThread currentThread]);
        dispatch_group_leave(group);
    }];
    [task1 resume];
 
    // 任务2
    dispatch_group_enter(group);
    NSURLSessionDataTask *task2 = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.apple.com/105/media/us/imac-pro/2018/d0b63f9b_f0de_4dea_a993_62b4cb35ca96/thumbnails/erin-sarofsky/large.mp4"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        NSLog(@"任务2 完成，线程：%@", [NSThread currentThread]);
        dispatch_group_leave(group);
    }];
    [task2 resume];
 
    // 全部完成
    dispatch_group_notify(group, dispatch_get_main_queue(), ^(){
        NSLog(@"全部完成，线程：%@", [NSThread currentThread]);
    });

    /*或者这样做
    dispatch_group_wait(taskGroup, DISPATCH_TIME_FOREVER);

        dispatch_async(dispatch_get_main_queue(), ^{

        //执行mainTask

    });
    */
}

```
 
输出结果：

```
AsyTaskTest[6102:311543] 任务2 完成，线程：<NSThread: 0x60400046bd00>{number = 3, name = (null)}

AsyTaskTest[6102:311539] 任务1 完成，线程：<NSThread: 0x60400046c700>{number = 4, name = (null)}

AsyTaskTest[6102:311509] 全部完成，线程：<NSThread: 0x60400007cdc0>{number = 1, name = main}

```


- 使用信号量+线程组来处理

```

{
    // 初始化信号量
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
 
    NSURLSession *session = [NSURLSession sharedSession];
 
    // 创建队列组
    dispatch_group_t group =  dispatch_group_create();
    // 创建并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
 
    // 任务1
    dispatch_group_async(group, queue, ^{
        NSURLSessionDataTask *task1 = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.apple.com/105/media/us/imac-pro/2018/d0b63f9b_f0de_4dea_a993_62b4cb35ca96/hero/large.mp4"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            NSLog(@"任务1 完成，线程：%@", [NSThread currentThread]);
            // 发送信号，使信号量+1
            dispatch_semaphore_signal(semaphore);
        }];
        [task1 resume];
    });
    // 信号量等于0时会一直等待，大于0时正常执行，并让信号量-1
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
 
    // 任务2
    dispatch_group_async(group, queue, ^{
        NSURLSessionDataTask *task2 = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.apple.com/105/media/us/imac-pro/2018/d0b63f9b_f0de_4dea_a993_62b4cb35ca96/thumbnails/erin-sarofsky/large.mp4"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            NSLog(@"任务2 完成，线程：%@", [NSThread currentThread]);
            dispatch_semaphore_signal(semaphore);
        }];
        [task2 resume];
    });
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
 
    // 全部完成
    dispatch_async(dispatch_get_main_queue(), ^{
        NSLog(@"全部完成，线程：%@", [NSThread currentThread]);
    });
}

```
 
输出结果：

```
AsyTaskTest[6149:312567] 任务1 完成，线程：<NSThread: 0x600000468040>{number = 3, name = (null)}

AsyTaskTest[6149:312567] 任务2 完成，线程：<NSThread: 0x600000468040>{number = 3, name = (null)}

AsyTaskTest[6149:312507] 全部完成，线程：<NSThread: 0x60000007d680>{number = 1, name = main}
 
```



<br/>
<br/>

***
<br/>


> <h2 id='内存问题'>内存问题</h2>


&emsp; 创建线程的过程，需要用到物理内存，CPU 也会消耗时间。而且，新建一个线程，系统还需要为这个进程空间分配一定的内存作为线程堆栈。堆栈大小是 4KB 的倍数。在 iOS 开发中，主线程堆栈大小是 1MB，新创建的子线程堆栈大小是 512KB。

&emsp; 除了内存开销外，线程创建得多了，CPU 在切换线程上下文时，还会更新寄存器，更新寄存器的时候需要寻址，而寻址的过程还会有较大的 CPU 消耗。

&emsp; 所以，线程过多时内存和 CPU 都会有大量的消耗，从而导致 App 整体性能降低，使得用户体验变成差。CPU 和内存的使用超出系统限制时，甚至会造成系统强杀。这种情况对用户和 App 的伤害就更大了。























