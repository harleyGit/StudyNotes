> <h2 id=''></h2>
- [**CoreData**](#CoreData)
	- [基础使用](#基础使用)
- [**持久化**](#持久化)
	- [序列化和反序列化](#序列化和反序列化)
- **参考资料**
	- [CoreData持久化存储数据至 SQLite](https://www.jianshu.com/p/f4d0f42398df)
	- [添加与查询数据](https://yq.aliyun.com/articles/39426)
	- [CoreData入门](https://www.cnblogs.com/mjios/archive/2013/02/26/2932999.html)



<br/>
<br/>

***
<br/>


> <h1 id='CoreData'>CoreData</h1>

![ios_oc1_22.png](./../../Pictures/ios_oc1_22.png)

- **NSManagedObjectContext：**数据库操作， 管理对象的上下文，类似于应用程序和数据存储间的一块缓冲区，你可以增删改查管理对象。也可以理解为是一个容器，从持久化存储（文件）中查询的数据在这个容器中形成对象图，对这些对象图中的对象操作都会存储在这个容器里，直到发出指令让容器中的内容同步到磁盘。

- **NSManagedObjectContext:**发起save操作，才会通过NSPersistentStoreCoordinate与数据交互并执行数据库操作，这样避免了因数据操作而带来的I/O操作，提高了效率

- **NSManagedObject：** 表记录，一个管理对象代表你想要保存到数据存储中的一个对象，类似于SQL中的一条记录，并且包含一些对象属性。简单点来说，NSManagedObject 就是NSManagedObjectContext对象图中的实际对象。由NSManagedObjectContext管理。NSManagedObjectContext会存储这些对象的变化来支持重做和撤销。

- **NSPersistentStoreCoordinator：**数据库存储方式， 持久化存储协调者 ，包含数据存储的名字和位置，简单点来说它是连接两端的纽带。所以整个流程就是：
	- 1、数据（NSManagedObject）被创建修改或删除等等，这些都被context看在眼里，然后你要保存了，context把修改的信息提交给，context根据数据信息找到正确的数据库文件，根据数据模型，正确的把数据写入到数据库文件里。
	- 2、查询时，context把查询条件提交给Coordinator，它去数据库文件里把数据查出来，给context,context再把这些数据和以在它管理内的结合。

- **NSPersistentStore：** 是持久化存储核心数据的抽象类，可以理解为持久化存储区，它的主要责任是把对象图中的信息map到实际的存储信息。持久化存储区支持的数据类型为SQLite、二进制、XML和内存。

<br/>

&emsp; SQLite 和FileSystem就是保存到持久化存储的文件，CoreData支持SQLite的数据格式。但是注意，coreData不是DBMS，并不能管理SQLite 



<br/>

> <h2 id='基础使用'>基础使用</h2>


- **1.创建NSManagedObjectModel**

```
// 加载：Model.xcdatamodeld 文件
lazy var managedObjectModel: NSManagedObjectModel = {

	if self.isTestMode {
	
	    return NSManagedObjectModel.mergedModel(from: Bundle.allBundles)! //连接项目中所有的 .xcdatamodeld 文件为一个datamodel，这是一个非常好的方法，把多个entity放在各自的xcodemodel文件中分开管理，然后用这个函数连接起来生成一个datamodel
	
	}
	
	let modelURL = Bundle.main.url(forResource: "Model", withExtension: "momd")!
	
	return NSManagedObjectModel(contentsOf: modelURL)!

}()
```




<br/>
<br/>




> <h2 id=''></h2>


<br/>
<br/>



> <h2 id=''></h2>


<br/>
<br/>


<br/>
<br/>

***
<br/>


> <h1 id='持久化'>持久化</h1>

- **持久化三个常见方法**
	- plist
	- NSUserDefault
	- 数据库

&emsp; 不管是哪一种方案，都不可能直接存储用户自定义的对象，所以需要将自定义的对象序列化成NSData，才能持久化。

&emsp; 需要用到的时候，就用数据库中取出，然后反序列化，恢复成对象

<br/>

> <h2 id='序列化和反序列化'>序列化和反序列化</h2>

&emsp; 如果自定义对象要想转成NSData，需要服从NSCoding协议。并实现其中的两个方法。

![ios_oc1_31](./../../Pictures/ios_oc1_31.webp)

<br/>

&emsp; iOS6中，苹果引入了一个新的协议，是基于NSCoding的，叫做NSSecureCoding。NSSecureCoding和NSCoding是一样的，除了在解码时要同时指定key和要解码的对象的类，如果要求的类和从文件中解码出的对象的类不匹配，NSCoder会抛出异常，告诉你数据已经被篡改了。大部分支持NSCoding的系统对象都已经升级到支持NSSecureCoding。

**DEMO**

**Person.h**

```
@interface Person : NSObject<NSSecureCoding>

@property (nonatomic, copy) NSString *name;

@property (nonatomic, copy) NSString *numberID;
```

<br/>

**Person.m**

```
@implementation Foo

- (void)encodeWithCoder:(nonnull NSCoder *)aCoder {
    [aCoder encodeObject:self.name forKey:NSStringFromSelector(@selector(name))];
    [aCoder encodeFloat:self.numberID forKey:NSStringFromSelector(@selector(numberID))];
}

- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder {
    if (self = [super init]) {
        self.name = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(name))];
        self.numberID = [aDecoder decodeFloatForKey:NSStringFromSelector(@selector(numberID))];
    }
    return self;
}

+ (BOOL)supportsSecureCoding
{
    return YES;
}

-(NSString *)description{
    return [NSString stringWithFormat:@"bar:%@ ; baz:%f",self.bar, self.baz];
}

@end

```

<br/>

**使用:**

```
Person *person = [[Person alloc] init];
person.name = @"祈求者Kael";
person.numberID = 24;

NSError *error0;
NSData *data = [NSKeyedArchiver archivedDataWithRootObject:person requiringSecureCoding:YES error:&error0];
NSLog(@"data --- %@", data);

NSError *error1;
Person *person1 = [NSKeyedUnarchiver unarchivedObjectOfClass:[Person class] fromData:data error:&error1];
NSLog(@"foo1 = %@", person1);

```


打印:

```
NSCodingDemo[1081:41952] data --- <62706c69 73743030 d4010203 04050616 17582476 65727369 6f6e5824 6f626a65 63747359 24617263 68697665 72542474 6f701200 0186a0a4 07080f10 55246e75 6c6cd309 0a0b0c0d 0e546b42 6172546b 42617a56 24636c61 73738002 2241c000 00800367 79486c42 8005004b 00610065 006cd211 1213145a 24636c61 73736e61 6d655824 636c6173 73657353 466f6fa2 1315584e 534f626a 6563745f 100f4e53 4b657965 64417263 68697665 72d11819 54726f6f 74800108 111a232d 32373c42 494e535a 5c616372 77828b8f 929badb0 b5000000 00000001 01000000 00000000 1a000000 00000000 00000000 00000000 b7>

NSCodingDemo[1081:41952] foo1 = bar:祈求者Kael ; baz:24.000000复制代码

```

<br/>

```
///测试属性@selector和序列号和反序列化
-(void) testUUIDMethod {
    self.testUUID = [NSUUID UUID].UUIDString;
    
    NSLog(@"🇨🇫 testUUID: %@,  @selector(testUUID): %@", self.testUUID, NSStringFromSelector(@selector(testUUID)));
}
```

打印:

```
2022-09-17 11:39:36.619385+0800 MLC[54350:1043294] 🇨🇫 testUUID: 503BBFA7-CA58-4CC0-BFDE-50F2925F897D,  @selector(testUUID): testUUID
(lldb) po @selector(testUUID)
"testUUID"

(lldb) p @selector(testUUID)
(SEL) $1 = "testUUID"
(lldb) 
```



<br/>
<br/>




<br/>
<br/>

***
<br/>


> <h1 id=''></h1>

<br/>

> <h2 id=''></h2>


<br/>
<br/>






<br/>
<br/>

***
<br/>

> <h1 id=''></h1>

