学习结构体的原因：
&emsp;  首先我们要了解为什么要用到`结构体`，我们已经学了很多`int 、char …`等类型还学到了同类型元素构成的数组，以及上述类型的指针，在一些小应用可以灵活使用。然而，在我们实际应用中，每一种变量进行一次声明，再结合起来显然是不太实际的，比如一位学生的信息管理，他可能有，姓名（char）、学号（int）、成绩（float）等多种数据。如果把这些数据分别单独定义，就会特别松散、复杂，难以规划。因此我们需要把一些相关的变量组合起来，以一个整体形式对对象进行描述，这就是`结构体`的好处。


![结构体学习图](https://upload-images.jianshu.io/upload_images/2959789-af39093175947be4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


<br/>
***
<br/>

># 结构体的申明和定义

#`结构体特点`
-  结构体变量分配地址，而结构体的定义是不分配空间的；
-  结构体中各成员的定义和之前的变量定义一样，但在定义时也不分配空间；
-  结构体变量的声明需要在主函数之上或者主函数中声明，如果在主函数之下则会报错；
-    C语言中的结构体不能直接进行强制转换，只有结构体指针才能进行强制转换。

# `结构体的申明`
```
struct StructureName{

    memberVariableList;

} StructureVariableList;

```
-  StructureName: 结构体名字；
-  memberVariableList： 成员变量类表；
- StructureVariableList：结构体变量列表；

#`定义结构体的几种方法`
-  先定义结构体类型，再定义结构体变量
```

struct Student{
      char number[20];         //学号
      char name[20];       //姓名
      char sex[5];         //性别
      int age;             //年龄
};             

//stu1,stu2为student结构体变量,分配空间
struct Student stu1,stu2;

// 用别名定义结构体类型的普通变量、指针变量和数组
struct Student stu1, *ps, stu[5]; 

size_t size_struct = sizeof(stu1);
size_t size_int = sizeof(int);
size_t size_char = sizeof(char);
printf(" struct stu1占用内存：%zu\n int 占用内存：%zu\n char 占用内存：%zu\n ", size_struct, size_int, size_char);

```
打印：
` struct stu1占用内存：52`
` int 占用内存：4`
 `char 占用内存：1`


-  定义结构体类型的同时定义结构体变量
```
struct Student{
    char number[20];   //学号
    char name[20];     //姓名
    char sex[5];       //性别
    int age;           //年龄
} stu1,stu2;  //结构体变量的定义 分配空间


// 用别名定义结构体类型的普通变量、指针变量和数组
struct Student stu1, *ps, stu[5]; 

size_t size_struct = sizeof(stu1);
size_t size_int = sizeof(int);
size_t size_char = sizeof(char);
printf(" struct stu1占用内存：%zu\n int 占用内存：%zu\n char 占用内存：%zu\n ", size_struct, size_int, size_char);

```
打印：
` struct stu1占用内存：52`
` int 占用内存：4`
 `char 占用内存：1`

此时还可以继续定义Student结构体变量，如：`struct Student stu3;`

- 不指定类型名而直接定义结构体变量
```
struct{
    char    number[20];     //学号
    char    name[20];       //姓名
    char    sex[5];         //性别
    int     age;            //年龄
} stu1,stu2;  //结构体变量的定义 分配空间


size_t size_struct = sizeof(stu1);
size_t size_int = sizeof(int);
size_t size_char = sizeof(char);
printf(" struct stu1占用内存：%zu\n int 占用内存：%zu\n char 占用内存：%zu\n ", size_struct, size_int, size_char);

```
打印：
` struct stu1占用内存：52`
` int 占用内存：4`
 `char 占用内存：1`

&emsp;  一般不使用这种方法，因为直接定义结构体变量stu1、stu2之后，就不能再继续定义该类型的变量。

- 用typedef定义结构体变量
```
typedef struct Stdudent{
    char    number[20];     //学号
    char    name[20];       //姓名
    char    sex[5];         //性别
    int     age;            //年龄
} Apprentice;

// 用别名定义结构体类型的普通变量、指针变量和数组
Apprentice stu1, *ps, stu[5]; 

Apprentice student;
size_t size_struct = sizeof(student);
size_t size_int = sizeof(int);
size_t size_char = sizeof(char);
printf(" struct student占用内存：%zu\n int 占用内存：%zu\n char 占用内存：%zu\n ", size_struct, size_int, size_char);
```
打印：
` struct student占用内存：52`
` int 占用内存：4`
 `char 占用内存：1`

&emsp;  上面的代码，定义了一个结构体变量类型，这个类型有2个名字：第一个名字是Stdudent；第二个类型名字是Apprentice.

定义了这个之后，下面有2中方法可以定义结构体变量

第一种： `struct Stdudent student_1;   //定义了一个student_1的结构体变量，分配空间`
第二种：`Apprentice student_1            //定义了一个student_1的结构体变量，分配空间`





<br/>
***
<br/>

> #结构体成员

&emsp;  获取结构体成员的一般格式为：`结构体变量名.成员名;`
```
struct Student
    {
        long ID;
        char name[20];
        float score;
    }ChengXin;

struct Student stu1;

```
-  `struct Student *p=&stu1;`

-  `(* p). score;`

-  ` p -> ID;`





<br/>
***
<br/>
># 结构体的引用

```
typedef struct Tool{
    char    eraser[10];
    char    knife[20];
}LearnTools;

typedef struct Stdudent{
    char    number[20];     //学号
    char    name[20];       //姓名
    char    sex[5];         //性别
    int     age;            //年龄
    
    LearnTools *tool;
} Apprentice;

```
&emsp;  在结构体中不可以包含一个类型为他自身的结构体,但结构体中可以包含自身类型的指针类型。





<br/>
***
<br/>
># 结构体变量的定义和初始化
```
typedef struct Tool{
    char    eraser[10];
    char    knife[20];
}LearnTools;

typedef struct Stdudent{
    char    number[20];     //学号
    char    name[20];       //姓名
    char    sex[5];         //性别
    int     age;            //年龄
    
    LearnTools tool;
} Apprentice;


# one 结构体赋值
    //定义
    Apprentice student_one;
    //初始化
    LearnTools tool = {"橡皮", "卷笔刀"};
    //结构体嵌套
    Apprentice student_two = {"2019314", "harley.boTe", "male", 16, {"🐸橡皮","威力刀具"}};
    
    printf("tool 结构体值为：%s,  %s\n", tool.eraser, tool.knife);
    printf("student_two 结构体值为：%s,  %s, %s,  %d, %s,  %s", student_two.number, student_two.name, student_two
           .sex, student_two.age, student_two.tool.eraser, student_two.tool.knife);


# two strcpy 赋值
typedef struct Stdudent{
    char    number[20];     //学号
    char    name[20];       //姓名
    char    sex[5];         //性别
    int     age;            //年龄
} Apprentice;





int main(int argc, const char * argv[]) {
    Apprentice student;
    
    strcpy(student.number, "20191038");
    strcpy(student.name, "hello");
    strcpy(student.sex, "male");
    student.age = 25;
//    strcpy(student.age, 26);//注意：这个库函数针对于字符串，int型不可以
    printf("numger: %s, name: %s, sex: %s, age: %d\n", student.number, student.name, student.sex, student.age);


//输出：numger: 20191038, name: hello, sex: male, age: 25





# three 定义之后任意赋值
int main(int argc, const char * argv[]) {
    Apprentice student = {
        .number = "20191038",
        .name = "hello",
        .sex = "male",
        .age = 25,
    };
    
    
    printf("numger: %s, name: %s, sex: %s, age: %d\n", student.number, student.name, student.sex, student.age);

//输出值为：numger: 20191038, name: hello, sex: male, age: 25
}
```
输出：
`tool 结构体值为：橡皮,  卷笔刀`
`student_two 结构体值为：2019314,  harley.boTe, male,  16, 🐸橡皮威力刀具,  威力刀具 struct student占用内存：84`

结构体的赋值只能访问成员变量逐个赋值，不可以一起赋值。



<br/>
***
<br/>
># 结构体内存对齐
```
struct Compare_one{
    int     a;
    char    c;
    double  d;
};
struct Compare_Two{
    char    c;
    double  d;
    int     a;
};

int main(int argc, const char * argv[]) {
      printf("size for int : %lu, char: %lu, double: %lu\n", sizeof(int), sizeof(char), sizeof(double));
      printf("%lu\n", sizeof(struct Compare_one));
      printf("%lu\n", sizeof(struct Compare_Two));
      system("pause");
}

```
我们原希望输出：
`size for int : 4, char: 1, double: 8`
 `13`
`13`

实际输出为：
`size for int : 4, char: 1, double: 8`
`16`
`24`

这是为什么呢？
这就是结构体的[内存对齐](https://blog.csdn.net/shanghx_123/article/details/79679726)，其原因主要有：`平台和性能两个原因，简而言之，就是拿空间换取时间`。

对齐规则：
-  第一个成员在结构体变量的偏移量为0的地指处；

-  下一个成员变量对齐到该成员变量对齐数的整数倍地址处，对齐数=min（默认对齐数（OC：8，liunux：4），该成员字节数）；

-  结构体的总大小为所有成员变量最大对齐数的整数倍；

-  如果结构体嵌套，嵌套的结构体对齐到自己最大对齐数的整数倍除，结构体的整体大小就是所有成员变量最大的对齐数的整数倍。

#`DEMO`
```
struct Compare_one{
    int     a;  //4
    char    c;  //4+1=5
    double  d;  //5+3+8=16
};
struct Compare_Two{
    char    c;                  //1
    struct Compare_one one;     //1+7+16=24
    double  d;                  //24+8=32
    int     a;                  //32+4=36
};//大于36的最小的整除最大对齐数8的是40，所以运算结果应该是40

int main(int argc, const char * argv[]) {
    printf("size for int : %lu, char: %lu, double: %lu\n", sizeof(int), sizeof(char), sizeof(double));
    printf("%lu\n", sizeof(struct Compare_Two));
    system("pause");
}
```
输出：
`size for int : 4, char: 1, double: 8`
`40`




<br/>
***
<br/>
># Structure 传参

```
void print_one(struct Compare_one one){
    //传值
    printf("one.a:%d\n", one.a);
}

void print_two(struct Compare_Two *two){
    //传指针
    printf("two.a:%d\n", two->a);
    printf("two.c:%c\n", (*two).c);

}




int main(int argc, const char * argv[]) {
    struct Compare_one one = {6, 'H', 12.00};
    struct Compare_Two two = {'E', {8, 'L', 120.00}, 124.00, 8};
    print_one(one);
    print_two(&two);
}
```
输出：
`one.a:6`
`two.a:8`
`two.c:E`


