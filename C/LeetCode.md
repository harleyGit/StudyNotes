> <h1 id=""></h1>
- **çŸ¥è¯†ç‚¹**
	- [std::](#std)
	- [Vectorå‘é‡](#Vectorå‘é‡)
	- [(::)èŒƒå›´è§£æè¿ç®—ç¬¦](#èŒƒå›´è§£æè¿ç®—ç¬¦)
	- [include](#include)
	- [size()å’Œstrlen()](#sizeå’Œstrlen)
- **ç®—æ³•ç»ƒä¹ **
	- [å®å®šä¹‰](#å®å®šä¹‰)
		- [æ™®é€šæ‰“å°-println](#æ™®é€šæ‰“å°-println)
		- [æ•°ç»„æ‰“å°-printArr](#æ•°ç»„æ‰“å°-printArr)
	- [**é€’å½’å›æº¯**](#é€’å½’å›æº¯)
		- [æ–æ³¢é‚£å¥‘æ•°åˆ—](#æ–æ³¢é‚£å¥‘æ•°åˆ—)
		- [ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](#ç”µè¯å·ç çš„å­—æ¯ç»„åˆ)
		- [æ‹¬å·ç”Ÿæˆ](#æ‹¬å·ç”Ÿæˆ)
	- [**é“¾è¡¨**](#é“¾è¡¨)
		- [æ¨å¯¼æ ‘çš„éå†(å¯Œé€”)](#æ¨å¯¼æ ‘çš„éå†(å¯Œé€”))
		- [2ä¸ªé˜Ÿåˆ—å®ç°ä¸€ä¸ªæ ˆ(ä¸ƒçŒ«)](#2ä¸ªé˜Ÿåˆ—å®ç°ä¸€ä¸ªæ ˆ)
		- [åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹](#åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªç»“ç‚¹)
		- [åˆå¹¶Kä¸ªå‡åºé“¾è¡¨(æœ‰æ®µä¸å¤ªæ˜ç™½)](#åˆå¹¶Kä¸ªå‡åºé“¾è¡¨)
		- [åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](#åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨)
	- [**æ ˆä¸é˜Ÿåˆ—**](#æ ˆä¸é˜Ÿåˆ—)
		- [æœ‰æ•ˆçš„æ‹¬å·](#æœ‰æ•ˆçš„æ‹¬å·)
		- [æœ€é•¿æœ‰æ•ˆæ‹¬å·](#æœ€é•¿æœ‰æ•ˆæ‹¬å·)
	- [ä¸¤æ•°ä¹‹å’Œ](#ä¸¤æ•°ä¹‹å’Œ)
	- [ä¸¤æ•°ç›¸åŠ ](#ä¸¤æ•°ç›¸åŠ )
	- [æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](#æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²)
	- [å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](#å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°)
	- [æœ€é•¿å›æ–‡å­ä¸²](#æœ€é•¿å›æ–‡å­ä¸²)
	- [æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…](#æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…)
	- [ç››æœ€å¤šæ°´çš„å®¹å™¨](#ç››æœ€å¤šæ°´çš„å®¹å™¨)
	- [ä¸‰æ•°ä¹‹å’Œ](#ä¸‰æ•°ä¹‹å’Œ)
	- [ä¸‹ä¸€ä¸ªæ’åˆ—](#ä¸‹ä¸€ä¸ªæ’åˆ—)
- **å‚è€ƒèµ„æ–™**
	- [**leetcode çƒ­é¢˜100**](https://leetcode-cn.com/problem-list/2cktkvj/)
	- [Cè¯­è¨€(èœé¸Ÿæ•™ç¨‹)](https://www.runoob.com/cprogramming/c-tutorial.html)
	- [10å¤§åŸºç¡€å®ç”¨ç®—æ³•åŠå…¶è®²è§£](https://mp.weixin.qq.com/s?__biz=MzI0MjE3OTYwMg==&mid=401441966&idx=1&sn=653fe22c5a7e6c221fbf121124fd18a2&scene=21#wechat_redirect)
	- [ç®—æ³•-æ˜¥æ°´ç…èŒ¶](https://writings.sh/posts)
	- [**ä»£ç éšæƒ³å½•**](https://www.programmercarl.com/)
		- [ä»£ç éšæƒ³å½•(Bç«™è§†é¢‘)](https://space.bilibili.com/525438321/)


<br/>

***
<br/>
<br/>


> <h1 id="çŸ¥è¯†ç‚¹">çŸ¥è¯†ç‚¹</h1>

<br/>

> <h2 id="std">std::</h2>

[**std::**](https://blog.csdn.net/Calvin_zhou/article/details/78440145)æ˜¯ä¸ªåç§°ç©ºé—´æ ‡è¯†ç¬¦ï¼ŒC++æ ‡å‡†åº“ä¸­çš„å‡½æ•°æˆ–è€…å¯¹è±¡éƒ½æ˜¯åœ¨å‘½åç©ºé—´stdä¸­å®šä¹‰çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ä½¿ç”¨æ ‡å‡†åº“ä¸­çš„å‡½æ•°æˆ–è€…å¯¹è±¡éƒ½è¦ç”¨stdæ¥é™å®šã€‚


<br/>


> <h2 id="Vectorå‘é‡">Vectorå‘é‡</h2>

[**Vectorå‘é‡**](https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html)æ˜¯ä¸€ä¸ªå°è£…äº†åŠ¨æ€å¤§å°æ•°ç»„çš„é¡ºåºå®¹å™¨ï¼ˆSequence Containerï¼‰ã€‚è·Ÿä»»æ„å…¶å®ƒç±»å‹å®¹å™¨ä¸€æ ·ï¼Œå®ƒèƒ½å¤Ÿå­˜æ”¾å„ç§ç±»å‹çš„å¯¹è±¡ã€‚å¯ä»¥ç®€å•çš„è®¤ä¸ºï¼Œå‘é‡æ˜¯ä¸€ä¸ªèƒ½å¤Ÿå­˜æ”¾ä»»æ„ç±»å‹çš„åŠ¨æ€æ•°ç»„ã€‚

<br/>


> <h2 id="èŒƒå›´è§£æè¿ç®—ç¬¦">(::)èŒƒå›´è§£æè¿ç®—ç¬¦</h2>

**(::)èŒƒå›´è§£æè¿ç®—ç¬¦**ï¼šåœ¨å‰é¢çš„ç±»å£°æ˜èŒƒä¾‹ä¸­ï¼Œæˆ‘ä»¬éƒ½æŠŠæˆå‘˜å‡½æ•°å®šä¹‰åœ¨ç±»å†…ã€‚äº‹å®ä¸Šï¼Œç±»ä¸­æˆå‘˜å‡½æ•°çš„ç¨‹åºä»£ç ä¸ä¸€å®šè¦å†™åœ¨ç±»å†…ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨ç±»ä¸­äº‹å…ˆå£°æ˜æˆå‘˜å‡½æ•°çš„åŸå‹ï¼Œç„¶ååœ¨ç±»å¤–é¢å†ç¼–å†™æˆå‘˜å‡½æ•°çš„ç¨‹åºä»£ç éƒ¨åˆ†ã€‚å¦‚æœæ˜¯åœ¨ç±»å¤–é¢ç¼–å†™æˆå‘˜å‡½æ•°ï¼Œåªè¦åœ¨å¤–éƒ¨å®šä¹‰æ—¶å‡½æ•°åç§°å‰é¢åŠ ä¸Šç±»åç§°ä¸èŒƒå›´è§£æè¿ç®—ç¬¦ï¼ˆ::ï¼‰å³å¯ã€‚èŒƒå›´è§£æè¿ç®—ç¬¦çš„ä¸»è¦ä½œç”¨å°±æ˜¯æŒ‡å‡ºæˆå‘˜å‡½æ•°æ‰€å±çš„ç±»ã€‚


<br/>

> <h2 id="include">#include</h2>
**#include**

```

 #includeå¹¶ä¸æ˜¯ä»€ä¹ˆç”³è¯·æŒ‡ä»¤ï¼Œåªæ˜¯å°†æŒ‡å®šæ–‡ä»¶çš„å†…å®¹ï¼ŒåŸå°ä¸åŠ¨çš„æ‹·è´è¿›æ¥
 *.hæ–‡ä»¶åšçš„æ˜¯ç±»çš„å£°æ˜ï¼ŒåŒ…æ‹¬ç±»æˆå‘˜çš„å®šä¹‰å’Œå‡½æ•°çš„å£°æ˜
 *.cppæ–‡ä»¶åšçš„ç±»æˆå‘˜å‡½æ•°çš„å…·ä½“å®ç°ï¼ˆå®šä¹‰ï¼‰
 åœ¨*.cppæ–‡ä»¶çš„ç¬¬ä¸€è¡Œä¸€èˆ¬ä¹Ÿæ˜¯#include"*.h"æ–‡ä»¶ï¼Œå…¶å®ä¹Ÿç›¸å½“äºæŠŠ*.hæ–‡ä»¶é‡Œçš„ä¸œè¥¿å¤åˆ¶åˆ°*.cppæ–‡ä»¶çš„å¼€å¤´
 */
```



<br/>


> <h2 id="sizeå’Œstrlen">size()å’Œstrlen()</h2>

- size()ï¼šè®¡ç®—stringçš„é•¿åº¦ï¼›
- strlenï¼šè®¡ç®—å­—ç¬¦çš„é•¿åº¦ï¼›

è¿™2ä¸ªå‡½æ•°æ–¹æ³•éœ€è¦å¯¼å…¥`#include <string.h>`çš„æ ‡å‡†åº“ã€‚

```
//size()è®¡ç®—stringçš„é•¿åº¦ï¼Œstrlenè®¡ç®—å­—ç¬¦çš„é•¿åº¦
size_t length = s.size();

```


- **size_tç±»å‹**
	- size_tçš„çœŸå®ç±»å‹ä¸æ“ä½œç³»ç»Ÿæœ‰å…³ï¼Œåœ¨32ä½æ¶æ„ä¸­è¢«æ™®éå®šä¹‰ä¸ºï¼š
		- typedef   unsigned int size_t;
	- è€Œåœ¨64ä½æ¶æ„ä¸­è¢«å®šä¹‰ä¸ºï¼š
		- typedef  unsigned long size_t;


<br/>

***
<br/>


> <h1 id="ç®—æ³•ç»ƒä¹ ">ç®—æ³•ç»ƒä¹ </h1>


<br/>


> <h2 id="å®å®šä¹‰">å®å®šä¹‰</h2>


<br/>

> <h3 id="æ™®é€šæ‰“å°-println">æ™®é€šæ‰“å°-println</h3>

```
///Cè¯­è¨€è‡ªåŠ¨æ¢è¡Œå®šä¹‰çš„å®:https://www.bennyhuo.com/2020/06/14/c-println/
#define println(format, ...) printf("ğŸŒ·ğŸŒ¹(%s:%s [%dè¡Œ] %s) "format"\n", __DATE__, __TIME__, __LINE__, __FUNCTION__, ##__VA_ARGS__)
```


<br/>
<br/>

> <h3 id="æ•°ç»„æ‰“å°-printArr">æ•°ç»„æ‰“å°-printArr</h3>



```
///Cè¯­è¨€æ•°ç»„æ‰“å°
#define printArr(array,len) \
    printf("ğŸŒ·ğŸŒ¹ %s [%dè¡Œ] %s=> ",__TIME__, __LINE__, __FUNCTION__); \
    do  \
    { \
        for(int i = 0;i<len;i++) \
        { \
            printf("%02X ",array[i]); \
        } \
        printf("\r\n"); \
    }while(0)
```



<br/>

***
<br/>
<br/>


> <h1 id="é€’å½’å›æº¯">é€’å½’å›æº¯</h1>

<br/>


> <h2 id="æ–æ³¢é‚£å¥‘æ•°åˆ—">æ–æ³¢é‚£å¥‘æ•°åˆ—</h2>

æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼š 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987

æ–æ³¢é‚£å¥‘æ•°åˆ—ä»£æ•°å¼ï¼š

```
n = 0ï¼ŒF(n) = 0;
n = 1,    F(N) = 1;
n > 1,    F(n-1) + F(n-2)
```



```
#pragma mark -- é€’å½’
int Fbi(int data){
    if (data < 2) {
        return data == 0 ? 0 : 1;
    }
    
    return Fbi(data -1) + Fbi(data -2);
}


void linkStackTestMethod(void){
    for (int i = 0; i < 17 ; i ++) {
            printf(" %d,",Fbi(i));
        }
}
```
è¾“å‡ºï¼š

```
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987,
```



æ¥æ¨¡æ‹Ÿä¸Šè¿°ä»£ç ä¸­å½“Fbi(int data) ä¸­ï¼Œdata = 5æ—¶çš„æ“ä½œï¼š
![æ–æ³¢é‚£å¥‘æ•°åˆ—é€’å½’å›¾](https://upload-images.jianshu.io/upload_images/2959789-fa16acc47f9f41b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&emsp;  é€’å½’ä¸­ï¼Œè°ƒç”¨è‡ªå·±å’Œå…¶ä»–å‡½æ•°å¹¶æ²¡æœ‰æœ¬è´¨ä¸åŒï¼Œæˆ‘ä»¬`æŠŠä¸€ä¸ªç›´æ¥è°ƒç”¨è‡ªå·±æˆ–é€šè¿‡ä¸€ç³»åˆ—çš„è°ƒç”¨è¯­å¥é—´æ¥åœ°è°ƒç”¨è‡ªå·±çš„å‡½æ•°ï¼Œç§°ä½œé€’å½’å‡½æ•°`ã€‚

&emsp;  åœ¨å†™é€’å½’æ—¶éœ€è¦æ³¨æ„ï¼Œ`æ¯ä¸ªé€’å½’å®šä¹‰å¿…é¡»è‡³å°‘æœ‰ä¸€ä¸ªæ¡ä»¶ï¼Œæ»¡è¶³æ—¶é€’å½’ä¸å†è¿›è¡Œï¼Œæ—¢ä¸å†å¼•ç”¨è‡ªèº«è€Œæ˜¯è¿”å›å€¼é€€å‡º`ã€‚æ¯”å¦‚ä¸Šè¿°çš„ä¾‹å­ä¸­ï¼Œæ€»æœ‰ä¸€æ¬¡é€’å½’ä¼šä½¿å¾—i<2çš„ï¼Œè¿™æ ·å°±å¯ä»¥æ‰§è¡Œ `return i`çš„è¯­å¥è€Œä¸ç”¨ç»§ç»­é€’å½’äº†ã€‚

&emsp;  `è¿­ä»£å’Œé€’å½’çš„åŒºåˆ«`ï¼šè¿­ä»£ä½¿ç”¨çš„æ˜¯å¾ªç¯ç»“æ„ï¼Œé€’å½’ä½¿ç”¨çš„æ˜¯é€‰æ‹©ç»“æ„ã€‚é€’å½’èƒ½ä½¿ç¨‹åºçš„ç»“æ„æ›´æ¸…æ™°ã€ç®€æ´ã€æ›´å®¹æ˜“è®©äººç†è§£ï¼Œä»è€Œå‡å°‘è¯»æ‡‚ä»£ç çš„æ—¶é—´ã€‚ä½†æ˜¯å¤§é‡çš„é€’å½’è°ƒç”¨ä¼šå»ºç«‹å‡½æ•°çš„å‰¯æœ¬ï¼Œä¼šè€—è´¹å¤§é‡çš„æ—¶é—´å’Œå†…å­˜ã€‚è¿­ä»£åˆ™ä¸éœ€è¦åå¤è°ƒç”¨å‡½æ•°å’Œå ç”¨é¢å¤–çš„å†…å­˜ã€‚

&emsp;  é€’å½’çš„æœ¬è´¨ï¼šé€’å½’è¿‡ç¨‹é€€å›çš„é¡ºåºæ˜¯å®ƒå‰è¡Œé¡ºåºçš„é€†åºã€‚åœ¨é€€å›è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½è¦æ‰§è¡ŒæŸäº›åŠ¨ä½œï¼ŒåŒ…æ‹¬æ¢å¤åœ¨å‰è¡Œè¿‡ç¨‹ä¸­çš„å­˜å‚¨èµ·æ¥çš„æŸäº›æ•°æ®ã€‚

&emsp;  è¿™ç§å­˜å‚¨æŸäº›æ•°æ®ï¼Œå¹¶åœ¨åé¢åˆä»¥å­˜å‚¨çš„é€†åºæ¢å¤è¿™äº›æ•°æ®ï¼Œä»¥æä¾›ä¹‹åä½¿ç”¨çš„éœ€æ±‚ï¼Œæ˜¾ç„¶å¾ˆç¬¦åˆæ ˆè¿™æ ·çš„æ•°æ®ç»“æ„ï¼Œå› æ­¤ï¼Œç¼–è¯‘å™¨ä½¿ç”¨æ ˆå®ç°é€’å½’å°±æ²¡æœ‰ä»€ä¹ˆå¥½å¥‡æ€ªçš„äº†ã€‚

&emsp;  ç®€å•çš„æ¥è¯´ï¼Œå°±æ˜¯åœ¨å‰è¡Œé˜¶æ®µï¼Œå¯¹äºæ¯ä¸€å±‚é€’å½’ï¼Œå‡½æ•°çš„å±€éƒ¨å˜é‡ã€å‚æ•°å€¼ä»¥åŠè¿”å›åœ°å€éƒ½è¢«å‹å…¥æ ˆä¸­ã€‚å†é€€å›é˜¶æ®µï¼Œä½äºæ ˆé¡¶çš„å±€éƒ¨å˜é‡ã€å‚æ•°å€¼å’Œè¿”å›åœ°å€è¢«å¼¹å‡ºï¼Œç”¨äºè¿”å›è°ƒç”¨å±‚æ¬¡ä¸­æ‰§è¡Œä»£ç çš„å…¶ä½™éƒ¨åˆ†ï¼Œä¹Ÿå°±æ¢å¤äº†è°ƒç”¨çš„çŠ¶æ€ã€‚


> <h2 id="ç”µè¯å·ç çš„å­—æ¯ç»„åˆ">ç”µè¯å·ç çš„å­—æ¯ç»„åˆ</h2>


ç»™å®šä¸€ä¸ªä»…åŒ…å«æ•°å­—Â 2-9Â çš„å­—ç¬¦ä¸²ï¼Œè¿”å›æ‰€æœ‰å®ƒèƒ½è¡¨ç¤ºçš„å­—æ¯ç»„åˆã€‚ç­”æ¡ˆå¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ã€‚

ç»™å‡ºæ•°å­—åˆ°å­—æ¯çš„æ˜ å°„å¦‚ä¸‹ï¼ˆä¸ç”µè¯æŒ‰é”®ç›¸åŒï¼‰ã€‚æ³¨æ„ 1 ä¸å¯¹åº”ä»»ä½•å­—æ¯ã€‚

![c0_38.png](./../Pictures/c0_38.png)

Â 

ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šdigits = "23"
è¾“å‡ºï¼š["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šdigits = ""
è¾“å‡ºï¼š[]
```

ç¤ºä¾‹ 3ï¼š

```
è¾“å…¥ï¼šdigits = "2"
è¾“å‡ºï¼š["a","b","c"]
```



**[å›æº¯æ³•](https://programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html#å›æº¯æ³•çš„æ•ˆç‡)è§£å†³nä¸ªforå¾ªç¯é—®é¢˜**

æ€è·¯:

![c0_39.png](./../Pictures/c0_39.png)



<br/>

**å›æº¯ä¸‰éƒ¨æ›²ï¼š**

- ç¡®å®šå›æº¯å‡½æ•°å‚æ•°

é¦–å…ˆéœ€è¦ä¸€ä¸ªå­—ç¬¦ä¸²pathArrayæ¥æ”¶é›†å¶å­èŠ‚ç‚¹çš„ç»“æœï¼Œç„¶åç”¨ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„resultLettersä¿å­˜èµ·æ¥ï¼Œè¿™ä¸¤ä¸ªå˜é‡æˆ‘ä¾ç„¶å®šä¹‰ä¸ºå…¨å±€ã€‚

å†æ¥çœ‹å‚æ•°ï¼Œå‚æ•°æŒ‡å®šæ˜¯æœ‰é¢˜ç›®ä¸­ç»™çš„char* digitsï¼Œç„¶åè¿˜è¦æœ‰ä¸€ä¸ªå‚æ•°å°±æ˜¯intå‹çš„indexã€‚

è¿™ä¸ªindexæ˜¯è®°å½•éå†ç¬¬å‡ ä¸ªæ•°å­—äº†ï¼Œå°±æ˜¯ç”¨æ¥éå†digitsçš„ï¼ˆé¢˜ç›®ä¸­ç»™å‡ºæ•°å­—å­—ç¬¦ä¸²ï¼‰ï¼ŒåŒæ—¶indexä¹Ÿè¡¨ç¤ºæ ‘çš„æ·±åº¦ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```
///æ•°ç»„è¦åŠ *å·,å¦åˆ™æŠ¥é”™:excess elements in char array initializer [solution.c]
///åŸå› :æ˜¯å¤šä¸ªå­—ç¬¦ä¸²ï¼Œä¸æ˜¯å•ä¸ªå­—ç¬¦ï¼Œè¿™å¾—ç”¨ï¼ŒæŒ‡é’ˆæ•°ç»„
///æ¯ä¸ªå·ç ç›˜ä»£è¡¨çš„æ•°å­—
char *numberChar[10]= {
    "",     //0
    "",     //1
    "abc",  //2
    "def",  //3
    "ghi",  //4
    "jkl",  //5
    "mno",  //6
    "pqrs", //7
    "tuv",  //8
    "wxyz", //9
};
///å­—æ¯ç»„åˆç»“æœ
char **resultLetters;
///æ¯æ¬¡éå†åˆ°æèŠ‚ç‚¹æ—¶ç››æ”¾å…ƒç´ çš„æ•°ç»„
char *pathArray;
///å­˜æ”¾ç»“æœæ•°ç»„å…ƒç´ åºåˆ—å·, ä¸èƒ½åœ¨è¿™é‡Œç›´æ¥èµ‹å€¼,å¦åˆ™åœ¨leetcodeä¸é€šè¿‡
int resultTop;
///è·¯å¾„æ·±åº¦
int pathTop;

void backTracking(char* digits, int index) 
```



- ç¡®å®šç»ˆæ­¢æ¡ä»¶

ä¾‹å¦‚è¾“å…¥ç”¨ä¾‹"23"ï¼Œä¸¤ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆæ ¹èŠ‚ç‚¹å¾€ä¸‹é€’å½’ä¸¤å±‚å°±å¯ä»¥äº†ï¼Œå¶å­èŠ‚ç‚¹å°±æ˜¯è¦æ”¶é›†çš„ç»“æœé›†ã€‚

é‚£ä¹ˆç»ˆæ­¢æ¡ä»¶å°±æ˜¯å¦‚æœindex ç­‰äº è¾“å…¥çš„æ•°å­—ä¸ªæ•°ï¼ˆstrlen(digits)äº†ï¼ˆæœ¬æ¥indexå°±æ˜¯ç”¨æ¥éå†digitsçš„ï¼‰ã€‚

ç„¶åæ”¶é›†ç»“æœï¼Œç»“æŸæœ¬å±‚é€’å½’ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```
//è‹¥å½“å‰ä¸‹æ ‡ç­‰äºdigitsæ•°ç»„é•¿åº¦
if (strlen(digits) == index) {
    //åœ¨è¿™é‡Œä¸éœ€è¦æŠŠpathArrayç½®ä¸ºNULL,å› ä¸ºåœ¨ä¸‹é¢çš„å¾ªç¯éå†ä¸­ä¼šæŠŠå®ƒè¦†ç›–æ‰çš„

    int digitLength = (int)strlen(digits);
    //å¤åˆ¶digitsæ•°ç»„ï¼Œå› ä¸ºæœ€åè¦å¤šå­˜å‚¨ä¸€ä¸ª0ï¼Œæ‰€ä»¥æ•°ç»„é•¿åº¦è¦+1
    char *tempStr = (char *)malloc(sizeof(char)*(digitLength+1));
    for (int j = 0; j < digitLength ; j++) {
        tempStr[j]= pathArray[j];
    }
    
    //tempStræœ€åä¸€ä¸ªè¦è®¾ç½®ä¸ºç©º,ä¹Ÿå°±æ˜¯0
    tempStr[digitLength]= 0;
    resultLetters[resultTop++]= tempStr;
    
    return;
}
```


- ç¡®å®šå•å±‚éå†é€»è¾‘

é¦–å…ˆè¦å–indexæŒ‡å‘çš„æ•°å­—ï¼Œå¹¶æ‰¾åˆ°å¯¹åº”çš„å­—ç¬¦é›†ï¼ˆæ‰‹æœºé”®ç›˜çš„å­—ç¬¦é›†ï¼‰ã€‚

ç„¶åforå¾ªç¯æ¥å¤„ç†è¿™ä¸ªå­—ç¬¦é›†ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
///é”®ç›˜ç¬¬å‡ ä¸ªæ•°å­—
//å°†å­—ç¬¦æ•°å­—è½¬æ¢ä¸ºçœŸçš„æ•°å­—,è¦å‡å»å­—ç¬¦'0',ä¸æ˜¯æ•°å­—0å¦åˆ™ä¼šå‡ºé”™
int currentIndex = digits[index] - '0';
///è·å–å¯¹åº”é”®ç›˜æ•°å­—çš„å­—ç¬¦ä¸²å…ƒç´ 
char *numbers = numberChar[currentIndex];
///é”®ç›˜å­—ç¬¦ä¸²é•¿åº¦
int numberLength = (int)strlen(numbers);

for (int i = 0; i < numberLength; i++) {
    pathArray[pathTop++]= numbers[i];
    //é€’å½’ï¼Œå¤„ç†ä¸‹ä¸€å±‚æ•°å­—
    backTracking(digits, index+1);
    pathTop--;
}
```


æ‰€ä»¥æ€»çš„ä»£ç æ˜¯:


```
///æ•°ç»„è¦åŠ *å·,å¦åˆ™æŠ¥é”™:excess elements in char array initializer [solution.c]
///åŸå› :æ˜¯å¤šä¸ªå­—ç¬¦ä¸²ï¼Œä¸æ˜¯å•ä¸ªå­—ç¬¦ï¼Œè¿™å¾—ç”¨ï¼ŒæŒ‡é’ˆæ•°ç»„
///æ¯ä¸ªå·ç ç›˜ä»£è¡¨çš„æ•°å­—
char *numberChar[10]= {
    "",     //0
    "",     //1
    "abc",  //2
    "def",  //3
    "ghi",  //4
    "jkl",  //5
    "mno",  //6
    "pqrs", //7
    "tuv",  //8
    "wxyz", //9
};
///å­—æ¯ç»„åˆç»“æœ
char **resultLetters;
///æ¯æ¬¡éå†åˆ°æèŠ‚ç‚¹æ—¶ç››æ”¾å…ƒç´ çš„æ•°ç»„
char *pathArray;
///å­˜æ”¾ç»“æœæ•°ç»„å…ƒç´ åºåˆ—å·, ä¸èƒ½åœ¨è¿™é‡Œç›´æ¥èµ‹å€¼,å¦åˆ™åœ¨leetcodeä¸é€šè¿‡
int resultTop;
///è·¯å¾„æ·±åº¦
int pathTop;

void backTracking(char* digits, int index) {
    
    //è‹¥å½“å‰ä¸‹æ ‡ç­‰äºdigitsæ•°ç»„é•¿åº¦
    if (strlen(digits) == index) {
        //åœ¨è¿™é‡Œä¸éœ€è¦æŠŠpathArrayç½®ä¸ºNULL,å› ä¸ºåœ¨ä¸‹é¢çš„å¾ªç¯éå†ä¸­ä¼šæŠŠå®ƒè¦†ç›–æ‰çš„

        int digitLength = (int)strlen(digits);
        //å¤åˆ¶digitsæ•°ç»„ï¼Œå› ä¸ºæœ€åè¦å¤šå­˜å‚¨ä¸€ä¸ª0ï¼Œæ‰€ä»¥æ•°ç»„é•¿åº¦è¦+1
        char *tempStr = (char *)malloc(sizeof(char)*(digitLength+1));
        for (int j = 0; j < digitLength ; j++) {
            tempStr[j]= pathArray[j];
        }
        
        //tempStræœ€åä¸€ä¸ªè¦è®¾ç½®ä¸ºç©º,ä¹Ÿå°±æ˜¯0
        tempStr[digitLength]= 0;
        resultLetters[resultTop++]= tempStr;
        
        return;
    }
    
    ///é”®ç›˜ç¬¬å‡ ä¸ªæ•°å­—
    //å°†å­—ç¬¦æ•°å­—è½¬æ¢ä¸ºçœŸçš„æ•°å­—,è¦å‡å»å­—ç¬¦'0',ä¸æ˜¯æ•°å­—0å¦åˆ™ä¼šå‡ºé”™
    int currentIndex = digits[index] - '0';
    ///è·å–å¯¹åº”é”®ç›˜æ•°å­—çš„å­—ç¬¦ä¸²å…ƒç´ 
    char *numbers = numberChar[currentIndex];
    ///é”®ç›˜å­—ç¬¦ä¸²é•¿åº¦
    int numberLength = (int)strlen(numbers);
    
    for (int i = 0; i < numberLength; i++) {
        pathArray[pathTop++]= numbers[i];
        //é€’å½’ï¼Œå¤„ç†ä¸‹ä¸€å±‚æ•°å­—
        backTracking(digits, index+1);
        pathTop--;
    }
}

char ** letterCombinations(char * digits, int* returnSize){
    
    int length = (int)strlen(digits);
    resultLetters = (char **)malloc(sizeof(char*) * 300);
    pathArray = (char *)malloc(sizeof(char) * length);
    *returnSize = 0;

    ///è‹¥digitsæ•°ç»„ä¸­å…ƒç´ ä¸ªæ•°ä¸º0ï¼Œè¿”å›ç©ºé›†
    if (length == 0) {
        return resultLetters;
    }
    pathTop = resultTop = 0;
    backTracking(digits, 0);
    *returnSize = resultTop;
    
    return resultLetters;
}




///è°ƒç”¨
///é€’å½’å›æº¯
+ (void)testLetterCombinations{
    char digits[] = {"23"};
    int size = 1;
    
    char **a = letterCombinations(digits, &size);
    
    for (int i = 0; i < size; i++) {
        printf("ğŸŒ·ğŸŒ¹è¡Œ:");
        char *b = a[i];
        for (int j = 0; j < 3; j++) {
            printf("%c", b[j]);
        }
        printf("\n");

    }
}

```


**Log:**

```
ğŸŒ·ğŸŒ¹è¡Œ:ad
ğŸŒ·ğŸŒ¹è¡Œ:ae
ğŸŒ·ğŸŒ¹è¡Œ:af
ğŸŒ·ğŸŒ¹è¡Œ:bd
ğŸŒ·ğŸŒ¹è¡Œ:be
ğŸŒ·ğŸŒ¹è¡Œ:bf
ğŸŒ·ğŸŒ¹è¡Œ:cd
ğŸŒ·ğŸŒ¹è¡Œ:ce
ğŸŒ·ğŸŒ¹è¡Œ:cf
```



<br/><br/>


> <h2 id='æ‹¬å·ç”Ÿæˆ'>æ‹¬å·ç”Ÿæˆ</h2>


æ•°å­— nÂ ä»£è¡¨ç”Ÿæˆæ‹¬å·çš„å¯¹æ•°ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºèƒ½å¤Ÿç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å¹¶ä¸” æœ‰æ•ˆçš„ æ‹¬å·ç»„åˆã€‚

Â 
![c0_70.png](./../Pictures/c0_70.png)


ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šn = 3
è¾“å‡ºï¼š["((()))","(()())","(())()","()(())","()()()"]
```

ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šn = 1
è¾“å‡ºï¼š["()"]
```


```
void generateBracket(int open, int close, int n, char **result, int *bracketsize, char *str, int index){
    if (open == n && close == n) { //å·¦å³æ‹¬å·éƒ½ç”¨å®Œ
        result[(*bracketsize)]= (char *)calloc((2*n+1), sizeof(char));
        strcpy(result[(*bracketsize)++] , str);
        return;
    }
    
    if (open < n) { //å½“å·¦æ‹¬å·æ²¡ç”¨å®Œæ—¶
        str[index] = '(';
        generateBracket(open+1, close, n, result, bracketsize, str, index+1);
    }
    
    if (close < open && close < n) { //å³æ‹¬å·æ•°é‡å¿…é¡»å°äºå·¦æ‹¬å·ï¼Œå¦åˆ™ä¸€å®šä¸åˆæ³•ï¼Œä¸”å³æ‹¬å·æ²¡æœ‰ç”¨å®Œ
        str[index] = ')';
        generateBracket(open, close+1, n, result, bracketsize, str, index+1);
    }
}

char ** generateParenthesis(int n, int* returnSize){
    char **kuoHaoArr = (char **)malloc(sizeof(char *) * 1430);///1430å¡ç‰¹å…°æ•°
    *returnSize = 0;
    char *str=(char *)calloc((2*n +1),sizeof(char));
    
    generateBracket(0, 0, n, kuoHaoArr, returnSize, str, 0);
    
    return kuoHaoArr;
}



///è°ƒç”¨
+ (void)testGenerateParenthesis{
    
    
    int size = 1;
    char **a= generateParenthesis(2, &size);
    for (int i = 0; i < size; i++) {
        printf("ğŸŒ·ğŸŒ¹è¡Œ:");
        char *b = a[i];
        for (int j = 0; j < (2*size); j++) {
            printf("%c", b[j]);
        }
        printf("\n");

    }
    
}
```


**log:**

```
ğŸŒ·ğŸŒ¹è¡Œ:(())
ğŸŒ·ğŸŒ¹è¡Œ:()()
```


<br/>

***
<br/><br/>

> <h1 id='é“¾è¡¨'>é“¾è¡¨</h1>


<br/><br/>

>## <h2 id='æ¨å¯¼æ ‘çš„éå†'>[æ¨å¯¼æ ‘çš„éå†(å¯Œé€”)](http://b23.tv/cBRRZJI)</h2>

![c0_71.png](./../Pictures/c0_71.png)

![c0_72.png](./../Pictures/c0_72.png)


<br/>

- **å‡ºé¢˜1:**
	- 	å‰åºéå†:ABDHKECFIGJ
	- 	ä¸­åºéå†:HKDBEAIFCGJ
	
	æ±‚ç»™å‡ºåç»­éå†çš„åºåˆ—?
	
	
	è¿™ä¸ªå¯ä»¥çœ‹ä¸‹ã€Šå¤§è¯æ•°æ®ç»“æ„ã€‹ä¸­çš„,æœ‰è¯¦è§£!
	
	ç­”æ¡ˆ:KHDEBIFJGCA
	
	
	<br/>



- **å‡ºé¢˜2:**
	- 	ä¸­åºéå†:ABCDEF
	- 	ååºéå†:CBAEDF

	
	æ±‚ç»™å‡ºå‰ç»­éå†çš„åºåˆ—?
	
	
è¿™ä¸ªå¯ä»¥çœ‹ä¸‹ã€Šå¤§è¯æ•°æ®ç»“æ„ã€‹ä¸­çš„,æœ‰è¯¦è§£!

		
ç­”æ¡ˆ:CBEFDA





<br/><br/>

> <h2 id='2ä¸ªé˜Ÿåˆ—å®ç°ä¸€ä¸ªæ ˆ'>2ä¸ªé˜Ÿåˆ—å®ç°ä¸€ä¸ªæ ˆ</h2>

**æ€è·¯:**


q1æ˜¯ä¸“èŒè¿›å‡ºæ ˆçš„ï¼Œq2åªæ˜¯ä¸ªä¸­è½¬ç«™

**å…¥æ ˆ**ï¼šç›´æ¥å…¥é˜Ÿåˆ—q1å³å¯

**å‡ºæ ˆ**ï¼šæŠŠq1çš„é™¤æœ€åä¸€ä¸ªå…ƒç´ å¤–å…¨éƒ¨è½¬ç§»åˆ°é˜Ÿq2ä¸­,ç„¶åæŠŠåˆšæ‰å‰©ä¸‹q1ä¸­çš„é‚£ä¸ªå…ƒç´ å‡ºé˜Ÿåˆ—ã€‚ä¹‹åæŠŠq2ä¸­çš„å…¨éƒ¨å…ƒç´ è½¬ç§»å›q1ä¸­

å›¾ç¤º

![c0_65.png](./../Pictures/c0_65.png)



**code:**

**Stackby_two_queue.h**

```
#pragma once

typedef char DataType2;

typedef struct Queue
{
	DataType2* queue_data;
	int head;
	int tail;
	int size;
	int capacity;
}Queue;

typedef struct Stack
{
	Queue queue1;
	Queue queue2;
	//æ ˆä¸­æœ‰æ•ˆå…ƒç´ ä¸ªæ•°
	int size;
}Stack;

//æ ˆçš„åˆå§‹åŒ–
void StackInit(Stack *stack,int vector_capacity);
//æ ˆçš„é”€æ¯
void StackDestory(Stack* stack);
//å…¥æ ˆ
void StackPush(Stack* stack, DataType2 value);
//å‡ºæ ˆ
void StackPop(Stack* stack);
//å–æ ˆé¡¶å…ƒç´ 
DataType2 StackGetTop(Stack* stack);
```


<br/>

**Stackby_two_queue.c**

```
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "Stackby_two_queue.h"

void QueueInit(Queue* queue, int vector_capacity)
{
	if (queue == NULL)
	{
		assert(0);
		return -1;
	}
	queue->capacity = vector_capacity;
	queue->queue_data = (DataType2*)malloc(sizeof(DataType2)*queue->capacity);
	queue->size = 0;
	queue->head = 0;
	queue->tail = 0;
}

void QueueDestory(Queue* queue)
{
	if (queue == NULL)
	{
		assert(0);
		return -1;
	}
	free(queue->queue_data);
	queue->queue_data = NULL;
	queue->size = 0;
	queue->head = 0;
	queue->tail = 0;
	queue->capacity = 0;
}

void QueuePush(Queue* queue,DataType2 value)
{
	if (queue == NULL)
	{
		assert(0);
		return -1;
	}
	if (queue->size >= queue->capacity)
	{
		return ;
	}
	queue->queue_data[queue->tail++] = value;
	queue->size++;
	if (queue->tail > queue->capacity)
	{
		queue->tail = 0;
	}
}

void QueuePop(Queue* queue)
{
	if (queue == NULL)
	{
		assert(0);
		return -1;
	}
	if (queue->size == 0)
	{
		return ; 
	}
	if (queue->head >= queue->capacity)
	{
		queue->head = 0;
	}
	queue->head++;
	queue->size--;
	if (queue->size == 0)
	{
		queue->head = 0;
		queue->tail = 0;
	}
}
//å–é˜Ÿé¦–å…ƒç´ 
DataType2 QueueGetTop(Queue* queue)
{
	if (queue == NULL)
	{
		assert(0);
		return -1;
	}
	if (queue->size == 0)
	{
		return ;
	}
	return queue->queue_data[queue->head];
}

//æ‰“å°æ•´ä¸ªé˜Ÿåˆ—
void PrintQueue(Queue* queue)
{
	if (queue == NULL)
	{
		assert(0);
		return -1;
	}
	if (queue->size == 0)
	{
		return ; 
	}
	if (queue->head < queue->tail)
	{
		int i = queue->head;
		for (; i < queue->tail; i++)
		{
			printf("%c ", queue->queue_data[i]);
		}
	}
	else
	{
		int i = queue->head;
		while (queue->head < queue->capacity)
		{
			printf("%c", queue->queue_data[queue->head]);
			queue->head++;
		}
		queue->head = 0;
		for (i = queue->head; i < queue->tail; ++i)
		{
			printf("%c ", queue->queue_data[i]);
		}
	}
	printf("\n");
}

//é€šè¿‡ä¸¤ä¸ªé˜Ÿåˆ—å®ç°ä¸€ä¸ªæ ˆçš„å…¥æ ˆï¼Œå‡ºæ ˆå’Œå–æ ˆé¡¶å…ƒç´ æ“ä½œ
//æ ˆçš„åˆå§‹åŒ–å‡½æ•°
void StackInit(Stack* stack,int vector_capacity)
{
	if (stack == NULL)
	{
		assert(0);
		return -1;
	}
	QueueInit(&stack->queue1,vector_capacity);
	QueueInit(&stack->queue2,vector_capacity);
	stack->size = 0;
}

//é”€æ¯ä¸€ä¸ªæ ˆ
void StackDestory(Stack* stack)
{
	if (stack == NULL)
	{
		assert(0);
		return -1;
	}
	QueueDestory(&stack->queue1);
	QueueDestory(&stack->queue2);
	stack->size = 0;
}

//å…¥æ ˆæ“ä½œ
void StackPush(Stack* stack,DataType2 value)
{
	if (stack == NULL)
	{
		assert(0);
		return -1;
	}
	if (stack->queue1.size != 0) {
		QueuePush(&stack->queue1, value);
	}
	else {
		QueuePush(&stack->queue2, value);
	}
	stack->size++;
}

void StackPop(Stack* stack)
{
	if (stack == NULL)
	{
		assert(0);
		return -1;
	}
	if (stack->queue1.size == 0 && stack->queue2.size == 0)
	{
		return ;
	}
	Queue* from = NULL;
	Queue* to = NULL;
	//åˆ¤æ–­æ•°æ®æ”¾åœ¨äº†å“ªä¸ªé˜Ÿåˆ—
	if (stack->queue1.size != 0)
	{
		from = &stack->queue1;
		to = &stack->queue2;
	}
	else
	{
		from = &stack->queue2;
		to = &stack->queue1;
	}
	while (from->size > 1)
	{
		//å–åˆ°fromé˜Ÿåˆ—çš„é˜Ÿå¤´å…ƒç´ 
		DataType2 tmp = QueueGetTop(from);
		//fromåšä¸€æ¬¡å‡ºé˜Ÿåˆ—æ“ä½œ
		QueuePop(from);
		//å°†fromçš„å¯¹å¤´æ”¾åˆ°toé˜Ÿåˆ—
		QueuePush(to, tmp);
	}
	//æŠŠfromé˜Ÿåˆ—å‰©çš„æœ€åä¸€ä¸ªå…ƒç´ ç§»å‡ºé˜Ÿåˆ—ï¼Œæ¨¡æ‹Ÿå‡ºæ ˆ
	QueuePop(from);
	//æ ˆä¸­çš„æœ‰æ•ˆæ•°æ®ä¸ªæ•°å‡ä¸€
	stack->size--;
}

DataType2 StackGetTop(Stack* stack)
{
	if (stack == NULL)
	{
		assert(0);
		return -1;
	}
	if ((stack->queue1.size == 0) && (stack->queue2.size == 0))
	{
		return ;
	}
	Queue* from = NULL;
	Queue* to = NULL;
	//åˆ¤æ–­æ•°æ®æ”¾åœ¨äº†å“ªä¸ªé˜Ÿåˆ—
	if (stack->queue1.size != 0)
	{
		from = &stack->queue1;
		to = &stack->queue2;
	}
	else
	{
		from = &stack->queue2;
		to = &stack->queue1;
	}
	while (from->size > 1)
	{
		//å–åˆ°fromé˜Ÿåˆ—çš„é˜Ÿå¤´å…ƒç´ 
		DataType2 tmp = QueueGetTop(from);
		//fromåšä¸€æ¬¡å‡ºé˜Ÿåˆ—æ“ä½œ
		QueuePop(from);
		//å°†fromçš„å¯¹å¤´æ”¾åˆ°toé˜Ÿåˆ—
		QueuePush(to, tmp);
	}
	//è¯»å–fromé˜Ÿåˆ—çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæ¨¡æ‹Ÿè¯»å–æ ˆé¡¶
	DataType2 stacktop = QueueGetTop(from);
	QueuePop(from);
	QueuePush(to, stacktop);
	return stacktop;
}

void PrintStack(Stack* stack)
{
	if (stack == NULL)
	{
		assert(0);
		return -1;
	}
	if (stack->size == 0)
	{
		return ;
	}
	Queue* print = NULL;
	if (stack->queue1.size == 0)
	{
		print = &stack->queue2;
	}
	else
	{
		print = &stack->queue1;
	}
	PrintQueue(print);
}

int main()
{
	Stack stack;
	//åˆå§‹åŒ–
	StackInit(&stack,10);
	//å…¥æ ˆå‡½æ•°æµ‹è¯•
	StackPush(&stack, 'a');
	StackPush(&stack, 'b');
	StackPush(&stack, 'c');
	StackPush(&stack, 'd');
	StackPop(&stack);
	PrintStack(&stack);
	DataType2 top_value = StackGetTop(&stack);
	printf("%c \n", top_value);
	StackDestory(&stack);
	system("pause");
	return 0;
}
```

<br/>
<br/>

> <h2 id='åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªç»“ç‚¹'> åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹</h2>

ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Â nÂ ä¸ªç»“ç‚¹ï¼Œå¹¶ä¸”è¿”å›é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚


![c0_40.png](./../Pictures/c0_40.png)


ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šhead = [1,2,3,4,5], n = 2
è¾“å‡ºï¼š[1,2,3,5]
```

ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šhead = [1], n = 1
è¾“å‡ºï¼š[]
```

ç¤ºä¾‹ 3ï¼š

```
è¾“å…¥ï¼šhead = [1,2], n = 1
è¾“å‡ºï¼š[1]
```



å¤§ç¥è§£é¢˜æ€è·¯:

åŒæŒ‡é’ˆçš„ç»å…¸åº”ç”¨ï¼Œå¦‚æœè¦åˆ é™¤å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹ï¼Œè®©fastç§»åŠ¨næ­¥ï¼Œç„¶åè®©fastå’ŒslowåŒæ—¶ç§»åŠ¨ï¼Œç›´åˆ°fastæŒ‡å‘é“¾è¡¨æœ«å°¾ã€‚åˆ æ‰slowæ‰€æŒ‡å‘çš„èŠ‚ç‚¹å°±å¯ä»¥äº†ã€‚

æ€è·¯æ˜¯è¿™æ ·çš„ï¼Œä½†è¦æ³¨æ„ä¸€äº›ç»†èŠ‚ã€‚

åˆ†ä¸ºå¦‚ä¸‹å‡ æ­¥ï¼š

é¦–å…ˆè¿™é‡Œæˆ‘æ¨èå¤§å®¶ä½¿ç”¨è™šæ‹Ÿå¤´ç»“ç‚¹ï¼Œè¿™æ ·æ–¹ä¾¿å¤„ç†åˆ é™¤å®é™…å¤´ç»“ç‚¹çš„é€»è¾‘ï¼Œå¦‚æœè™šæ‹Ÿå¤´ç»“ç‚¹ä¸æ¸…æ¥šï¼Œå¯ä»¥çœ‹è¿™ç¯‡ï¼š é“¾è¡¨ï¼šå¬è¯´ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹ä¼šæ–¹ä¾¿å¾ˆå¤šï¼Ÿ (opens new window)

å®šä¹‰fastæŒ‡é’ˆå’ŒslowæŒ‡é’ˆï¼Œåˆå§‹å€¼ä¸ºè™šæ‹Ÿå¤´ç»“ç‚¹ï¼Œå¦‚å›¾ï¼š


![c0_44.png](./../Pictures/c0_44.png)



fasté¦–å…ˆèµ°n + 1æ­¥ ï¼Œä¸ºä»€ä¹ˆæ˜¯n+1å‘¢ï¼Œå› ä¸ºåªæœ‰è¿™æ ·åŒæ—¶ç§»åŠ¨çš„æ—¶å€™slowæ‰èƒ½æŒ‡å‘åˆ é™¤èŠ‚ç‚¹çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼ˆæ–¹ä¾¿åšåˆ é™¤æ“ä½œï¼‰ï¼Œå¦‚å›¾ï¼š 

![c0_41.png](./../Pictures/c0_41.png)

fastå’ŒslowåŒæ—¶ç§»åŠ¨ï¼Œç›´åˆ°fastæŒ‡å‘æœ«å°¾ï¼Œå¦‚é¢˜ï¼š

![c0_42.png](./../Pictures/c0_42.png) 

åˆ é™¤slowæŒ‡å‘çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚å›¾ï¼š 

![c0_43.png](./../Pictures/c0_43.png)



```
struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {
    //å®šä¹‰è™šæ‹Ÿå¤´èŠ‚ç‚¹dummy å¹¶åˆå§‹åŒ–ä½¿å…¶æŒ‡å‘head
    struct ListNode* dummy = malloc(sizeof(struct ListNode));
    dummy->val = 0;
    dummy->next = head;
    //å®šä¹‰ fast slow åŒæŒ‡é’ˆ
    struct ListNode* fast = head;
    struct ListNode* slow = dummy;

    for (int i = 0; i < n; ++i) {
        fast = fast->next;
    }
    while (fast) {
        fast = fast->next;
        slow = slow->next;
    }
    slow->next = slow->next->next;//åˆ é™¤å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹
    head = dummy->next;
    free(dummy);//åˆ é™¤è™šæ‹ŸèŠ‚ç‚¹dummy
    return head;
}



///è°ƒç”¨
+ (void)testRemoveNthFromEnd{
    
    int list[]={1, 2, 3, 4, 5};
    int listLength = sizeof(list)/sizeof(int);
    struct ListNode *head = (struct ListNode*)malloc(sizeof(struct ListNode));
    head->val = list[0];
    head->next = NULL;
    
    struct ListNode* node = head;
    node->next = NULL;
    
    ///é‡‡ç”¨å°¾æ’æ³•
    for (int i = 1; i < listLength; i ++) {
        struct ListNode* addNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        addNode->val = list[i];
        addNode->next = NULL;//è¿™é‡Œè¦ç½®ä¸ºNULL,å¦åˆ™åé¢æ— æ³•åˆ¤æ–­é“¾è¡¨æ˜¯å¦ç»“æŸ
        
        node->next = addNode;
        node = addNode;
    }
    
    struct ListNode *nowHead = removeNthFromEnd(head, 2);
    
    while(nowHead){
        println("é“¾è¡¨èŠ‚ç‚¹: %d", nowHead->val);
        nowHead = nowHead->next;
    }
}
```


Log:

```
ğŸŒ·ğŸŒ¹(May  4 2023:22:10:49 [132è¡Œ] +[HGTestAlgorithm testRemoveNthFromEnd]) é“¾è¡¨èŠ‚ç‚¹: 1
ğŸŒ·ğŸŒ¹(May  4 2023:22:10:49 [132è¡Œ] +[HGTestAlgorithm testRemoveNthFromEnd]) é“¾è¡¨èŠ‚ç‚¹: 2
ğŸŒ·ğŸŒ¹(May  4 2023:22:10:49 [132è¡Œ] +[HGTestAlgorithm testRemoveNthFromEnd]) é“¾è¡¨èŠ‚ç‚¹: 3
ğŸŒ·ğŸŒ¹(May  4 2023:22:10:49 [132è¡Œ] +[HGTestAlgorithm testRemoveNthFromEnd]) é“¾è¡¨èŠ‚ç‚¹: 5
```



æˆ‘çš„æ€è·¯:
	ä½¿ç”¨ä¸€ä¸ªNè®°å½•æ€»å…±çš„èŠ‚ç‚¹æ•°,ç„¶åå½“å®ƒç­‰äºæ­£æ•°ç¬¬(N-n)ä¸ªæ—¶è¿›è¡Œè¿”å›,é‡‡ç”¨é€’å½’.æˆ‘æ˜¯è¿™æ ·æƒ³çš„.ç„¶åç”¨ä¸€ä¸ªèŠ‚ç‚¹è®°å½•ä¸Šä¸€ä¸ªèŠ‚ç‚¹,è¿™æ ·å°±å¯ä»¥äº†!





<br/><br/>


> <h2 id='åˆå¹¶Kä¸ªå‡åºé“¾è¡¨'>åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨</h2>


ç»™ä½ ä¸€ä¸ªé“¾è¡¨æ•°ç»„ï¼Œæ¯ä¸ªé“¾è¡¨éƒ½å·²ç»æŒ‰å‡åºæ’åˆ—ã€‚

è¯·ä½ å°†æ‰€æœ‰é“¾è¡¨åˆå¹¶åˆ°ä¸€ä¸ªå‡åºé“¾è¡¨ä¸­ï¼Œè¿”å›åˆå¹¶åçš„é“¾è¡¨ã€‚


ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šlists = [[1,4,5],[1,3,4],[2,6]]
è¾“å‡ºï¼š[1,1,2,3,4,4,5,6]
è§£é‡Šï¼šé“¾è¡¨æ•°ç»„å¦‚ä¸‹ï¼š
[
  1->4->5,
  1->3->4,
  2->6
]
å°†å®ƒä»¬åˆå¹¶åˆ°ä¸€ä¸ªæœ‰åºé“¾è¡¨ä¸­å¾—åˆ°ã€‚
1->1->2->3->4->4->5->6
```

ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šlists = []
è¾“å‡ºï¼š[]
```

ç¤ºä¾‹ 3ï¼š

```
è¾“å…¥ï¼šlists = [[]]
è¾“å‡ºï¼š[]
```


<br/>


**æ€è·¯:**

å¦‚æœå¯¹å¿«é€Ÿæ’åºæˆ–è€…å½’å¹¶æ’åºæœ‰äº†è§£çš„åŒå­¦ä»£ç ä¹Ÿè®¸ä¸€çœ¼å°±èƒ½çœ‹æ˜ç™½ï¼Œæœ‰ç‚¹å‚è€ƒä»–ä»¬çš„æ€æƒ³

ç¨‹åºä¸»é¢˜æ€æƒ³è¿˜æ˜¯é€’å½’ï¼Œå½’å¹¶æˆ–è€…å¿«é€Ÿæ’åºçš„æ€æƒ³å¤æ‚åº¦ä¸ºnlgnçº§åˆ«ï¼Œ

å› ä¸ºæ˜¯é€’å½’ï¼Œå¦‚æœåµŒå¥—ååˆ†æ·±å…¥çš„è¯ï¼Œè¿˜æ˜¯éœ€è¦ä¸€ç‚¹å †æ ˆçš„ç©ºé—´çš„

mergeTwoLists è¿™ä¸ªå‡½æ•°å¯ä»¥ä¸çœ‹ï¼Œæ˜¯ä¹‹å‰åšé¢˜å·²ç»å®ç°çš„ç¨‹åºï¼Œã€‚ç›´æ¥æ‹¿æ¥ç”¨å°±å¯ä»¥äº†

æ ¸å¿ƒä»£ç ä¸è¿‡ _mergeKLists(...) å‡½æ•°é‡Œé¢çš„åè¡Œæœ‰ä½™

å¦‚æœæœ‰bug,è¯·æŒ‡æ­£


```
struct ListNode *_twoListMerge(struct ListNode *l1, struct ListNode *l2){
    
    struct ListNode head;
    head.next = l1;
    l1 = &head;
    struct ListNode *q,*p;
    
    if (!l1) {
        return l2;
    }
    
    if (!l2) {
        return l1;
    }
    
    while (l2) {
        q = l1->next;
        p = l2 ->next;
        
        
        if (!l1->next) {
            l1->next = l2;
            break;
        }
        
        /*è¿™æ®µä»£ç é”™è¯¯çš„,ä¸ºä»€ä¹ˆä¸èƒ½æ›¿æ¢ä¸‹é¢çš„
        if (q->val <= l2->val) {
            l2->next = q->next;
            q->next = l2;
    
            l2 = p;
        }
    
        l1 = q;
         */
        
        if (q->val >= l2->val) {
            l1->next = l2;
            l2->next = q;
            l2 = p;
        }
        
        l1 = l1->next;
    }
    
    return head.next;
}

struct ListNode *_mergeKLists(struct ListNode** lists, int listsSize){
    
    if (listsSize == 0) {
        return NULL;
    }else if(listsSize == 1){
        return lists[0];//*lists[listsSize] æŠ¥é”™ä¸ºä»€ä¹ˆ
    }else if(listsSize == 2){
        return _twoListMerge(lists[0], lists[1]);
    }
    
    struct ListNode *l1 = _mergeKLists(&lists[0], (listsSize+1)/2);
    struct ListNode *l2 = _mergeKLists(&lists[(listsSize+1)/2], listsSize-(listsSize+1)/2);
    
    return _twoListMerge(l1, l2);
}

struct ListNode* mergeKLists(struct ListNode** lists, int listsSize){
    return _mergeKLists(lists, listsSize);
}
```




<br/><br/>

> <h2 id='åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨'>åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨</h2>

å°†ä¸¤ä¸ªå‡åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ å‡åº é“¾è¡¨å¹¶è¿”å›ã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚Â Â 

ç¤ºä¾‹ 1ï¼š

![c0_66.jpg](./../Pictures/c0_66.jpg)



```
è¾“å…¥ï¼šl1 = [1,2,4], l2 = [1,3,4]
è¾“å‡ºï¼š[1,1,2,3,4,4]
```

ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šl1 = [], l2 = []
è¾“å‡ºï¼š[]
```

ç¤ºä¾‹ 3ï¼š

```
è¾“å…¥ï¼šl1 = [], l2 = [0]
è¾“å‡ºï¼š[0]
```




```
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){
    struct ListNode *tmp = (struct ListNode*)malloc(sizeof(struct ListNode));
    tmp->next = NULL;
    tmp->val = 0;
    struct ListNode *head = tmp;

    while(list1 && list2){
        if(list1->val < list2->val){
            tmp->next = list1;
            list1 = list1->next;
            tmp = tmp->next;
        }else{
            tmp->next = list2;
            list2 = list2->next;
            tmp=tmp->next;
        }
    }
    tmp->next = list1 ? list1 : list2;

    return head->next;
}



///è°ƒç”¨
+ (void)testMergeTwoLists {
    
    int list[]={1, 2, 4};
    int list1[]={1, 3, 4};
    int listLength = sizeof(list)/sizeof(int);
    int list1Length =sizeof(list1)/sizeof(int);;
    
    struct ListNode *head = (struct ListNode*)malloc(sizeof(struct ListNode));
    head->val = list[0];
    head->next = NULL;
    
    struct ListNode* node = head;
    node->next = NULL;
    
    for (int i = 1; i < listLength; i ++) {
        struct ListNode* addNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        addNode->val = list[i];
        addNode->next = NULL;
        
        node->next = addNode;
        node = addNode;
    }
    
    
    struct ListNode *head1 = (struct ListNode*)malloc(sizeof(struct ListNode));
    head1->val = list1[0];
    head1->next = NULL;
    
    struct ListNode* node1 = head1;
    node1->next = NULL;
    
    for (int i = 1; i < list1Length; i ++) {
        struct ListNode* addNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        addNode->val = list1[i];
        addNode->next = NULL;
        
        node1->next = addNode;
        node1 = addNode;
    }
    
    
    
   struct ListNode* resultNode = mergeTwoLists(head, head1);
    while (resultNode) {
        println("%d", resultNode->val);
        resultNode=resultNode->next;
    }
}
```

Log:

```
ğŸŒ·ğŸŒ¹(May  8 2023:21:02:27 [154è¡Œ] +[HGTestAlgorithm testMergeTwoLists]) 1
ğŸŒ·ğŸŒ¹(May  8 2023:21:02:27 [154è¡Œ] +[HGTestAlgorithm testMergeTwoLists]) 1
ğŸŒ·ğŸŒ¹(May  8 2023:21:02:27 [154è¡Œ] +[HGTestAlgorithm testMergeTwoLists]) 2
ğŸŒ·ğŸŒ¹(May  8 2023:21:02:27 [154è¡Œ] +[HGTestAlgorithm testMergeTwoLists]) 3
ğŸŒ·ğŸŒ¹(May  8 2023:21:02:27 [154è¡Œ] +[HGTestAlgorithm testMergeTwoLists]) 4
ğŸŒ·ğŸŒ¹(May  8 2023:21:02:27 [154è¡Œ] +[HGTestAlgorithm testMergeTwoLists]) 4
```



<br/>

***
<br/><br/>


> <h1 id='æ ˆä¸é˜Ÿåˆ—'>æ ˆä¸é˜Ÿåˆ—</h1>

<br/><br/>

>## <h2 id='æœ‰æ•ˆçš„æ‹¬å·'>[æœ‰æ•ˆçš„æ‹¬å·](https://www.bilibili.com/video/BV1AF411w78g/)</h2>


ç»™å®šä¸€ä¸ªåªåŒ…æ‹¬ '('ï¼Œ')'ï¼Œ'{'ï¼Œ'}'ï¼Œ'['ï¼Œ']'Â çš„å­—ç¬¦ä¸² s ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆã€‚

æœ‰æ•ˆå­—ç¬¦ä¸²éœ€æ»¡è¶³ï¼š

- å·¦æ‹¬å·å¿…é¡»ç”¨ç›¸åŒç±»å‹çš„å³æ‹¬å·é—­åˆã€‚
- å·¦æ‹¬å·å¿…é¡»ä»¥æ­£ç¡®çš„é¡ºåºé—­åˆã€‚
- æ¯ä¸ªå³æ‹¬å·éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ç›¸åŒç±»å‹çš„å·¦æ‹¬å·ã€‚
Â 

ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šs = "()"
è¾“å‡ºï¼štrue
```


ç¤ºä¾‹Â 2ï¼š

```
è¾“å…¥ï¼šs = "()[]{}"
è¾“å‡ºï¼štrue
```

ç¤ºä¾‹Â 3ï¼š

```
è¾“å…¥ï¼šs = "(]"
è¾“å‡ºï¼šfalse
```


å¼€å§‹çœ‹åˆ°è¿™ä¸ªé¢˜ç›®ï¼Œæˆ‘éƒ½æ‡µäº†ï¼Œä¸çŸ¥é“ä»å“ªä¸‹æ‰‹ï¼æ‰€ä»¥ä¸‹é¢åˆ†æä¸‹ï¼Œå¤§ç¥çš„æ€è·¯ï¼š

ç”±äºæ ˆç»“æ„çš„ç‰¹æ®Šæ€§ï¼Œéå¸¸é€‚åˆåšå¯¹ç§°åŒ¹é…ç±»çš„é¢˜ç›®ã€‚

é¦–å…ˆè¦å¼„æ¸…æ¥šï¼Œå­—ç¬¦ä¸²é‡Œçš„æ‹¬å·ä¸åŒ¹é…æœ‰å‡ ç§æƒ…å†µã€‚

ä¸€äº›åŒå­¦ï¼Œåœ¨é¢è¯•ä¸­çœ‹åˆ°è¿™ç§é¢˜ç›®ä¸Šæ¥å°±å¼€å§‹å†™ä»£ç ï¼Œç„¶åå°±è¶Šå†™è¶Šä¹±ã€‚

å»ºè®®åœ¨å†™ä»£ç ä¹‹å‰è¦åˆ†æå¥½æœ‰å“ªå‡ ç§ä¸åŒ¹é…çš„æƒ…å†µï¼Œå¦‚æœä¸åœ¨åŠ¨æ‰‹ä¹‹å‰åˆ†æå¥½ï¼Œå†™å‡ºçš„ä»£ç ä¹Ÿä¼šæœ‰å¾ˆå¤šé—®é¢˜ã€‚

å…ˆæ¥åˆ†æä¸€ä¸‹ è¿™é‡Œæœ‰ä¸‰ç§ä¸åŒ¹é…çš„æƒ…å†µï¼Œ

ç¬¬ä¸€ç§æƒ…å†µï¼Œå­—ç¬¦ä¸²é‡Œå·¦æ–¹å‘çš„æ‹¬å·å¤šä½™äº† ï¼Œæ‰€ä»¥ä¸åŒ¹é…ã€‚ 

![c0_66.png](./../Pictures/c0_66.png)


ç¬¬äºŒç§æƒ…å†µï¼Œæ‹¬å·æ²¡æœ‰å¤šä½™ï¼Œä½†æ˜¯ æ‹¬å·çš„ç±»å‹æ²¡æœ‰åŒ¹é…ä¸Šã€‚ 

![c0_69.png](./../Pictures/c0_69.png)


ç¬¬ä¸‰ç§æƒ…å†µï¼Œå­—ç¬¦ä¸²é‡Œå³æ–¹å‘çš„æ‹¬å·å¤šä½™äº†ï¼Œæ‰€ä»¥ä¸åŒ¹é…ã€‚

![c0_68.png](./../Pictures/c0_68.png)


æˆ‘ä»¬çš„ä»£ç åªè¦è¦†ç›–äº†è¿™ä¸‰ç§ä¸åŒ¹é…çš„æƒ…å†µï¼Œå°±ä¸ä¼šå‡ºé—®é¢˜ï¼Œå¯ä»¥çœ‹å‡º åŠ¨æ‰‹ä¹‹å‰åˆ†æå¥½é¢˜ç›®çš„é‡è¦æ€§ã€‚

åŠ¨ç”»å¦‚ä¸‹ï¼š

![c0_67.gif](./../Pictures/c0_67.gif)


ç¬¬ä¸€ç§æƒ…å†µï¼šå·²ç»éå†å®Œäº†å­—ç¬¦ä¸²ï¼Œä½†æ˜¯æ ˆä¸ä¸ºç©ºï¼Œè¯´æ˜æœ‰ç›¸åº”çš„å·¦æ‹¬å·æ²¡æœ‰å³æ‹¬å·æ¥åŒ¹é…ï¼Œæ‰€ä»¥return false

ç¬¬äºŒç§æƒ…å†µï¼šéå†å­—ç¬¦ä¸²åŒ¹é…çš„è¿‡ç¨‹ä¸­ï¼Œå‘ç°æ ˆé‡Œæ²¡æœ‰è¦åŒ¹é…çš„å­—ç¬¦ã€‚æ‰€ä»¥return false

ç¬¬ä¸‰ç§æƒ…å†µï¼šéå†å­—ç¬¦ä¸²åŒ¹é…çš„è¿‡ç¨‹ä¸­ï¼Œæ ˆå·²ç»ä¸ºç©ºäº†ï¼Œæ²¡æœ‰åŒ¹é…çš„å­—ç¬¦äº†ï¼Œè¯´æ˜å³æ‹¬å·æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„å·¦æ‹¬å·return false

é‚£ä¹ˆä»€ä¹ˆæ—¶å€™è¯´æ˜å·¦æ‹¬å·å’Œå³æ‹¬å·å…¨éƒ½åŒ¹é…äº†å‘¢ï¼Œå°±æ˜¯å­—ç¬¦ä¸²éå†å®Œä¹‹åï¼Œæ ˆæ˜¯ç©ºçš„ï¼Œå°±è¯´æ˜å…¨éƒ½åŒ¹é…äº†ã€‚



<br/>


**Code**

```
//è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ ˆé¡¶å…ƒç´ ä¸è¾“å…¥çš„æ‹¬å·æ˜¯å¦ä¸ºä¸€å¯¹ã€‚è‹¥ä¸æ˜¯ï¼Œåˆ™è¿”å›False
int isMatchKuoHao(int top, char kuoHao, char *stack) {
   
    int isMatch = 0;

    switch(kuoHao){
        case ')':
            isMatch = stack[top-1] != '(';//è¯´æ˜æ ˆé¡¶å…ƒç´ å’Œæ¯”è¾ƒçš„ç¬¦å·æ˜¯åŒ¹é…çš„
            return isMatch;
            break;
        case ']':
            isMatch = stack[top-1] != '[';
            return isMatch;
            break;
        case '}':
            isMatch = stack[top-1] != '{';
            return isMatch;
        break;

    }

    return isMatch;
}

int isValid(char * s){

    int length = (int)strlen(s);//"([{}]()"
    char charStack[5000];//è®¾ç½®ä¸º5000ï¼Œè®¾ç½®ä¸º500ä¼šå¯¼è‡´leetcodeå‡ºé”™ï¼Œå› ä¸ºleetCodeçš„å…ƒç´ è¿œæ¯”è¿™å¤§
    int topP = 0;

    //éå†å­—ç¬¦ä¸²
    for(int i=0; i< length; i++){
        //å–å‡ºå½“å‰ä¸‹æ ‡æ‰€å¯¹åº”å­—ç¬¦
        char kuoHao = s[i];

        //è‹¥å½“å‰å­—ç¬¦ä¸ºå·¦æ‹¬å·ï¼Œåˆ™å…¥æ ˆ
        if(kuoHao == '(' || kuoHao == '[' ||
           kuoHao == '{') {
               charStack[topP++]= kuoHao;//æ³¨æ„ï¼štopP++å’Œ++topPçš„åŒºåˆ«ï¼Œç¬¬ä¸€æ¬¡ä¸­æ‹¬å·å†…çš„topP++æ˜¯0ï¼Œè€Œç¬¬ä¸€æ¬¡ä¸­æ‹¬å·å†…çš„++topPæ˜¯1
        }else if(topP == 0 || isMatchKuoHao(topP, kuoHao, charStack)){//è‹¥å½“å‰å­—ç¬¦ä¸ºå³æ‹¬å·ï¼Œä¸”æ ˆä¸­æ— å…ƒç´ æˆ–å³æ‹¬å·ä¸æ ˆé¡¶å…ƒç´ ä¸ç¬¦ï¼Œè¿”å›False
            return 0;
        }else{//å½“å‰å­—ç¬¦ä¸æ ˆé¡¶å…ƒç´ ä¸ºä¸€å¯¹æ‹¬å·ï¼Œå°†æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
            charStack[topP-1]= '\0';//åˆ é™¤çš„å…ƒç´ ç½®ä¸ºç©º
            topP--;
        }
    }
    
    //è‹¥æ ˆä¸­æœ‰å…ƒç´ ï¼Œè¿”å›Falseã€‚è‹¥æ²¡æœ‰å…ƒç´ ï¼ˆstackTopä¸º0ï¼‰ï¼Œè¿”å›True
    return !topP;
}





+ (void)testIsValid {
//    char *charStr = "([{}]()";//å­—ç¬¦ä¸²å¯ä»¥è¿™æ ·è®¾ç½®
//    char charStr[] = "([{}]()";
    char charStr[] = {'(', '[', '{', ']', '(', ')'};
    
    bool isMatch = isValid(charStr);
    println("æ‹¬å·å­—ç¬¦ä¸²%s", isMatch ? "åŒ¹é…" : "ä¸åŒ¹é…");
}
```

**Log:**

```
ğŸŒ·ğŸŒ¹(May  5 2023:23:46:08 [115è¡Œ] +[HGTestAlgorithm testIsValid]) æ‹¬å·å­—ç¬¦ä¸²ä¸åŒ¹é…
```



<br/><br/>


> <h2 id='æœ€é•¿æœ‰æ•ˆæ‹¬å·'>æœ€é•¿æœ‰æ•ˆæ‹¬å·</h2>


ç»™ä½ ä¸€ä¸ªåªåŒ…å« '('Â å’Œ ')'Â çš„å­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºæœ€é•¿æœ‰æ•ˆï¼ˆæ ¼å¼æ­£ç¡®ä¸”è¿ç»­ï¼‰æ‹¬å·å­ä¸²çš„é•¿åº¦ã€‚

Â 

ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šs = "(()"
è¾“å‡ºï¼š2
è§£é‡Šï¼šæœ€é•¿æœ‰æ•ˆæ‹¬å·å­ä¸²æ˜¯ "()"
```


ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šs = ")()())"
è¾“å‡ºï¼š4
è§£é‡Šï¼šæœ€é•¿æœ‰æ•ˆæ‹¬å·å­ä¸²æ˜¯ "()()"
```

ç¤ºä¾‹ 3ï¼š

```
è¾“å…¥ï¼šs = ""
è¾“å‡ºï¼š0
```


**Code**

```
```

**Log:**

```
```




<br/>
<br/>


> <h2 id="ä¸¤æ•°ä¹‹å’Œ">ä¸¤æ•°ä¹‹å’Œ</h2>

```
ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ numsÂ å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ çš„é‚£Â ä¸¤ä¸ªÂ æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚

ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ åœ¨ç­”æ¡ˆé‡Œä¸èƒ½é‡å¤å‡ºç°ã€‚

ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚


ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šnums = [2,7,11,15], target = 9
è¾“å‡ºï¼š[0,1]
è§£é‡Šï¼šå› ä¸º nums[0] + nums[1] == 9 ï¼Œè¿”å› [0, 1] ã€‚
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šnums = [3,2,4], target = 6
è¾“å‡ºï¼š[1,2]
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šnums = [3,3], target = 6
è¾“å‡ºï¼š[0,1]

```

ç­”æ¡ˆCodeï¼š

**C++ ä»£ç **

```

vector<int> twoSum(vector<int>& nums, int target) {
    vector<int> backNums = vector<int>();

    
    for (int i = 0; i < nums.size(); i ++) {
        for (int j = i +1; j < nums.size(); j ++) {
            if (nums[i] + nums[j] == target) {
                backNums.push_back(i);
                backNums.push_back(j);
                return backNums;;
            }
        }
    }
    
    
    
    
    return  backNums;
    
};



int main(int argc, const char * argv[]) {
    
    
    //vector<int> vec1{2,7,11,15};
    vector<int> vec1{0,4,3,0};
    twoSum(vec1, 3);
}

```


<br/>

**C ä»£ç **


```
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    int *sum= NULL;
    for(int i = 0; i < numsSize-1; i++){
        for(int j= i+1; j < numsSize; j++){
            if(target == nums[i]+nums[j]){
                sum = (int *)malloc(sizeof(int) *2);
                *returnSize = 2;
                sum[0]= i;
                sum[1]=j;
                return sum;
            }
        }
    }
    return sum;
}

//è°ƒç”¨
int nums [4] = {2, 7, 11, 15};
int returnSize = 2;
int *returnArr = twoSum(nums, 4, 9, &returnSize);
printArr(returnArr, 2);//å®å®šä¹‰
```

æ‰“å°:

```
ğŸŒ·ğŸŒ¹ 18:41:00 [49è¡Œ] +[HGTestAlgorithm testLeetcodeAlgorithmModule:]=> 00 01 
```


<br/>
<br/>


> <h2 id= "ä¸¤æ•°ç›¸åŠ ">ä¸¤æ•°ç›¸åŠ </h2>

```
ç»™ä½ ä¸¤ä¸ªÂ éç©º çš„é“¾è¡¨ï¼Œè¡¨ç¤ºä¸¤ä¸ªéè´Ÿçš„æ•´æ•°ã€‚å®ƒä»¬æ¯ä½æ•°å­—éƒ½æ˜¯æŒ‰ç…§Â é€†åºÂ çš„æ–¹å¼å­˜å‚¨çš„ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨Â ä¸€ä½Â æ•°å­—ã€‚

è¯·ä½ å°†ä¸¤ä¸ªæ•°ç›¸åŠ ï¼Œå¹¶ä»¥ç›¸åŒå½¢å¼è¿”å›ä¸€ä¸ªè¡¨ç¤ºå’Œçš„é“¾è¡¨ã€‚

ä½ å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°éƒ½ä¸ä¼šä»¥ 0Â å¼€å¤´ã€‚



ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šl1 = [2,4,3], l2 = [5,6,4]
è¾“å‡ºï¼š[7,0,8]
è§£é‡Šï¼š342 + 465 = 807.


ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šl1 = [0], l2 = [0]
è¾“å‡ºï¼š[0]


ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šl1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
è¾“å‡ºï¼š[8,9,9,9,0,0,0,1]
```



<br/>



```
typedef struct ListNode {
    int value;
    ListNode *next;
}ListNode;

ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode *sumList = (ListNode *)malloc(sizeof(ListNode));
    sumList->next = NULL;
    sumList->value = 0;
    
    ListNode *tempP = sumList;
    
    //2æ•°åŠ ä¹‹å’Œ
    int sum = 0;
    //è¿›ä½ç‚¹
    int carry = 0;
    //è¿›ä½ä»¥åçš„å€¼
    int singleValue = 0;
    while (l1 || l2) {
    
		//é”™è¯¯ï¼šint value1 = l1->next == NULL ? 0 : l1->value;ä¼šå¯¼è‡´æœ€åçš„æ— æ³•å–åˆ°å€¼ï¼Œä¸€ç›´ä¸º0äº†
        int value1 = l1 == NULL ? 0 : l1->value;
        int value2 = l2 == NULL ? 0 : l2->value;
        
        sum = value1 + value2 + carry;
        carry = sum / 10;
        singleValue = sum % 10;
        
        ListNode *insertNode = (ListNode *)malloc(sizeof(ListNode));
        insertNode->next = NULL;
        insertNode->value = singleValue;
        tempP->next = insertNode;
        
        tempP = insertNode;
        
        if (l1) {
            l1 = l1->next;
        }
        if (l2) {
            l2 = l2->next;
        }
    }
    
    if (carry > 0) {
        ListNode *insertNode = (ListNode *)malloc(sizeof(ListNode));
        insertNode->next = NULL;
        insertNode->value = carry;
        tempP->next = insertNode;
    }
    
    //è¿”å›ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªå€¼æ²¡æœ‰è®¾ä»»ä½•å€¼
    return sumList->next;

};




int main(int argc, const char * argv[]) {
    ListNode *insertNode1 = (ListNode *)malloc(sizeof(ListNode));
    insertNode1->next = NULL;
    insertNode1->value = 2;
    
    ListNode *insertNode2 = (ListNode *)malloc(sizeof(ListNode));
    insertNode2->next = NULL;
    insertNode2->value = 4;
    insertNode1->next = insertNode2;
    
    
    ListNode *insertNode3 = (ListNode *)malloc(sizeof(ListNode));
    insertNode3->next = NULL;
    insertNode3->value = 3;
    insertNode2->next = insertNode3;
    
    
    
    
    
    ListNode *node1 = (ListNode *)malloc(sizeof(ListNode));
    node1->next = NULL;
    node1->value = 5;
    
    ListNode *node2 = (ListNode *)malloc(sizeof(ListNode));
    node2->next = NULL;
    node2->value = 6;
    node1->next = node2;
    
    
    ListNode *node3 = (ListNode *)malloc(sizeof(ListNode));
    node3->next = NULL;
    node3->value = 4;
    node2->next = node3;
    
    
    ListNode *sumNode = addTwoNumbers(insertNode1, node1);
    
    while (sumNode != NULL) {
        printf("%d", sumNode->value);
        sumNode = sumNode->next;
    }
    
    
   
}
```

æ‰“å°ï¼š`708`

&emsp; å› ä¸ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹é“¾è¡¨æ˜¯:2, 4, 3
	
&emsp; ç¬¬äºŒä¸ªèŠ‚ç‚¹é“¾è¡¨æ˜¯: 5, 6, 4	

æ‰€ä»¥æ‰“å°ä¸º: 807 æ‰å¯¹


<br/>
<br/>




**Cè¯­è¨€-é€’å½’è§£å†³æ³•**

```
struct ListNode {
      int val;
      struct ListNode *next;
};

void get_sum(struct ListNode *pre, struct ListNode* l1, struct ListNode* l2, int carry ){
    if (!l1 && !l2 && !carry) {
        return;
    }//é€’å½’è¾¹ç•Œï¼šä¸‰è€…å‡ä¸ºé›¶ï¼ˆæˆ–æŒ‡é’ˆä¸ºç©ºï¼‰æ—¶åˆ™é€’å½’åœæ­¢
    
    struct ListNode *node = (struct ListNode *)malloc(sizeof(struct ListNode));
    node->next = NULL;//å¿˜äº†åŠ è¿™ä¸ªåœ¨leetcodeä¼šæŠ¥é”™,ä½†æ˜¯çœŸæ­£è¿è¡Œæ—¶å¹¶ä¸ä¼šæŠ¥é”™.ä½†æ˜¯åœ¨æ‰“å°è¿™ä¸ªé“¾è¡¨æ—¶ä¼šæŠ¥é”™
    
    int n1 = l1 ? l1->val : 0;//è‹¥l1å­˜åœ¨åˆ™å–å…¶èŠ‚ç‚¹å€¼ï¼Œå¦åˆ™ä¸º0ï¼›
    int n2 = l2 ? l2->val : 0;//è‹¥l2å­˜åœ¨åˆ™å–å…¶èŠ‚ç‚¹å€¼ï¼Œå¦åˆ™ä¸º0ï¼›
    int sum = carry + n1 + n2;
    carry = sum / 10;//æ›´æ–°è¿›ä½å€¼ï¼›
    node->val = sum % 10;//ä¸ºå½“å‰æ–°èŠ‚ç‚¹èµ‹å€¼ï¼›
    pre->next = node;//å°†æ–°èŠ‚ç‚¹æ”¾ç½®äºå‰é©±èŠ‚ç‚¹ä¹‹åï¼›
    
    l1 = l1 ? l1->next : NULL;//æ›´æ–°l1è‡³åç»§èŠ‚ç‚¹ï¼›
    l2 = l2 ? l2->next : NULL;//æ›´æ–°l2è‡³åç»§èŠ‚ç‚¹ï¼›
    
    get_sum(node, l1, l2, carry);//è°ƒç”¨è‡ªèº«è¿›è¡Œé€’å½’ï¼›
}


struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    //[2, 4, 3]
    struct ListNode *l1_0 = (struct ListNode *)malloc(sizeof(struct ListNode));
    l1_0->val = 2;
    struct ListNode *l1_1 = (struct ListNode *)malloc(sizeof(struct ListNode));
    l1_1->val = 4;
    struct ListNode *l1_2 = (struct ListNode *)malloc(sizeof(struct ListNode));
    l1_2->val = 3;
    l1_2->next = NULL;
    
    l1_0->next = l1_1;
    l1_1->next = l1_2;
    
    //[5, 6, 4]
    struct ListNode *l2_0 = (struct ListNode *)malloc(sizeof(struct ListNode));
    l2_0->val = 5;
    struct ListNode *l2_1 = (struct ListNode *)malloc(sizeof(struct ListNode));
    l2_1->val = 6;
    struct ListNode *l2_2 = (struct ListNode *)malloc(sizeof(struct ListNode));
    l2_2->val = 4;
    l2_2->next = NULL;//è¦åŠ ,å¦åˆ™è¿è¡ŒæŠ¥é”™,å› ä¸ºä¸çŸ¥é“ä»€ä¹ˆæ—¶å€™ç»“æŸ,è¿™ä¸ªå¯ä»¥ä½œä¸ºåˆ¤æ–­é“¾è¡¨ç»“æŸæ—¶çš„æ¡ä»¶
    
    l2_0->next =l2_1;
    l2_1->next = l2_2;
    
    l1 = l1_0;
    l2 = l2_0;

    
    
    int carry = 0;//æ•°å€¼ç›¸åŠ åçš„è¿›ä½å€¼,æ¯”å¦‚8+9 = 17,è¿›ä½1
    struct ListNode *headNode = (struct ListNode *)malloc(sizeof(struct ListNode));
    headNode->val = 0; // å¿˜äº†è¿™ä¸ª éœ€è¦åˆå§‹åŒ–èµ‹å€¼
    //å¿…é¡»è¦åˆå§‹åŒ–,åŸå› : åœ¨è®¿é—®æŸä¸ªå˜é‡æ—¶ï¼Œå› ä¸ºè¿™ä¸ªå˜é‡ä¸­å«æœ‰æœªèµ‹å€¼çš„æŒ‡é’ˆã€‚å®šä¹‰ä½†æ˜¯ä¸èµ‹å€¼çš„æŒ‡é’ˆå«åšé‡æŒ‡é’ˆã€‚
    //é‡æŒ‡é’ˆæŒ‡å‘ä¸æ˜ï¼Œå¯¹ç¨‹åºæœ‰ä¸å¯çŸ¥çš„åæœï¼Œå¼•ç”¨äº†æ›´æ˜¯å‡ºå¤§é—®é¢˜ï¼Œæ‰€ä»¥ï¼Œcè¯­è¨€ä¸¥æ ¼åå¯¹é‡æŒ‡é’ˆ
    headNode->next = NULL; // å¿˜äº†è¿™ä¸ª éœ€è¦åˆå§‹åŒ–èµ‹å€¼
    
    get_sum(headNode, l1, l2, carry);
    
    
    struct ListNode *node = headNode->next;
    while (node) {
        println("%d", node->val);
        node = node->next;
    }
    
    return headNode->next;
}

//è°ƒç”¨
addTwoNumbers(NULL, NULL);
```

æ‰“å°:

```
ğŸŒ·ğŸŒ¹(Mar 20 2023:18:51:45 [77è¡Œ] addTwoNumbers) 7
ğŸŒ·ğŸŒ¹(Mar 20 2023:18:51:45 [77è¡Œ] addTwoNumbers) 0
ğŸŒ·ğŸŒ¹(Mar 20 2023:18:51:45 [77è¡Œ] addTwoNumbers) 8
```



<br/>
<br/>


> <h2 id="æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²">æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²</h2>

```
ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„Â æœ€é•¿å­ä¸²Â çš„é•¿åº¦ã€‚

Â 

ç¤ºä¾‹Â 1:
è¾“å…¥: s = "abcabcbb"
è¾“å‡º: 3 
è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "abc"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚


ç¤ºä¾‹ 2:
è¾“å…¥: s = "bbbbb"
è¾“å‡º: 1
è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "b"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 1ã€‚


ç¤ºä¾‹ 3:
è¾“å…¥: s = "pwwkew"
è¾“å‡º: 3
è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯Â "wke"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚
Â     è¯·æ³¨æ„ï¼Œä½ çš„ç­”æ¡ˆå¿…é¡»æ˜¯ å­ä¸² çš„é•¿åº¦ï¼Œ"pwke"Â æ˜¯ä¸€ä¸ªå­åºåˆ—ï¼Œä¸æ˜¯å­ä¸²ã€‚


ç¤ºä¾‹ 4:
è¾“å…¥: s = ""
è¾“å‡º: 0
```


è§£é¢˜æ€è·¯:

![c0_31.png](./../Pictures/c0_31.png)

<br/>


**C++è§£ç­”Code:**

```

int lengthOfLongestSubstring(string methodName, string s) {
    printf("\n=================%s=================\n", methodName.c_str());
    int max = 0;
    int head = 0;
    int tail = 0;
    
    //size()è®¡ç®—stringçš„é•¿åº¦ï¼Œstrlenè®¡ç®—å­—ç¬¦çš„é•¿åº¦
    size_t length = s.size();
    
    while (tail < length) {
        //headæŒ‡å‘å¤´ï¼Œè‹¥æ˜¯æ²¡æœ‰é‡åˆ°ç›¸åŒçš„å®ƒä¼šä¸€ç›´æŒ‡çª—å£ç¬¬ä¸€ä¸ªå­—ç¬¦
        for (int i = head; i < tail; i++) {
            if (s[i] == s[tail]) {
                max = max > tail - head ? max : tail - head;
                //é‡åˆ°ç›¸åŒçš„äº†ï¼Œçª—å£è¦å‘åç§»åŠ¨ä¸€æ ¼ï¼Œé€€å‡ºæœ¬æ¬¡å¾ªç¯ã€‚å‡å°‘å¾ªç¯
                //è€Œä¸”ä¹‹å‰è¿˜å¾ªç¯è¿‡äº†ï¼Œæ²¡å¿…è¦å†æ¬¡å¾ªç¯ä¸€é
                head = i + 1;
                break;
            }
        }
        
        tail++;
        //å½“å­—ç¬¦ä¸²åªæœ‰ä¸€ä¸ªå­—ç¬¦æ—¶ï¼Œè‹¥æ²¡æœ‰è¿™æ®µä»£ç ä¼šå‡ºé”™çš„ï¼Œä¸€ä¸ªå®ƒæ²¡æ³•è®¡ç®—
        max = max > tail - head ? max : tail - head;

    }
    
    return  max;
}




int main(int argc, const char * argv[]) {
    
    string str = "abcabcbb";
    string str1 = "bbbbb";
    string str2 = "pwwkew";
    string str3 = "lengthOfLongestSubstring";
    string str4 = "c";

    
    int sum = lengthOfLongestSubstring("æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²", str);
    printf("\n é•¿åº¦ä¸ºï¼š %i\n", sum);
}
```

æ‰“å°ï¼š

```
=================æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²=================

 é•¿åº¦ä¸ºï¼š 3
```

<br/>

**Cè¯­è¨€è§£ç­”code**

```
int lengthOfLongestSubstring(char * s){
    unsigned long length = strlen(s);
    int head = 0;
    int tail = 0;
    int max = 0;

    while (tail < length){
       for(int i = head; i < tail; i++){
           if(s[i] == s[tail]){
               head = i+1;//çª—å£å·¦è¾¹ç§»åŠ¨ä¸€æ ¼,æ³¨æ„ä¸æ˜¯: head  +=1;è¿™ä¸æ˜¯æŒ‰ç…§ç›®å‰çš„çª—å£è¿›è¡ŒåŠ 1,è€Œæ˜¯æ•´ä¸ªæ•°ç»„äº†,æ‰€ä»¥ä¸è¡Œ
               break;
           }
       }
       tail +=1;//çª—å£å³è¾¹ç§»åŠ¨ä¸€æ ¼
       max = max > (tail - head) ? max : (tail - head);
   }
    
    println("é•¿åº¦æ˜¯: %d", max);
    
    return max;
}



//è°ƒç”¨
char *s = "pwwkew";
//char *s = "abcabcbb";
lengthOfLongestSubstring(s);

```


æ‰“å°:

```
ğŸŒ·ğŸŒ¹(Mar 25 2023:10:55:27 [29è¡Œ] lengthOfLongestSubstring) é•¿åº¦æ˜¯: 3
```

<br/>
<br/>


> <h2 id="å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°">å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°</h2>

```

ç»™å®šä¸¤ä¸ªå¤§å°åˆ†åˆ«ä¸º m å’Œ n çš„æ­£åºï¼ˆä»å°åˆ°å¤§ï¼‰æ•°ç»„Â nums1 å’ŒÂ nums2ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›è¿™ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ ä¸­ä½æ•° ã€‚

Â 

ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šnums1 = [1,3], nums2 = [2]
è¾“å‡ºï¼š2.00000
è§£é‡Šï¼šåˆå¹¶æ•°ç»„ = [1,2,3] ï¼Œä¸­ä½æ•° 2

ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šnums1 = [1,2], nums2 = [3,4]
è¾“å‡ºï¼š2.50000
è§£é‡Šï¼šåˆå¹¶æ•°ç»„ = [1,2,3,4] ï¼Œä¸­ä½æ•° (2 + 3) / 2 = 2.5

ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šnums1 = [0,0], nums2 = [0,0]
è¾“å‡ºï¼š0.00000

ç¤ºä¾‹ 4ï¼š
è¾“å…¥ï¼šnums1 = [], nums2 = [1]
è¾“å‡ºï¼š1.00000

ç¤ºä¾‹ 5ï¼š
è¾“å…¥ï¼šnums1 = [2], nums2 = []
è¾“å‡ºï¼š2.00000
```

<br/>


**C++ç­”æ¡ˆCodeï¼š**

```
double findMedianSortedArrays(string methodName,vector<int>& nums1, vector<int>& nums2) {
    printf("\n=================%s=================\n", methodName.c_str());
    
    size_t length1 = nums1.size();
    size_t length2 = nums2.size();
    
    if (length1 == 0 && length2 == 0) {
        return  0;
    }else if (length1 == 0 && length2 > 0){
        //åŠ  length2 != 1 è¿™ä¸ªåˆ¤æ–­æ˜¯é˜²æ­¢æ•°ç»„ä¸­åªæœ‰ä¸€ä¸ªå…ƒç´ æ—¶å‡ºé”™
        if (length2 % 2 != 0 && length2 != 1) {
            int middle = length2 / 2;
            double a = (nums2[middle] + nums2[middle+1])/2.0;
            return a;
        }else {
            int middle = length2 / 2;
            
            return  nums2[middle];
        }
        
    }else if (length1 > 0 && length2 == 0) {
        if (length1 % 2 != 0 && length1 != 1) {
            int middle = length1 / 2;
            double a = (nums1[middle] + nums1[middle+1])/2.0;
            return a;
        }else {
            int middle = length2 / 2;
            
            return  nums1[middle];
        }
    }else {
        int tag1 = 0;
        int tag2 = 0;
        vector<int> sums = vector<int>();
        
        while (tag1 < length1 || tag2 < length2 ) {
            //tag1 < length1 åŠ è¿™ä¸ªåˆ¤æ–­æ˜¯ä¸ºäº†é˜²æ­¢å³ä½¿num1æ•°ç»„åŠ å®Œäº†ä»ç„¶åœ¨sumsä¸­æ·»åŠ å…ƒç´ é€ æˆæ­»å¾ªç¯ã€‚ç¨‹åºå´©æºƒäº†ã€‚
            if (nums1[tag1] < nums2[tag2] && tag1 < length1) {
                sums.push_back(nums1[tag1]);
                if (tag1 < length1) {
                    ++tag1;
                }
                
            }else if (nums1[tag1] > nums2[tag2] && tag2 < length2) {
                sums.push_back(nums2[tag2]);
                if (tag2 < length2) {
                    ++tag2;
                }
            }else {
                
                if (tag2 < length2) {
                    //ä¹‹æ‰€ä»¥è¦åŠ ä¸€ä¸ªåˆ¤æ–­ï¼Œé˜²æ­¢å³ä½¿æ•°ç»„è¶Šç•Œä»ç„¶å¯ä»¥æ·»åŠ å…ƒç´ ï¼Œé‚£ç»“æœå°±ä¸å¯¹äº†
                    sums.push_back(nums2[tag2]);
                    ++tag2;
                }
                if (tag1 < length1) {
                    sums.push_back(nums1[tag1]);
                    ++tag1;
                }
            }
        }
        
        int sumLength = sums.size();
        if(sumLength % 2 == 0) {
            int middle = length2 / 2;
            
            return  nums1[middle];
            
        }else {
            int middle = sumLength / 2;
            double a = (sums[middle] + sums[middle+1])/2.0;
            
            return a;
        }
    }
    
    
    
    return  0.0;
}



int main(int argc, const char * argv[]) {
    
    vector<int> nums1 = {1,3}, nums2 = {2};
    //    vector<int> nums1 = {0,0}, nums2 = {0,0};
    //    vector<int> nums1 = {}, nums2 = {};
    //    vector<int> nums1 = {1}, nums2 = {};
    //    vector<int> nums1 = {2}, nums2 = {};
    
    
    
    double c = findMedianSortedArrays("å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°", nums1, nums2);
    printf("ä¸­ä½æ•°ä¸ºï¼š %f", c);
}

```

æ‰“å°ï¼š

```
=================å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°=================
ä¸­ä½æ•°ä¸ºï¼š 2.500000

```


<br/>
<br/>

è§£é¢˜æ€è·¯:


![c0_32.png](./../Pictures/c0_32.png)

**Cè¯­è¨€Code**

```
double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){
    int j = 0,k = 0;//è¦åŒæ—¶èµ‹å€¼ä¸º0,é”™è¯¯: int j, k=0;å¯¼è‡´ä¸çŸ¥é“jçš„å€¼ ,j nums1æ•°ç»„ä¸‹æ ‡å€¼, num2æ•°ç»„ä¸‹æ ‡å€¼
    double previous = 0.0,current = 0.0; //previous æŒ‡å‘å‰ä¸€ä¸ªå€¼, current æŒ‡å‘åä¸€ä¸ªå€¼
    int mid = (nums1Size + nums2Size) /2;
    
    for(int i = 0; i <= mid; i++){
        if(j < nums1Size && k < nums2Size){
            if(nums1[j]< nums2[k]){
                previous = current;
                current = nums1[j];
                j++;
                continue;
            }else {
                previous = current;
                current = nums2[k];
                k++;
                continue;
            }
        }
        
        if(k < nums2Size){
            previous = current;
            current = nums2[k];
            k++;
            continue;
        }
        
        if(j < nums1Size){
            previous = current;
            current = nums1[j];
            j++;
            continue;
        }
    }
    
    
    double medValue = 0.0;
    if(((nums1Size + nums2Size)%2) == 0){
        medValue = (previous+current)/2;
    }else{
        medValue = current;
    }
    println("ä¸­ä½æ•°:%f", medValue);
    
    return medValue;
}




//è°ƒç”¨
int num1[]={1, 2};
int num2[]={3, 4};
findMedianSortedArrays(num1, 2, num2, 2);
```

æ‰“å°å€¼:

```
ğŸŒ·ğŸŒ¹(Mar 26 2023:10:30:44 [54è¡Œ] findMedianSortedArrays) ä¸­ä½æ•°:2.500000
```


<br/>
<br/>


>## <h2 id="æœ€é•¿å›æ–‡å­ä¸²">[æœ€é•¿å›æ–‡å­ä¸²](https://writings.sh/post/algorithm-longest-palindromic-substring#äºŒç»´åŠ¨æ€è§„åˆ’æ–¹æ³•)</h2>

[åŠ¨æ€è§„åˆ’](https://blog.csdn.net/u013309870/article/details/75193592)

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œæ‰¾åˆ° s ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚


```
ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šs = "babad"
è¾“å‡ºï¼š"bab"
è§£é‡Šï¼š"aba" åŒæ ·æ˜¯ç¬¦åˆé¢˜æ„çš„ç­”æ¡ˆã€‚



ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šs = "cbbd"
è¾“å‡ºï¼š"bb"


ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šs = "a"
è¾“å‡ºï¼š"a"
ç¤ºä¾‹ 4ï¼š

è¾“å…¥ï¼šs = "ac"
è¾“å‡ºï¼š"a"


```


<br/>

è§£é¢˜æ€è·¯:


![c0_33.png](./../Pictures/c0_33.png)
![c0_34.png](./../Pictures/c0_34.png)
![c0_35.png](./../Pictures/c0_35.png)
![c0_36.png](./../Pictures/c0_36.png)

<br/>

**ä»£ç :**

```
//æœ€é•¿å›æ–‡å­ä¸²
char * longestPalindrome(char * s){
    int length = strlen(s);
    if(!s || length < 0){
        return s;
    }
    
    // dp[i][j] è¡¨ç¤º s[i..j] æ˜¯å¦å›æ–‡ï¼Œj >= i
    int dp[length][length];
    // è®°å½•æœ€å¤§å›æ–‡å­ä¸²çš„é•¿åº¦ï¼Œè‡³å°‘ä¸º 1
    int maxLength = 1, begin = 0, end = 0;
    
    // åˆå§‹åŒ–
    for(int i = 0; i<length; i++){
        for(int j = i; j <length; j++){
            dp[i][j] = 0;
        }
    }
    
    // æ˜“çŸ¥ï¼Œå•ä¸ªå­—ç¬¦ s[i..i] æ„æˆå›æ–‡
    for(int i =0; i<length; i++){
        dp[i][i]= 1;
    }
    
    // è€ƒè™‘é€’æ¨
    // ä¸»è¦çš„é€’æ¨å…³ç³»æ˜¯ dp[i][j] = dp[i+1][j-1]
    // æ‰€ä»¥å€’åºéå† i ï¼Œæ‰å¯ä»¥å½¢æˆé€’æ¨
    for(int i = length - 1; i >= 0; i--){
        for(int j = i; j < length; j++){
            if(s[i] == s[j]){
                if(j-1 >= i+1){ // å­ä¸² s[i+1..j-1] æœ‰æ•ˆæ€§
                    if(dp[i+1][j-1]){
                        dp[i][j] = 1;
                    }
                }else {
                    // æ­¤æ—¶ j < i + 2 å³ j <= i+1
                    // å†ä¹‹ s[i] == s[j]ï¼Œå¿…å›æ–‡
                    dp[i][j] = 1;
                }
            }
            
            if(dp[i][j]){
                // æ›´æ–°æœ€å¤§é•¿åº¦
                int length = j - i + 1;
                
                if( length > maxLength){
                    maxLength = length;
                    begin = i;
                    end = j;
                }
            }
        }
    }
    
    //char *sub=(char *)malloc(sizeof(int) * (maxLength * 2));
    //åˆå§‹åŒ–subï¼ŒsubæŒ‡å‘ä¸€å—10ä¸ªcharå¤§å°çš„å†…å­˜
    char *sub = (char*)malloc(sizeof(char) * maxLength);
    int i = 0;
    for( ;i<maxLength; i++){
        sub[i] = s[begin];
        begin = begin+1;
    }
    //sub[i] = '\0';
    
    return sub;
}


///è°ƒç”¨
char *charArray= "babad";
char *charArray= "cbbd";
char *a = longestPalindrome(charArray);
println("%s", a);
```

æ‰“å°:

```
ğŸŒ·ğŸŒ¹(Apr 19 2023:22:40:01 [74è¡Œ] +[HGTestAlgorithm testLeetcodeAlgorithmModule:]) bb
```







<br/>
<br/>


> <h2 id="æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…">æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…</h2>

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²Â sÂ å’Œä¸€ä¸ªå­—ç¬¦è§„å¾‹Â pï¼Œè¯·ä½ æ¥å®ç°ä¸€ä¸ªæ”¯æŒ '.'Â å’ŒÂ '*'Â çš„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ã€‚

- '.' åŒ¹é…ä»»æ„å•ä¸ªå­—ç¬¦
- '*' åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªå‰é¢çš„é‚£ä¸€ä¸ªå…ƒç´ 

æ‰€è°“åŒ¹é…ï¼Œæ˜¯è¦æ¶µç›–Â æ•´ä¸ªÂ å­—ç¬¦ä¸²Â sçš„ï¼Œè€Œä¸æ˜¯éƒ¨åˆ†å­—ç¬¦ä¸²ã€‚

Â 
ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šs = "aa", p = "a"
è¾“å‡ºï¼šfalse
è§£é‡Šï¼š"a" æ— æ³•åŒ¹é… "aa" æ•´ä¸ªå­—ç¬¦ä¸²ã€‚
```

ç¤ºä¾‹ 2:

```
è¾“å…¥ï¼šs = "aa", p = "a*"
è¾“å‡ºï¼štrue
è§£é‡Šï¼šå› ä¸º '*' ä»£è¡¨å¯ä»¥åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªå‰é¢çš„é‚£ä¸€ä¸ªå…ƒç´ , åœ¨è¿™é‡Œå‰é¢çš„å…ƒç´ å°±æ˜¯ 'a'ã€‚å› æ­¤ï¼Œå­—ç¬¦ä¸² "aa" å¯è¢«è§†ä¸º 'a' é‡å¤äº†ä¸€æ¬¡ã€‚
```

ç¤ºä¾‹Â 3ï¼š

```
è¾“å…¥ï¼šs = "ab", p = ".*"
è¾“å‡ºï¼štrue
è§£é‡Šï¼š".*" è¡¨ç¤ºå¯åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªï¼ˆ'*'ï¼‰ä»»æ„å­—ç¬¦ï¼ˆ'.'ï¼‰
```


æç¤ºï¼š

- 1 <= s.lengthÂ <= 20
- 1 <= p.lengthÂ <= 20
- sÂ åªåŒ…å«ä»Â a-zÂ çš„å°å†™å­—æ¯ã€‚
- pÂ åªåŒ…å«ä»Â a-zÂ çš„å°å†™å­—æ¯ï¼Œä»¥åŠå­—ç¬¦Â .Â å’ŒÂ *ã€‚
- ä¿è¯æ¯æ¬¡å‡ºç°å­—ç¬¦Â * æ—¶ï¼Œå‰é¢éƒ½åŒ¹é…åˆ°æœ‰æ•ˆçš„å­—ç¬¦


**code:**

```
/**è§£é¢˜æ€è·¯:
 *1ã€å¦‚æœpä¸ºç©ºï¼Œsä¸ºç©ºåŒ¹é…ï¼Œséç©ºä¸åŒ¹é…ï¼›
 *2ã€séç©ºï¼Œp == s || p == '.'æ—¶ç¬¬ä¸€ä¸ªå­—ç¬¦åŒ¹é…ï¼›
 *3ã€(p+1) != ''ï¼Œåˆ™é€’å½’åˆ¤æ–­å‰©ä¸‹çš„æ˜¯å¦åŒ¹é… first_match && isMatch(++s, ++p)
 *4ã€(p+1) == '*'ï¼Œåˆ™æœ‰ä¸¤ç§æƒ…å†µåŒ¹é…ï¼š
 *a: *åŒ¹é…0ä¸ªå­—ç¬¦ï¼ŒsåŒ¹é…å‰©ä¸‹çš„ï¼Œå³isMatch(s, p+2)
 *b: *åŒ¹é…1ä¸ªå­—ç¬¦ï¼Œç»§ç»­ç”¨påŒ¹é…å‰©ä¸‹çš„sï¼Œå³first_match && isMatch(s+1, p)
 */
 
 
int isMatch(char * s, char * p){

    if (!*p) {
        return !*s;
    }
    
    int isFirstMatch = *s && (*s == *p || *p == '.');
    if (*(p+1) == '*') {
        return isMatch(s, p+2) || (isFirstMatch && isMatch(++s, p));
    }else {
        return (isFirstMatch && isMatch(++s, ++p));
    }
}


//è°ƒç”¨
//    char *s = "aa";
//    char *p = "a";

char *s = "aa";
char *p = "a*";

//    char *s = "ab";
//    char *p = ".*";

int is_match = isMatch(s, p);
char *desc = is_match == 1 ? "åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼" : "ä¸åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼";
println("%s", desc);
```

æ‰“å°:

```
ğŸŒ·ğŸŒ¹(Apr 20 2023:20:28:39 [144è¡Œ] +[HGTestAlgorithm testLeetcodeIsMatch]) åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼
```



<br/>
<br/>


>## <h2 id="ä¸‰æ•°ä¹‹å’Œ">[ä¸‰æ•°ä¹‹å’Œ(åŠ¨æ€è§„åˆ’)](http://b23.tv/drt9epH)</h2>


ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸‰å…ƒç»„ [nums[i], nums[j], nums[k]] æ»¡è¶³ i != jã€i != k ä¸” j != k ï¼ŒåŒæ—¶è¿˜æ»¡è¶³ nums[i] + nums[j] + nums[k] == 0 ã€‚è¯·

ä½ è¿”å›æ‰€æœ‰å’Œä¸º 0 ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„ã€‚

æ³¨æ„ï¼šç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„ä¸‰å…ƒç»„ã€‚

Â 


ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šnums = [-1,0,1,2,-1,-4]
è¾“å‡ºï¼š[[-1,-1,2],[-1,0,1]]
è§£é‡Šï¼š
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 ã€‚
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 ã€‚
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 ã€‚
ä¸åŒçš„ä¸‰å…ƒç»„æ˜¯ [-1,0,1] å’Œ [-1,-1,2] ã€‚
æ³¨æ„ï¼Œè¾“å‡ºçš„é¡ºåºå’Œä¸‰å…ƒç»„çš„é¡ºåºå¹¶ä¸é‡è¦ã€‚
```

ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šnums = [0,1,1]
è¾“å‡ºï¼š[]
è§£é‡Šï¼šå”¯ä¸€å¯èƒ½çš„ä¸‰å…ƒç»„å’Œä¸ä¸º 0 ã€‚
```

ç¤ºä¾‹ 3ï¼š

```
è¾“å…¥ï¼šnums = [0,0,0]
è¾“å‡ºï¼š[[0,0,0]]
è§£é‡Šï¼šå”¯ä¸€å¯èƒ½çš„ä¸‰å…ƒç»„å’Œä¸º 0 ã€‚
```

<br/>

è§£é¢˜æ€è·¯å›¾:

![c0_31.JPG](./../Pictures/c0_31.JPG)



```
///ç­›é€‰
int sortComp(const void* pa, const void* pb){
    int a=*(int*)pa;
    int b=*(int*)pb;
    return a>b?1:-1;
}


int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    //Cè¯­è¨€å‡½æ•°
    qsort(nums, numsSize, sizeof(int), sortComp);
    int baseLength = 100; //æ•°ç»„åˆå§‹é•¿åº¦100
    //åˆå§‹åŒ–å¤„ç†è¿”å›å€¼ï¼ŒäºŒç»´æ•°ç»„çš„å¤§å°å’Œä¿å­˜æ¯ä¸€ä¸ªä¸€ç»´æ•°ç»„å¤§å°çš„æ•°ç»„çš„ç©ºé—´ä¿æŒä¸€è‡´
    int **newArr = (int **)malloc(sizeof(int*) * baseLength);
    *returnColumnSizes = (int *)malloc(sizeof(int)* baseLength);
    *returnSize = 0;

    for(int i = 0; i < numsSize; i ++){
        if(i > 0 && nums[i] == nums[i -1]){//è·³è¿‡é‡å¤å…ƒç´ (ç°åœ¨çš„å…ƒç´ å’Œä¸Šä¸€ä¸ªç›¸åŒäº†)
            continue;
        }
        //ä¸èƒ½æ”¾åœ¨forå¾ªç¯å¤–é¢.å¦åˆ™åæ¥å¾ªç¯ä¸èƒ½è®¡ç®—æœ«å°¾å…ƒç´ äº†,ä¹Ÿå°±æ˜¯ç¬¬äºŒä¸ªæŒ‡é’ˆ
        int r = numsSize -1;
        //iä¸‹æ ‡çš„ä¸‹ä¸€ä¸ªå…ƒç´ 
        int l = i + 1;
        int target = 0 - nums[i];        
        while(l < r){//lä¸‹æ ‡å°äºæœ€æœ«å°¾å…ƒç´ ä¸‹æ ‡
            if(nums[l]+nums[r] == target){//ç¬¦åˆç›¸åŠ ä¸º0
                //ç”³è¯·è¿”å›å€¼äºŒç»´æ•°ç»„çš„ç©ºé—´
                newArr[*returnSize]= (int *)malloc(sizeof(int)*3);
                //æ¯ä¸€ä¸ªæ•°ç»„å¤§å°éƒ½ä¸º3
                (*returnColumnSizes)[*returnSize]= 3;
                //èµ‹å€¼
                newArr[*returnSize][0]= nums[i];
                newArr[*returnSize][1]= nums[l];
                newArr[*returnSize][2]= nums[r];

                //äºŒç»´æ•°ç»„çš„è¡Œæ•°åŠ 1
                (*returnSize)++;

                //æ•°ç»„æ‰©å±•ä¸€å€
                if(*returnSize == baseLength){
                    baseLength *=2;
                    //rellocé‡æ–°åˆ†é…å†…å­˜å¤§å°,ä½†æ˜¯åœ°å€ä¸å˜:https://www.runoob.com/cprogramming/c-function-realloc.html
                    newArr = (int **)realloc(newArr, sizeof(int*)*baseLength);
                    *returnColumnSizes=(int*)realloc(*returnColumnSizes,sizeof(int)*baseLength);
                }
                while(l < r && nums[l] == nums[l+1]){//è·³è¿‡é‡å¤å…ƒç´ 
                    l++;
                }
                while(l<r && nums[r] == nums[r-1]){//è·³è¿‡é‡å¤å…ƒç´ 
                    r--;
                }

                l++;
                r--;
            }else if(nums[l]+nums[r] < target){//å·¦è¾¹å…ƒç´ ä¸‹æ ‡å¤ªå°äº†
                l++;
            }else{
                r--;
            }
        }
    }
    
    return newArr;
}


///è°ƒç”¨
int nums[] = {-1,0,1,2,-1,-4};
int numSize = sizeof(nums)/sizeof(int);

///calloc:C åº“å‡½æ•° void *calloc(size_t nitems, size_t size) åˆ†é…æ‰€éœ€çš„å†…å­˜ç©ºé—´ï¼Œå¹¶è¿”å›ä¸€ä¸ªæŒ‡å‘å®ƒçš„æŒ‡é’ˆã€‚malloc å’Œ calloc ä¹‹é—´çš„ä¸åŒç‚¹æ˜¯ï¼Œmalloc ä¸ä¼šè®¾ç½®å†…å­˜ä¸ºé›¶ï¼Œè€Œ calloc ä¼šè®¾ç½®åˆ†é…çš„å†…å­˜ä¸ºé›¶ã€‚
///æ³¨æ„ï¼šcalloc() å‡½æ•°å°†åˆ†é…çš„å†…å­˜å…¨éƒ¨åˆå§‹åŒ–ä¸ºé›¶ã€‚å¦‚æœä¸éœ€è¦åˆå§‹åŒ–ï¼Œå¯ä»¥ä½¿ç”¨ malloc() å‡½æ•°ä»£æ›¿ã€‚å¦å¤–ï¼Œä½¿ç”¨ calloc() å‡½æ•°æ—¶éœ€è¦æ³¨æ„ï¼Œå¦‚æœåˆ†é…çš„å†…å­˜å—è¿‡å¤§ï¼Œå¯èƒ½ä¼šå¯¼è‡´å†…å­˜ä¸è¶³çš„é—®é¢˜ã€‚
int *returnSize = (int *)calloc(1, sizeof(int));

//è¿™é‡Œçš„å†…å­˜åˆ†é…æœ€å¤§å€¼,å³æ’åˆ—ç»„åˆçŸ¥è¯†,Cå‡ å–3
//C6å–3 == 20
int** returnColumnSizes = (int**)malloc(sizeof(int*) * (numSize * (numSize - 1) * (numSize - 2)) / 6);

int **a = threeSum(nums, numSize, returnSize, returnColumnSizes);
for (int i = 0; i < *returnSize; i++) {
    printf("ğŸŒ·ğŸŒ¹è¡Œ:");
    int *b = a[i];
    for (int j = 0; j < 3; j++) {
        printf("%d, ", b[j]);
    }
    printf("\n");

}
```

Log:

```
ğŸŒ·ğŸŒ¹è¡Œ:-1, -1, 2, 
ğŸŒ·ğŸŒ¹è¡Œ:-1, 0, 1, 
```

<br/>
<br/>


> <h2 id="ç››æœ€å¤šæ°´çš„å®¹å™¨">ç››æœ€å¤šæ°´çš„å®¹å™¨(è´ªå¿ƒç®—æ³•)</h2>

![c0_37.png](./../Pictures/c0_37.png)



```
int maxArea(int* height, int heightSize){
    int left=0;
    int right=heightSize-1;
    int tall=0;//é«˜
    int area=0;//é¢ç§¯--å‚¨æ°´é‡
    int max=0;

    while(left < right)
    {
        tall=height[left]<height[right] ? height[left] : height[right];
        area=tall*(right-left);
        max=max>area ? max : area;
        
        if(height[left] < height[right])left++;
        else right--;
    }

    return max;
}

```

<br/>
<br/>





<br/>
<br/>


> <h2 id="ä¸‹ä¸€ä¸ªæ’åˆ—">ä¸‹ä¸€ä¸ªæ’åˆ—</h2>


æ•´æ•°æ•°ç»„çš„ä¸€ä¸ª æ’åˆ—Â  å°±æ˜¯å°†å…¶æ‰€æœ‰æˆå‘˜ä»¥åºåˆ—æˆ–çº¿æ€§é¡ºåºæ’åˆ—ã€‚

ä¾‹å¦‚ï¼Œarr = [1,2,3] ï¼Œä»¥ä¸‹è¿™äº›éƒ½å¯ä»¥è§†ä½œ arr çš„æ’åˆ—ï¼š[1,2,3]ã€[1,3,2]ã€[3,1,2]ã€[2,3,1] ã€‚

æ•´æ•°æ•°ç»„çš„ ä¸‹ä¸€ä¸ªæ’åˆ— æ˜¯æŒ‡å…¶æ•´æ•°çš„ä¸‹ä¸€ä¸ªå­—å…¸åºæ›´å¤§çš„æ’åˆ—ã€‚æ›´æ­£å¼åœ°ï¼Œå¦‚æœæ•°ç»„çš„æ‰€æœ‰æ’åˆ—æ ¹æ®å…¶å­—å…¸é¡ºåºä»å°åˆ°å¤§æ’åˆ—åœ¨ä¸€ä¸ªå®¹å™¨ä¸­ï¼Œé‚£ä¹ˆæ•°ç»„çš„ ä¸‹ä¸€ä¸ªæ’åˆ— å°±æ˜¯åœ¨è¿™ä¸ªæœ‰åºå®¹å™¨ä¸­æ’åœ¨å®ƒåé¢çš„é‚£ä¸ªæ’åˆ—ã€‚å¦‚æœä¸å­˜åœ¨ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ’åˆ—ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°ç»„å¿…é¡»é‡æ’ä¸ºå­—å…¸åºæœ€å°çš„æ’åˆ—ï¼ˆå³ï¼Œå…¶å…ƒç´ æŒ‰å‡åºæ’åˆ—ï¼‰ã€‚

ä¾‹å¦‚ï¼Œarr = [1,2,3] çš„ä¸‹ä¸€ä¸ªæ’åˆ—æ˜¯ [1,3,2] ã€‚

ç±»ä¼¼åœ°ï¼Œarr = [2,3,1] çš„ä¸‹ä¸€ä¸ªæ’åˆ—æ˜¯ [3,1,2] ã€‚

è€Œ arr = [3,2,1] çš„ä¸‹ä¸€ä¸ªæ’åˆ—æ˜¯ [1,2,3] ï¼Œå› ä¸º [3,2,1] ä¸å­˜åœ¨ä¸€ä¸ªå­—å…¸åºæ›´å¤§çš„æ’åˆ—ã€‚

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾å‡º nums çš„ä¸‹ä¸€ä¸ªæ’åˆ—ã€‚

å¿…é¡» åŸåœ° ä¿®æ”¹ï¼Œåªå…è®¸ä½¿ç”¨é¢å¤–å¸¸æ•°ç©ºé—´ã€‚

Â 

ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šnums = [1,2,3]
è¾“å‡ºï¼š[1,3,2]
```

ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šnums = [3,2,1]
è¾“å‡ºï¼š[1,2,3]
```

ç¤ºä¾‹ 3ï¼š

```
è¾“å…¥ï¼šnums = [1,1,5]
è¾“å‡ºï¼š[1,5,1]
```


<br/>

æ€è·¯å›¾:

![c0_73.png](./../Pictures/c0_73.png)


<br/>


```
//æ¯”è¾ƒ
int cmp(void* a, void* b){
    return *(int *)a  - *(int *)b;
}
//äº¤æ¢
void swap(int *a, int *b){
    int tmp = *b;
    *b = *a;
    *a = tmp;
}
//é¢ å€’é¡ºåº
void reverse(int *array, int size, int start){
    int end = size -1;
    while(start < end) {
        swap(&array[start], &array[end]);
       
        start++;
        end--;
    }
}



void nextPermutation(int* nums, int numsSize){
    int cur = numsSize - 2;
    while(cur>=0 && nums[cur]>=nums[cur+1]){//nums[cur]>=nums[cur+1] å€’æ•°ç¬¬ä¸€å’Œå€’æ•°ç¬¬äºŒä¸ªæ•°åšå¯¹æ¯”,
        //è‹¥æ˜¯ç¬¦åˆè¿™ä¸ªæ¡ä»¶è¯´æ˜æœ«å°¾æ˜¯é™åºæ’åˆ—,åé¢åªéœ€è¦é¢ å€’é¡ºåºå³å¯,å°±å¯ä»¥åšåˆ°å‡åºæ’åˆ—äº†
        cur--;
    }

    if(cur < 0){//è‹¥æ˜¯å‡åºæ’åˆ—: cur = -1;
        qsort(nums, numsSize, sizeof(int), cmp);
    }else {
        //curæ˜¯ä»åé¢æ¯”è¾ƒ,æ‰¾åˆ°ç¬¬ä¸€ä¸ªå‰é¢å¤§äºåé¢çš„æ•°å­—çš„ç´¢å¼•åºåˆ—
        int pos = numsSize -1;
        while(nums[pos] <= nums[cur]){//æ³¨æ„: è·å–æ•°ç»„å…ƒç´ å€¼:nums[pos]
            pos--;
        }
        //ä»åå¾€å‰æ‰¾,æ‰¾åˆ°æ¯”åœ¨ç´¢å¼•åºåˆ—curè¿˜å¤§ä¸€ç‚¹çš„æ•°ç»„å…ƒç´ ,è¿›è¡Œäº¤æ¢
        swap(&nums[pos], &nums[cur]);//æ³¨æ„:è¿™æ ·ä¼ é€’æ•°ç»„å…ƒç´ æŒ‡é’ˆå€¼
        reverse(nums, numsSize, cur+1);//é¢ å€’é¡ºåºåšåˆ°æœ«å°¾å‡åºæ’åˆ—,å› ä¸ºæ’åºæ˜¯ä»cur+1å¼€å§‹çš„
        //æ³¨æ„: ä¼ é€’æ•°ç»„,åªè¦ä¼ é€’æ•°ç»„é¦–åœ°å€å°±å¯ä»¥äº†
    }
}


//è°ƒç”¨
+ (void)testNextPermutation{
    
    int nums[] = {4, 2, 5, 3, 2, 1, 0};
//    int nums[] = {4, 3, 2, 1, 0};//å‡åºæ’åˆ—
    
    int size = sizeof(nums)/sizeof(int);
    nextPermutation(nums, size);
    
    printArr(nums, size);
}
```

**Log:**

```
ğŸŒ·ğŸŒ¹ 21:04:45 [125è¡Œ] +[HGTestAlgorithm testNextPermutation]=> 04 03 00 01 02 02 05 
```


<br/>
<br/>


> <h2 id=""></h2>








<br/>
<br/>


> <h2 id=""></h2>







<br/>
<br/>


> <h2 id=""></h2>







<br/>
<br/>


> <h2 id=""></h2>







<br/>
<br/>


> <h2 id=""></h2>






<br/>
<br/>


> <h2 id=""></h2>





<br/>
<br/>


> <h2 id=""></h2>







<br/>
<br/>


> <h2 id=""></h2>







<br/>
<br/>


> <h2 id=""></h2>







<br/>
<br/>


> <h2 id=""></h2>







<br/>
<br/>


> <h2 id=""></h2>







<br/>
<br/>


> <h2 id=""></h2>






<br/>
<br/>


> <h2 id=""></h2>







<br/>
<br/>


> <h2 id=""></h2>




<br/>
<br/>


> <h2 id=""></h2>





<br/>
<br/>


> <h2 id=""></h2>







<br/>
<br/>


> <h2 id=""></h2>








<br/>
<br/>


> <h2 id=""></h2>








<br/>
<br/>


> <h2 id=""></h2>








<br/>
<br/>


> <h2 id=""></h2>







<br/>
<br/>


> <h2 id=""></h2>








<br/>
<br/>


> <h2 id=""></h2>






<br/>
<br/>


> <h2 id=""></h2>






<br/>
<br/>


> <h2 id=""></h2>




<br/>
<br/>


> <h2 id=""></h2>




<br/>
<br/>


> <h2 id=""></h2>






<br/>
<br/>


> <h2 id=""></h2>



