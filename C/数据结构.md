> <h2 id=''></h2>
- [**æ—¶é—´å¤æ‚åº¦çš„è®¡ç®—**](#æ—¶é—´å¤æ‚åº¦çš„è®¡ç®—)
	- [æ¨å¯¼å¤§Oé˜¶](#æ¨å¯¼å¤§Oé˜¶)
		- [ä¹ é¢˜](#ä¹ é¢˜)	
			- [é”™è¯¯5](#é”™è¯¯5)
			- [é”™è¯¯6](#é”™è¯¯6)
			- [é”™è¯¯7](#é”™è¯¯7)
			- [é”™è¯¯8](#é”™è¯¯8)
			- [é”™è¯¯9](#é”™è¯¯9)
			- 	[é”™è¯¯10](#é”™è¯¯10)
- [**çº¿æ€§è¡¨**](#çº¿æ€§è¡¨)
	- [**çº¿æ€§çš„è¡¨é¡ºåºå­˜å‚¨**](#çº¿æ€§çš„è¡¨é¡ºåºå­˜å‚¨)
		- [æ’å…¥](#æ’å…¥)
		- [å•é“¾è¡¨æ’å…¥2æ¯”è¾ƒ](#å•é“¾è¡¨æ’å…¥2æ¯”è¾ƒ)
			- [ä¸€èˆ¬å¤´èŠ‚ç‚¹](#ä¸€èˆ¬å¤´èŠ‚ç‚¹)
			- [äºŒçº§æŒ‡é’ˆå……å½“å¤´èŠ‚ç‚¹](#äºŒçº§æŒ‡é’ˆå……å½“å¤´èŠ‚ç‚¹)
			- [äºŒçº§æŒ‡é’ˆæ¯”è¾ƒ](#äºŒçº§æŒ‡é’ˆæ¯”è¾ƒ)
		- [åˆ é™¤](#åˆ é™¤)
- [**çº¿æ€§è¡¨çš„é“¾å¼å­˜å‚¨**](#çº¿æ€§è¡¨çš„é“¾å¼å­˜å‚¨)
	- [å¤´æŒ‡é’ˆä½œç”¨](#å¤´æŒ‡é’ˆä½œç”¨)
	- [å¤´èŠ‚ç‚¹ä½œç”¨](#å¤´èŠ‚ç‚¹ä½œç”¨)
	- [ç»“æ„ä½“èŠ‚ç‚¹çš„å®šä¹‰å’Œç”³æ˜](#ç»“æ„ä½“èŠ‚ç‚¹çš„å®šä¹‰å’Œç”³æ˜)
	- [å•é“¾è¡¨çš„æ’å…¥](#å•é“¾è¡¨çš„æ’å…¥)
		- [å¤´æ’æ³•(ä»£ç éœ€è¦æ•´ç†)](#å¤´æ’æ³•)
		- [å¤´æ’æ³•åˆ›å»ºé“¾è¡¨](#å¤´æ’æ³•åˆ›å»ºé“¾è¡¨)
		- [å°¾æ’æ³•åˆ›å»ºé“¾è¡¨](#å°¾æ’æ³•åˆ›å»ºé“¾è¡¨)
			- [å°¾æ’æ³•é“¾è¡¨: è§£å†³å°¾æŒ‡é’ˆèŠ‚ç‚¹è·Ÿéšæ’å…¥èŠ‚ç‚¹èµ°åŠ¨é¡¾è™‘](#å°¾æ’æ³•é“¾è¡¨è§£å†³å°¾æŒ‡é’ˆèŠ‚ç‚¹è·Ÿéšæ’å…¥èŠ‚ç‚¹èµ°åŠ¨é¡¾è™‘)
	- [å•é“¾è¡¨å…ƒç´ çš„åˆ é™¤](#å•é“¾è¡¨å…ƒç´ çš„åˆ é™¤)
- [**å¾ªç¯é“¾è¡¨**](#å¾ªç¯é“¾è¡¨)
- [**åŒå‘é“¾è¡¨**](#åŒå‘é“¾è¡¨)
	- [åŒå‘é“¾è¡¨çš„æ’å…¥](#åŒå‘é“¾è¡¨çš„æ’å…¥)
	- [åŒå‘é“¾è¡¨çš„åˆ é™¤](#åŒå‘é“¾è¡¨çš„åˆ é™¤)
- [**é“¾æ ˆ**](#é“¾æ ˆ)
	- [è¿›æ ˆ](#è¿›æ ˆ)
	- [å‡ºæ ˆ](#å‡ºæ ˆ)
	- [æ¸…ç©ºæ ˆå…ƒç´ ](#æ¸…ç©ºæ ˆå…ƒç´ )
	- [å››åˆ™è¿ç®—è¡¨è¾¾å¼(æ ˆçš„åº”ç”¨)](#å››åˆ™è¿ç®—è¡¨è¾¾å¼æ ˆçš„åº”ç”¨)
- [**é˜Ÿåˆ—**](#é˜Ÿåˆ—)
	- [é“¾å¼é˜Ÿåˆ—](#é“¾å¼é˜Ÿåˆ—)
	- [å…¥é˜Ÿåˆ—](#å…¥é˜Ÿåˆ—)
	- [é“¾å¼å‡ºé˜Ÿåˆ—](#é“¾å¼å‡ºé˜Ÿåˆ—)
- [**äºŒå‰æ ‘**](#äºŒå‰æ ‘)
	- [æ€§è´¨](#æ€§è´¨)
	- [éå†](#éå†)
	- [æ˜“é”™ç‚¹](#æ˜“é”™ç‚¹)
	- [äºŒå‰æ ‘çš„å‰ã€ä¸­ã€åéå†](#äºŒå‰æ ‘çš„å‰ä¸­åéå†)
- **å‚è€ƒèµ„æ–™**
	- [**çº¿æ€§è¡¨2**](https://www.jianshu.com/p/1ed7e2d2c761)
	- [æ•°æ®ç»“æ„](https://www.cnblogs.com/linuxAndMcu/category/1084577.html)
	- [**æ ˆçš„å››åˆ™è¿ç®—**](https://www.cnblogs.com/mm93/p/6702083.html)
	- [**åˆ¤æ–­è¿ç®—ç¬¦ä¼˜å…ˆçº§ï¼š**](https://blog.csdn.net/wenzhou1219/article/details/23961307)
	- [**ä»£ç ï¼š**](https://www.xuebuyuan.com/1389583.html)

<br/>


***
<br/>

> <h1 id="æ—¶é—´å¤æ‚åº¦çš„è®¡ç®—">æ—¶é—´å¤æ‚åº¦çš„è®¡ç®—</h1>

<br/>


<h2 id="æ¨å¯¼å¤§Oé˜¶">æ¨å¯¼å¤§Oé˜¶:</h2>

- ç”¨å¸¸æ•° 1 å–ä»£è¿è¡Œæ—¶é—´ä¸­çš„æ‰€æœ‰åŠ æ³•å¸¸æ•°ï¼›
- åœ¨ä¿®æ”¹åçš„è¿è¡Œæ•°å‡½æ•°ä¸­ï¼Œåªä¿ç•™æœ€é«˜é˜¶é¡¹ï¼›
- å¦‚æœæœ€é«˜é˜¶é¡¹å­˜åœ¨ä¸”ä¸æ˜¯ 1 å°±ï¼Œ åˆ™å»é™¤ä¸è¿™ä¸ªé¡¹ç›¸ä¹˜çš„å¸¸æ•°ï¼Œå¾—åˆ°ç»“æœå°±æ˜¯å¤§ O é˜¶ã€‚



<br/><br/>

> <h3 id='ä¹ é¢˜'>ä¹ é¢˜</h3>

**1).O(nÂ²)**

```
sum=0; // (1æ¬¡)
for(i=1;i<=n;i++) 
    //(næ¬¡)
    for(j=1;j<=n;j++)
        //(nÂ²æ¬¡)
        sum++; // (nÂ²æ¬¡)
```

**T(n) = O(nÂ²)**

<br/>
<br/>



**2).O(nÂ²)**


```
for (i=1;i<n;i++)  {
    y=y+1; // â‘ 
    for (j=0;j<=(2*n);j++)
        x++; // â‘¡
}
```


è§£:è¯­å¥1çš„é¢‘åº¦æ˜¯n-1

è¯­å¥2çš„é¢‘åº¦æ˜¯(n-1)(2n+1)=2nÂ²-n-1

f(n)=2nÂ²-n-1+(n-1)=2nÂ²-2

è¯¥ç¨‹åºçš„æ—¶é—´å¤æ‚åº¦**T(n) = O(nÂ²)**



<br/>
<br/>



**3).O(n)**

```
a=0;
b=1;   // â‘ 
for (i=1;i<=n;i++)   {//â‘¡
    s=a+b; // â‘¢
    b=a;   // â‘£
    a=s;   // â‘¤
} 
```


è§£:è¯­å¥1çš„é¢‘åº¦:1,

è¯­å¥2çš„é¢‘åº¦:n,

è¯­å¥3çš„é¢‘åº¦:n-1,

è¯­å¥4çš„é¢‘åº¦:n-1,

è¯­å¥5çš„é¢‘åº¦:n-1,

**T(n) = 1+n+3(n-1) = 4n-2 = O(n)**



<br/>
<br/>





**4).O(logâ‚‚â¿)**


```
i=1; // â‘ 
while (i<=n)
    //â‘¡
    i=i*2;
```



è§£:è¯­å¥1çš„é¢‘åº¦æ˜¯1

è®¾è¯­å¥2çš„é¢‘åº¦æ˜¯f(n),

åˆ™:2^f(n)=n; f(n)=logâ‚‚â¿

å–æœ€å¤§å€¼f(n)=logâ‚‚â¿, **T(n)=O(logâ‚‚â¿)**


<br/>
<br/>

> <h4 id='é”™è¯¯5'>é”™è¯¯5</h2>

**5).O(nÂ³)**

```
for(i=1;i<=n;i++)  {
    for(j=1;j<=i;j++)  {
        for(k=1;k<=j;k++)
            x=x+2;
    }
}
```


é”™è¯¯ç­”æ¡ˆæ˜¯: n * (nÂ²+n)/2 *n = (nâ´+nÂ³)/2

è§£:å¾ªç¯å…±è¿›è¡Œäº†[1+(1+2)+(1+2+3)+â€¦+(1+2+3+â€¦+n) = n(n+1)(n+2)/6](https://qb.zuoyebang.com/xfe-question/question/5b910feb17621b0087f5e2a3cfcbcd44.html) æ¬¡ï¼Œ

æ‰€ä»¥ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºT(n) = O(nÂ³)



<br/>
<br/>

> <h4 id='é”™è¯¯6'>é”™è¯¯6</h2>


**6).**


æŸç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n2)ï¼Œè¡¨æ˜è¯¥ç®—æ³•çš„ï¼ˆ ï¼‰
A.é—®é¢˜è§„æ¨¡æ˜¯n2 

B.æ‰§è¡Œæ—¶é—´ç­‰äºn2

C.æ‰§è¡Œæ—¶é—´ä¸n2æˆæ­£æ¯” 

D.é—®é¢˜è§„æ¨¡ä¸n2æˆæ­£æ¯”

é”™è¯¯: A


è§£ç­”: **æ­¤é¢˜é€‰C**ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(n2)ï¼Œè¯´æ˜ç®—æ³•çš„æ‰§è¡Œæ—¶é—´T(n)<=c * n2(cä¸ºæ¯”ä¾‹å¸¸æ•°)ï¼Œå³T(n)=O(n2)ï¼Œæ—¶é—´å¤æ‚åº¦T(n)æ˜¯é—®é¢˜è§„æ¨¡nçš„å‡½æ•°ï¼Œå…¶é—®é¢˜è§„æ¨¡ä»ç„¶æ˜¯nè€Œä¸æ˜¯n2ã€‚

<br/>
<br/>

> <h4 id='é”™è¯¯7'>é”™è¯¯7</h2>

**7).**

æ±‚æ•´æ•°n (n>=0)é˜¶ä¹˜çš„ç®—æ³•å¦‚ä¸‹ï¼Œå…¶æ—¶é—´å¤æ‚åº¦æ˜¯ï¼ˆ ï¼‰


```
int fact(int n){
    if (n<=1) return 1;
    return n*fact(n-1);
}
```

T(n)=O(n)ï¼Œæœ¬é¢˜æ˜¯æ±‚é˜¶ä¹˜n!çš„é€’å½’ä»£ç ï¼Œå³n(n-1)...*1å…±æ‰§è¡Œnæ¬¡ä¹˜æ³•æ“ä½œï¼Œæ•…T(n)=O(n)ã€‚



<br/>
<br/>



> <h4 id='é”™è¯¯8'>é”™è¯¯8</h2>

**8).**


ç¨‹åºæ®µ

```
for(i=n-1;i>1;i--)
   for(j=1;j<i;j++)
       if (A[j]>A[j+1])
           A[j]ä¸ A[j+1]å¯¹æ¢;
```

å…¶ä¸­nä¸ºæ­£æ•´æ•°ï¼Œåˆ™æœ€åä¸€è¡Œçš„è¯­å¥é¢‘åº¦åœ¨æœ€åæƒ…å†µä¸‹æ˜¯ï¼ˆ ï¼‰



é”™è¯¯è§£ç­”:(n-2) * (nÂ²-2n+1)/2


è§£ç­”: (n-1)+(n-2)+(n-3)+....+2 = (n-2)(n+1)/2

T(n)= 0(nÂ²)





<br/>
<br/>


> <h4 id='é”™è¯¯9'>é”™è¯¯8</h9>

**9).**


ä¸‹é¢è¯´æ³•é”™è¯¯çš„æ˜¯ï¼ˆ ï¼‰ã€‚

â… .ç®—æ³•åŸåœ°å·¥ä½œçš„å«ä¹‰æ˜¯æŒ‡ä¸éœ€è¦ä»»ä½•é¢å¤–çš„è¾…åŠ©ç©ºé—´

â…¡.åœ¨ç›¸åŒçš„è§„æ¨¡nä¸‹ï¼Œå¤æ‚åº¦O(n)çš„ç®—æ³•åœ¨æ—¶é—´ä¸Šæ€»æ˜¯ä¼˜äºå¤æ‚åº¦O(2n)çš„ç®—æ³•

â…¢.æ‰€è°“æ—¶é—´å¤æ‚åº¦æ˜¯æŒ‡æœ€åæƒ…å†µä¸‹ï¼Œä¼°ç®—ç®—æ³•æ‰§è¡Œæ—¶é—´çš„ä¸€ä¸ªä¸Šç•Œ

â…£.åŒä¸€ä¸ªç®—æ³•ï¼Œå®ç°è¯­è¨€çš„çº§åˆ«è¶Šé«˜ï¼Œæ‰§è¡Œæ•ˆç‡å°±è¶Šä½

A. â…  

B. â… ã€â…¡ 

C. â… ã€â…£ 

D. â…¢



é”™è¯¯è§£ç­”: é€‰D

æ­£ç¡®è§£ç­”: é€‰A

â… ï¼Œç®—æ³•åŸåœ°å·¥ä½œæ˜¯æŒ‡ç®—æ³•æ‰€éœ€çš„è¾…åŠ©ç©ºé—´æ˜¯å¸¸é‡ã€‚â…¡ï¼Œé¢˜ä¸­æ˜¯æŒ‡ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ï¼Œä¸è¦æƒ³å½“ç„¶è®¤ä¸ºæ˜¯ç¨‹åºï¼ˆè¯¥ç®—æ³•çš„å®ç°ï¼‰çš„å…·ä½“æ‰§è¡Œæ—¶é—´ï¼Œè€Œèµ‹äºˆnâ€”ä¸ªç‰¹æ®Šçš„å€¼ã€‚æ—¶é—´å¤æ‚åº¦ä¸ºO(n)çš„ç®—æ³•ï¼Œå¿…ç„¶æ€»æ˜¯ä¼˜äºæ—¶é—´å¤æ‚åº¦ä¸ºO(2n)çš„ç®—æ³•ã€‚â…¢ï¼Œæ—¶é—´å¤æ‚åº¦æ€»æ˜¯è€ƒè™‘åœ¨æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ï¼Œä»¥ä¿è¯ç®—æ³•çš„è¿è¡Œæ—¶é—´ä¸ä¼šæ¯”å®ƒæ›´é•¿ã€‚â…£ä¸ºä¸¥è”šæ•æ•™æçš„åŸè¯ã€‚

<br/>
<br/>

> <h4 id='é”™è¯¯10'>é”™è¯¯10</h10>

**10).**

åˆ†æä»¥ä¸‹å„ç¨‹åºæ®µï¼Œæ±‚å‡ºç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ã€‚

```
// ç¨‹åºæ®µâ‘ 
i=1;k=0;
while(i<n-1){
    k=k+10*i;
    i++;
}


// ç¨‹åºæ®µâ‘¡
y=0;
while((y+1)*(y+1)<=n)
    y=y+1;


// ç¨‹åºæ®µâ‘¢
for(i=1;i<=n;i++)
    for(j =1;j <=i;j ++)
        for(k=1;k<=j;k++)
            x++;


// ç¨‹åºæ®µâ‘£
for(i=0;i<n;i++)
    for(j=0;j<m;j++)
        a[i] [j]=0;
```



â‘ åŸºæœ¬è¯­å¥æ˜¯k=k+10iï¼Œå…±æ‰§è¡Œäº†n-2æ¬¡ï¼Œæ‰€ä»¥T(n) = O(n)ã€‚

â‘¡è®¾å¾ªç¯ä½“å…±æ‰§è¡ŒT(n)æ¬¡ï¼Œæ¯å¾ªç¯ä¸€æ¬¡ï¼Œå¾ªç¯å˜é‡yåŠ 1,æœ€ç»ˆT(n)=yã€‚æ•…(T(n))2<=nï¼Œè§£å¾— T(n) = O(n1/2)ã€‚

â‘¢å‚è€ƒ[ç»ƒä¹ é¢˜5](#é”™è¯¯5)ï¼ŒT(n) = O(n3)

â‘£ai=0æ˜¯åŸºæœ¬è¯­å¥ï¼Œå†…å¾ªç¯æ‰§è¡Œmæ¬¡ï¼Œå¤–å¾ªç¯æ‰§è¡Œnæ¬¡ï¼Œå…±æ‰§è¡Œäº†mnæ¬¡ï¼Œæ‰€ä»¥ T(m, n) = O(mn)







<br/>


***
<br/>
<br/>

> <h1 id="çº¿æ€§è¡¨">çº¿æ€§è¡¨</h1>


> <h2 id="çº¿æ€§çš„è¡¨é¡ºåºå­˜å‚¨">çº¿æ€§çš„è¡¨é¡ºåºå­˜å‚¨</h2>

<br/>

> <h3 id="æ’å…¥">æ’å…¥</h3>

![é¡ºåºæ’å…¥å¦‚æ’é˜Ÿ](https://upload-images.jianshu.io/upload_images/2959789-cefa6587a0ad65c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
int initList(SqList *list){
    list -> length = 0;
    
    return OK;
}


//çº¿æ€§è¡¨é¡ºåºæ’å…¥
int listInsert(SqList *list, int i, int e){
    //é¡ºåºçº¿æ€§è¡¨å·²ç»æ»¡
    if (list->length == MAXSIZE ) {
        return ERROR;
    }
    
    //å½“iæ¯”ç¬¬ä¸€ä½ç½®å°æˆ–è€…æ¯”æœ€åä¸€ä½ç½®åä¸€ä½ç½®è¿˜è¦å¤§æ—¶(å¦‚ï¼šæ•°ç»„é•¿åº¦ä¸º9ï¼Œä½†æ˜¯iä¸º10)
    if (i < 1 || i > list->length +1) {
        return ERROR;
    }
    
    //è‹¥æ’å…¥æ•°æ®ä½ç½®ä¸åœ¨è¡¨å°¾
    if (i <= list->length) {
        for (int k = list->length-1; k >= i-1; k --) {
            list->data[k+1] = list->data[k];
        }
    }
    
    //å°†æ–°å…ƒç´ æ’å…¥
    list->data[i -1] = e;
    list->length++;
    
    return TRUE;
}

//åˆå§‹æ¡ä»¶ï¼šé¡ºåºçº¿æ€§è¡¨Lå·²å­˜åœ¨
//æ“ä½œç»“æœï¼šä¾æ¬¡å¯¹Lçš„æ¯ä¸ªæ•°æ®å…ƒç´ è¾“å‡º
int listTraverse(SqList list){
    int i;
    for (i = 0; i < list.length; i ++) {
        int k = visitElement(list.data[i]);
        printf("\n");
    }
    return OK;
}

int visitElement(ElemType c){
    printf("%d", c);
    
    return OK;
}


SqList  L;
    
ElemType e = NULL;
Status  i;
int j;
    
i = initList(&L);
printf("åˆå§‹åŒ–Låï¼šL.length=%d\n",L.length);
    
for (j = 1; j <= 5; j ++) {
    i = listInsert(&L, j, 1);
}
printf("åœ¨Lçš„è¡¨å¤´ä¾æ¬¡æ’å…¥1ï½5åï¼šL.data=\n");
listTraverse(L);

```

è¾“å‡ºï¼š

```
åˆå§‹åŒ–Låï¼šL.length=0
åœ¨Lçš„è¡¨å¤´ä¾æ¬¡æ’å…¥1ï½5åï¼šL.data=
1
1
1
1
1
```



<br/>
<br/>


> <h2 id="å•é“¾è¡¨æ’å…¥2æ¯”è¾ƒ">å•é“¾è¡¨æ’å…¥2æ¯”è¾ƒ</h2>

- <h3 id="ä¸€èˆ¬å¤´èŠ‚ç‚¹">ä¸€èˆ¬å¤´èŠ‚ç‚¹</h3>

```
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *next;
} ChainNode;

typedef struct Node* HeaderNode;


ChainNode* insertNode(ChainNode *header, int i, int data) {
    
    if (header == NULL) {
	    //ä¼ è¿‡æ¥çš„headeræŒ‡é’ˆç»è¿‡åˆå§‹åŒ–ä¼šè¢«è¦†ç›–æ‰ï¼Œåœ¨mainå‡½æ•°é‡Œé¢çš„headerå¤´èŠ‚ç‚¹ä»ç„¶ä¸ºnullï¼Œæ‰€ä»¥åœ¨è¿™ä¸ªå‡½æ•°é‡Œè¦ä¼ å¤´èŠ‚ç‚¹æŒ‡é’ˆ
        header = (ChainNode *)malloc(sizeof(ChainNode));
        //è‹¥ä¸æŒ‡å‘ä¸ºnullï¼Œåˆ™åœ¨éå†æ—¶å¯èƒ½è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘äº†æœªçŸ¥ç©ºé—´å¼•èµ·crash
        header->next = 0;
    }
    
    ChainNode *tagNode = header;
    int j = 0;
    
    while (j < i) {
        tagNode = tagNode->next;
        ++j;
    }
    
    ChainNode *insertNode = (ChainNode *)malloc(sizeof(ChainNode));
    insertNode->data = data;
    
    insertNode->next = tagNode->next;
    tagNode->next = insertNode;
    
    return  header;
}

//å•é“¾è¡¨å€¼çš„éå†
int chainedListTraverse(ChainNode *list){
    if (list->next == NULL) {
        return 0;
    }
    
    printf("é“¾è¡¨çš„å€¼æ˜¯ï¼š");
    
    ChainNode *traverse = list->next;
    while (traverse != NULL) {
        printf("%d,  ", traverse->data);
        traverse = traverse->next;
    }
    return 1;
}
```

æ‰“å°ï¼š

```
é“¾è¡¨çš„å€¼æ˜¯ï¼š0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  
```

<br/>


- <h3 id="äºŒçº§æŒ‡é’ˆå……å½“å¤´èŠ‚ç‚¹">äºŒçº§æŒ‡é’ˆå……å½“å¤´èŠ‚ç‚¹</h3>


```
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *next;
} ChainNode;

//å¯ä»¥ç”¨æ¥å……å½“äºŒçº§æŒ‡é’ˆå£°æ˜
typedef struct Node* HeaderNode;




void insertNode1(HeaderNode *header, int i, int data) {
    
    if (*header == NULL) {
        //C åº“å‡½æ•° void *malloc(size_t size) åˆ†é…æ‰€éœ€çš„å†…å­˜ç©ºé—´ï¼Œå¹¶è¿”å›ä¸€ä¸ªæŒ‡å‘å®ƒçš„æŒ‡é’ˆã€‚
        *header = (HeaderNode)malloc(sizeof(HeaderNode));
        //è‹¥ä¸æŒ‡å‘ä¸ºnullï¼Œåˆ™åœ¨éå†æ—¶å¯èƒ½è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘äº†æœªçŸ¥ç©ºé—´å¼•èµ·crash
        //ã€‚åœ¨æ­¤è¦ç‰¹åˆ«è¯´æ˜ä¸€ç‚¹ï¼Œæ­¤å¤„çš„åˆå€¼0ä»£è¡¨NULLï¼Œè€Œä¸æ˜¯æ•°å€¼0ã€‚å› æ­¤åœ¨å£°æ˜æŒ‡é’ˆå˜é‡æ—¶ï¼Œä¸‡ä¸‡ä¸èƒ½ç›´æ¥å°†æŒ‡é’ˆå˜é‡çš„åˆå€¼è®¾ç½®ä¸ºæ•°å€¼ï¼Œè¿™æ ·ä¼šä½¿æŒ‡é’ˆå˜é‡æŒ‡å‘ä¸åˆæ³•çš„åœ°å€ï¼Œå› è€Œé€ æˆä¸å¯é¢„æœŸçš„é”™è¯¯ã€‚
        (*header)->next = 0;
    }
    
    HeaderNode tagNode = *header;
    int j = 0;
    
    while (j < i) {
        tagNode = tagNode->next;
        ++j;
    }
    
    ChainNode *insertNode = (ChainNode *)malloc(sizeof(ChainNode));
    insertNode->data = data;
    
    insertNode->next = tagNode->next;
    tagNode->next = insertNode;
    
}

//å•é“¾è¡¨å€¼çš„éå†
int chainedListTraverse1(HeaderNode *list){
    if ((*list)->next == NULL) {
        return 0;
    }
    
    printf("é“¾è¡¨çš„å€¼æ˜¯ï¼š");
    
    ChainNode *traverse = (*list)->next;
    while (traverse != NULL) {
        printf("%d,  ", traverse->data);
        traverse = traverse->next;
    }
    return 1;
}




int main(int argc, const char * argv[]) {
    /**å¤šé‡æŒ‡é’ˆ
     *ç”±äºæŒ‡é’ˆå˜é‡å­˜å‚¨çš„æ˜¯æŒ‡é’ˆæ‰€æŒ‡å‘çš„å†…å­˜åœ°å€ï¼Œè€ŒæŒ‡é’ˆå˜é‡è‡ªå·±æ‰€å æœ‰çš„å†…å­˜ç©ºé—´ä¹Ÿæ‹¥æœ‰ä¸€ä¸ªåœ°å€ï¼Œ
     *å› æ­¤å¯ä»¥å£°æ˜â€œæŒ‡é’ˆçš„æŒ‡é’ˆâ€ï¼ˆpointer of pointerï¼‰ï¼Œå°±æ˜¯â€œæŒ‡å‘æŒ‡é’ˆå˜é‡çš„æŒ‡é’ˆå˜é‡â€ï¼Œæˆ–è€…ç§°ä¸ºâ€œå¤šé‡æŒ‡é’ˆâ€çš„åº”ç”¨ã€‚
     *
     *int num = 10;
     *int *ptr1 = &num; //å®šä¹‰æŒ‡é’ˆå˜é‡ *ptr1ï¼Œå¹¶æŒ‡å‘æ•´æ•°å˜é‡numåœ°å€
     *int **ptr2 = &ptr1; //å®šä¹‰æŒ‡é’ˆå˜é‡ptr2ï¼Œå¹¶æŒ‡å‘æŒ‡é’ˆå˜é‡ptr1çš„åœ°å€
     */
    HeaderNode headerNode = NULL;
    for (int i = 0; i < 10; i ++) {
	    //&headerNodeå˜ä¸ºäºŒçº§æŒ‡é’ˆ
        insertNode1(&headerNode, i, i);
    }
    chainedListTraverse1(&headerNode);
}

```

æ‰“å°ï¼š

```
é“¾è¡¨çš„å€¼æ˜¯ï¼š0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  
```


<br/>

- <h3 id="äºŒçº§æŒ‡é’ˆæ¯”è¾ƒ">äºŒçº§æŒ‡é’ˆæ¯”è¾ƒ</h2>
&emsp; ç”±äºæŒ‡é’ˆå˜é‡å­˜å‚¨çš„æ˜¯æŒ‡é’ˆæ‰€æŒ‡å‘çš„å†…å­˜åœ°å€ï¼Œè€ŒæŒ‡é’ˆå˜é‡è‡ªå·±æ‰€å æœ‰çš„å†…å­˜ç©ºé—´ä¹Ÿæ‹¥æœ‰ä¸€ä¸ªåœ°å€ï¼Œå› æ­¤å¯ä»¥å£°æ˜â€œæŒ‡é’ˆçš„æŒ‡é’ˆâ€ï¼ˆpointer of pointerï¼‰ï¼Œå°±æ˜¯â€œæŒ‡å‘æŒ‡é’ˆå˜é‡çš„æŒ‡é’ˆå˜é‡â€ï¼Œæˆ–è€…ç§°ä¸ºâ€œå¤šé‡æŒ‡é’ˆâ€çš„åº”ç”¨ã€‚

```
int main(int argc, const char * argv[]) {

	int num = 10;
    int *ptr1 = &num; //å®šä¹‰æŒ‡é’ˆå˜é‡ *ptr1ï¼Œå¹¶æŒ‡å‘æ•´æ•°å˜é‡numåœ°å€
    int **ptr2 = &ptr1; //å®šä¹‰æŒ‡é’ˆå˜é‡ptr2ï¼Œå¹¶æŒ‡å‘æŒ‡é’ˆå˜é‡ptr1çš„åœ°å€

    printf("\n\n-------------------------------------------------\n");
    printf("num=%d &num=%p\n", num, &num);
    printf("-------------------------------------------------\n");
    printf("&ptr1=%p ptr1=%p *ptr1=%d\n", &ptr1, ptr1, *ptr1);
    printf("-------------------------------------------------\n");
    printf("&ptr2=%p ptr2=%p *ptr2=%p **ptr2=%d\n", &ptr2, ptr2, *ptr2, **ptr2);
}
```

æ‰“å°ï¼š

```
-------------------------------------------------
num=10 &num=0x7ffeefbff430
-------------------------------------------------
&ptr1=0x7ffeefbff428 ptr1=0x7ffeefbff430 *ptr1=10
-------------------------------------------------
&ptr2=0x7ffeefbff420 ptr2=0x7ffeefbff428 *ptr2=0x7ffeefbff430 **ptr2=10
```


&emsp; ä¸Šé¢çš„å£°æ˜èŒƒä¾‹è¡¨ç¤ºå˜é‡numå­˜å‚¨çš„å€¼ä¸º10ï¼Œè€ŒæŒ‡é’ˆptr1ä¼šå­˜å‚¨å˜é‡numæ‰€å ç”¨å†…å­˜çš„å†…å­˜åœ°å€ï¼ŒæŒ‡é’ˆptr2åˆ™å­˜å‚¨æŒ‡é’ˆptr1æ‰€å ç”¨å†…å­˜çš„å†…å­˜åœ°å€ï¼Œå¦‚ä¸‹å›¾ï¼š

![å…³ç³»å›¾ <br/>](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/dataStructure0.png)


<br/>
<br/>

> <h2 id="åˆ é™¤">åˆ é™¤</h2>

![åˆ é™¤ğŸŒ°å›¾](https://upload-images.jianshu.io/upload_images/2959789-5bc0d8502b8cb7a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
typedef struct
{
    //æ•°ç»„ï¼Œå­˜å‚¨æ•°æ®å…ƒç´ 
    ElemType data[MAXSIZE];
    //çº¿æ€§è¡¨å½“å‰é•¿åº¦
    int length;                                
}SqList;

//çº¿æ€§è¡¨é¡ºåºåˆ é™¤
int listDelete(SqList *list, int i, ElemType *e){
    
    //çº¿æ€§è¡¨ä¸ºç©º
    if (list->length == 0) {
        return ERROR;
    }
    
    //åˆ é™¤ä½ç½®ä¸æ­£ç¡®
    if (i < 1 || i > list->length) {
        return ERROR;
    }
    
    //å–æ•°ç»„åœ°å€èµ‹å€¼ç»™æŒ‡é’ˆå˜é‡e
    *e = list->data[i-1];
    
    if (i < list->length) {
        for (int k = i-1; k < list->length; k ++) {
            list->data[k] = list->data[k +1];
        }
    }
    
    list->length -=1;
    
    return OK;
}


SqList list = {{1,1,1,1,1}, 5}; 
int k = 5;
int e = NULL;

listDelete(&list, k, &e);
printf("åˆ é™¤ç¬¬%dä¸ªçš„å…ƒç´ å€¼ä¸ºï¼š%d\n",k,e);
    
```
è¾“å‡ºï¼š
`åˆ é™¤ç¬¬5ä¸ªçš„å…ƒç´ å€¼ä¸ºï¼š1`




<br/>

***
<br/>

> <h1 id="çº¿æ€§è¡¨çš„é“¾å¼å­˜å‚¨">çº¿æ€§è¡¨çš„é“¾å¼å­˜å‚¨</h2>

![é“¾è¡¨åŸºæœ¬ç»“æ„](https://upload-images.jianshu.io/upload_images/2959789-d060f3ee4e965ce2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


><h2 id="å¤´æŒ‡é’ˆä½œç”¨">å¤´æŒ‡é’ˆä½œç”¨ï¼š</h2>

 
- å¤´æŒ‡é’ˆæ˜¯æŒ‡é“¾è¡¨æŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œè‹¥é“¾è¡¨æœ‰å¤´ç»“ç‚¹ï¼Œåˆ™æ˜¯æŒ‡å‘å¤´ç»“ç‚¹çš„æŒ‡é’ˆï¼›

- å¤´æŒ‡é’ˆå…·æœ‰è¡¨ç¤ºä½œç”¨ï¼Œæ‰€ä»¥å¸¸ç”¨å¤´æŒ‡é’ˆå† ä»¥é“¾è¡¨çš„åå­—ï¼›

-  æ— è®ºé“¾è¡¨æ˜¯å¦ä¸ºç©ºï¼Œå¤´æŒ‡é’ˆå‡ä¸ä¸ºç©ºã€‚å¤´æŒ‡é’ˆæ˜¯é“¾è¡¨çš„å¿…è¦å…ƒç´ ï¼›


<br/>

><h2 id="å¤´ç»“ç‚¹ä½œç”¨">å¤´ç»“ç‚¹ä½œç”¨</h2> 

- å¤´ç»“ç‚¹æ˜¯ä¸ºäº†æ“ä½œçš„çš„ç»Ÿä¸€ä¸ªæ–¹ä¾¿è€Œè®¾ç«‹çš„ï¼Œæ”¾åœ¨ç¬¬ä¸€å…ƒç´ çš„èŠ‚ç‚¹ä¹‹å‰ï¼Œå…¶æ•°æ®åŸŸä¸€èˆ¬æ— æ„ä¹‰ï¼›

- æœ‰äº†å¤´ç»“ç‚¹ï¼Œå¯¹åœ¨ç¬¬ä¸€å…ƒç´ èŠ‚ç‚¹å‰æ’å…¥èŠ‚ç‚¹å’Œåˆ é™¤ç¬¬ä¸€èŠ‚ç‚¹ï¼Œå…¶æ“ä½œä¸å…¶ä»–èŠ‚ç‚¹çš„æ“ä½œå°±ç»Ÿä¸€äº†ã€‚

-  å¤´ç»“ç‚¹ä¸ä¸€å®šæ˜¯é“¾è¡¨å¿…é¡»çš„è¦ç´ ã€‚

<br/>

![æœ‰ã€æ— å¤´ç»“ç‚¹çš„3ç§å±•ç¤º](https://upload-images.jianshu.io/upload_images/2959789-35572aad1850a435.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


<br/>
<br/>

> <h1 id="ç»“æ„ä½“èŠ‚ç‚¹çš„å®šä¹‰å’Œç”³æ˜">ç»“æ„ä½“èŠ‚ç‚¹çš„å®šä¹‰å’Œç”³æ˜</h2>

```

typedef struct Node {
    int data;
    struct Node *next;
}Node;


typedef  struct Node* LinkList; //Node* ç­‰ä»·äº LinkList

```


<br/>
<br/>
<br/>

> <h2 id="å•é“¾è¡¨çš„æ’å…¥">å•é“¾è¡¨çš„æ’å…¥</h2>

![å•é“¾è¡¨çš„æ’å…¥ç¤ºæ„å›¾](https://upload-images.jianshu.io/upload_images/2959789-a0188373ee1f6cf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



<br/>
<br/>
<br/>

> <h2 id="å¤´æ’æ³•">å¤´æ’æ³•(ä»£ç éœ€è¦æ•´ç†)</h2>


```

//åˆå§‹æ¡ä»¶ï¼šé¡ºåºçº¿æ€§è¡¨Lå·²å­˜åœ¨,1â‰¤iâ‰¤ListLength(L)
//æ“ä½œç»“æœï¼šåœ¨Lä¸­ç¬¬iä¸ªä½ç½®ä¹‹å‰æ’å…¥æ–°çš„æ•°æ®å…ƒç´ eï¼ŒLçš„é•¿åº¦åŠ 1ï¼Œè‹¥æ˜¯i=1ï¼Œç›¸å½“äºå¤´æ’æ³•
Status chainedListInsert(LinkList *list, int i, int e){
    int j = 1;
    LinkList insertNode = (LinkList)malloc(sizeof(LinkList));
    LinkList tagNode = *list;
    
    if (!(*list) || j > i) {
        return FALSE;
    }
    
    //å¯»æ‰¾ç¬¬iä¸ªç»“ç‚¹
    while (tagNode && j < i) {
        tagNode = tagNode->next;
        ++ j;
        
    }
    
    if (tagNode != NULL || i > 1) {
        insertNode->next = tagNode->next;
        tagNode->next = insertNode;
        insertNode->data = e;
       
        return TRUE;
    }
    

    return TRUE;
}


//å•é“¾è¡¨å€¼çš„éå†
int chainedListTraverse(LinkList *list){
    if ((*list)->next == NULL) {
        return FALSE;
    }
    
    printf("é“¾è¡¨çš„å€¼æ˜¯ï¼š");
    
    LinkList traverse = (*list)->next;
    while (traverse) {
        printf("%d,  ", traverse->data);
        traverse = traverse->next;
    }
    return TRUE;
}


void chainedListTest(void){
    LinkList list;
    int i, j, k, e;

for (j = 1; j <= 10; j ++) {
        chainedListInsert(&list, j, j);
    }
    printf("\n\nåœ¨listçš„è¡¨å°¾ä¾æ¬¡æ’å…¥1ï½10åï¼šlist.data=");
    chainedListTraverse(&list);
}

```

è¾“å‡ºï¼š

```
åœ¨listçš„è¡¨å°¾ä¾æ¬¡æ’å…¥1ï½10åï¼šlist.data=é“¾è¡¨çš„å€¼æ˜¯ï¼š1,  2,  3,  4,  5,  6,  7,  8,  9,  10,  
```



<br/>
<br/>


> <h3 id="å¤´æ’æ³•åˆ›å»ºé“¾è¡¨">å¤´æ’æ³•åˆ›å»ºé“¾è¡¨</h3>


![å¤´æ’æ³•åˆ›å»ºé“¾è¡¨](https://upload-images.jianshu.io/upload_images/2959789-ecc1f1d7f82c3a7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


```
typedef struct Node {
    int data;
    struct Node *next;
}Node;

typedef  struct Node* LinkList; //Node* ç­‰ä»·äº LinkList

//å¤´æ’æ³•åˆ›å»ºé“¾è¡¨
int createListOfHeadInsert(LinkList *list, int length){
    if (length < 0) {
        return  FALSE;
    }
    
    //åˆå§‹åŒ–éšæœºæ•°ç§å­
    srand(time(0));
    //å…ˆå»ºç«‹ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨
    (*list) = (LinkList)malloc(sizeof(Node));
    (*list)->next = NULL;
    
    while (length > 0) {
        LinkList insertNote = (LinkList)malloc(sizeof(Node));//æ³¨æ„ï¼šsizeofé‡Œçš„æ˜¯ç±»å‹åå­—ï¼Œä¸èƒ½æ˜¯LinkListï¼Œå®ƒæ˜¯Node *
        insertNote->data = length;  //insertNote->data = rand()%100+1;
        insertNote->next = (*list)->next;
        //æ’å…¥åˆ°è¡¨å¤´
        (*list)->next = insertNote;
        
        length --;
    }
    
    return TRUE;
}


//å•é“¾è¡¨å€¼çš„éå†
int chainedListTraverse(LinkList *list){
    if ((*list)->next == NULL) {
        return FALSE;
    }
    
    printf("é“¾è¡¨çš„å€¼æ˜¯ï¼š");
    
    LinkList traverse = (*list)->next;
    while (traverse) {
        printf("%d,  ", traverse->data);
        traverse = traverse->next;
    }
    return TRUE;
}

//é“¾è¡¨çš„åˆ é™¤
//LinkList *listç”³æ˜çš„å˜é‡ä¸­ï¼Œ*listæ˜¯ä¸€ä¸ªå˜é‡ï¼Œè€Œä¸”æ˜¯ä¸€ä¸ªæŒ‡é’ˆå˜é‡ã€‚ç›¸å½“äº int aï¼Œè¿™ä¸ªaç›¸å½“äº *list
int deleteChainedList(LinkList *list){
    
    LinkList p = (*list)->next;
    LinkList q = NULL;
    
    while (p) {
        //å…ˆåˆ¤æ–­pæ˜¯å¦å­˜åœ¨ï¼Œå†å¯¹qèµ‹å€¼ï¼Œå¦åˆ™å®¹æ˜“é€ æˆå´©æºƒ
        q = p->next;
        free(p);
        p = q;
    }
    
    //å¤´ç»“ç‚¹æŒ‡é’ˆåŸŸä¸ºç©º
    (*list)->next = NULL;
    
    return TRUE;
}



#pragma mark -- é“¾è¡¨æ–¹æ³•è°ƒç”¨
void chainedListTest(void){
    LinkList list;
    int i, j, k, e;
    

//å¤´æ’æ³•åˆ›å»ºé“¾è¡¨
    createListOfHeadInsert( &list, 20);
    chainedListTraverse(&list);
    i = deleteChainedList(&list);
    printf("\n\nå¤´æ’æ³•é“¾è¡¨åˆ é™¤åçš„å¸ƒå°”å€¼ï¼š%d(1:æ˜¯ 0:å¦)\n\n", i);
}


```
è¾“å‡ºï¼š
`é“¾è¡¨çš„å€¼æ˜¯ï¼š1,  2,  3,  4,  5,  6,  7,  8,  9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20, ` 

`å¤´æ’æ³•é“¾è¡¨åˆ é™¤åçš„å¸ƒå°”å€¼ï¼š1(1:æ˜¯ 0:å¦)`



<br/>
<br/>

<h3 id="å°¾æ’æ³•åˆ›å»ºé“¾è¡¨">å°¾æ’æ³•åˆ›å»ºé“¾è¡¨</h3>


![å°¾æ’æ³•é“¾è¡¨åˆ›å»º](https://upload-images.jianshu.io/upload_images/2959789-c1e8616b8c7f4bef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
typedef struct Node {
    int data;
    struct Node *next;
}Node;

typedef  struct Node* LinkList; //Node* ç­‰ä»·äº LinkList



//å°¾æ’æ³•åˆ›å»ºé“¾è¡¨
int createListOfTailInsert(LinkList *list, int length){
    if (length < 0) {
        return FALSE;
    }
    
    *list = (LinkList)malloc(sizeof(Node));
    //æ˜¯æŒ‡é’ˆçš„ä¸€ç§æµ…æ‹·è´ï¼Œç›¸å½“äºæ•´å‹ä¹‹é—´çš„èµ‹å€¼ä¸€æ ·
    LinkList tagNode = *list;
    
    while (length > 0) {
        LinkList insertNode = (LinkList)malloc(sizeof(Node));
        insertNode->data = length;
        //å°†è¡¨å°¾ç»ˆç«¯ç»“ç‚¹çš„æŒ‡é’ˆæŒ‡å‘æ–°ç»“ç‚¹
        tagNode->next = insertNode;
        //å°†å½“å‰çš„æ–°ç»“ç‚¹å®šä¹‰ä¸ºè¡¨å°¾ç»ˆç«¯ç»“ç‚¹
        tagNode = insertNode;
        
        length --;
    }
    
    //è¡¨ç¤ºå½“å‰é“¾è¡¨ç»“æŸ
    tagNode->next = NULL;
    
    return TRUE;
    
}


/å•é“¾è¡¨å€¼çš„éå†
int chainedListTraverse(LinkList *list){
    if ((*list)->next == NULL) {
        return FALSE;
    }
    
    printf("é“¾è¡¨çš„å€¼æ˜¯ï¼š");
    
    LinkList traverse = (*list)->next;
    while (traverse) {
        printf("%d,  ", traverse->data);
        traverse = traverse->next;
    }
    return TRUE;
}

//é“¾è¡¨çš„åˆ é™¤
//LinkList *listç”³æ˜çš„å˜é‡ä¸­ï¼Œ*listæ˜¯ä¸€ä¸ªå˜é‡ï¼Œè€Œä¸”æ˜¯ä¸€ä¸ªæŒ‡é’ˆå˜é‡ã€‚ç›¸å½“äº int aï¼Œè¿™ä¸ªaç›¸å½“äº *list
int deleteChainedList(LinkList *list){
    
    LinkList p = (*list)->next;
    LinkList q = NULL;
    
    while (p) {
        //å…ˆåˆ¤æ–­pæ˜¯å¦å­˜åœ¨ï¼Œå†å¯¹qèµ‹å€¼ï¼Œå¦åˆ™å®¹æ˜“é€ æˆå´©æºƒ
        q = p->next;
        free(p);
        p = q;
    }
    
    //å¤´ç»“ç‚¹æŒ‡é’ˆåŸŸä¸ºç©º
    (*list)->next = NULL;
    
    return TRUE;
}



#pragma mark -- é“¾è¡¨æ–¹æ³•è°ƒç”¨
void chainedListTest(void){
    LinkList list;
    int i, j, k, e;
    
 //å°¾æ’æ³•åˆ›å»ºé“¾è¡¨
    createListOfTailInsert(&list, 20);
    chainedListTraverse(&list);
    i = deleteChainedList(&list);
    printf("\n\nå°¾æ’æ³•é“¾è¡¨åˆ é™¤åçš„å¸ƒå°”å€¼ï¼š%d(1:æ˜¯ 0:å¦)", i);
    
    
    printf("\n\n");
}


```
è¾“å‡ºï¼š

```
é“¾è¡¨çš„å€¼æ˜¯ï¼š20,  19,  18,  17,  16,  15,  14,  13,  12,  11,  10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  

å°¾æ’æ³•é“¾è¡¨åˆ é™¤åçš„å¸ƒå°”å€¼ï¼š1(1:æ˜¯ 0:å¦)
```


<br/>
<br/>

> <h4 id='å°¾æ’æ³•é“¾è¡¨è§£å†³å°¾æŒ‡é’ˆèŠ‚ç‚¹è·Ÿéšæ’å…¥èŠ‚ç‚¹èµ°åŠ¨é¡¾è™‘'>å°¾æ’æ³•é“¾è¡¨: è§£å†³å°¾æŒ‡é’ˆèŠ‚ç‚¹è·Ÿéšæ’å…¥èŠ‚ç‚¹èµ°åŠ¨é¡¾è™‘</h4>
> 

```
///å¤´æ’æ³•-é“¾è¡¨
typedef struct ChainNode {
    int num;
    struct ChainNode *next;
}ChainNode, *ChainHeaderNode;



void testStructureTypeTailInsert(void){
    ChainNode *tailNode = (ChainNode *)malloc(sizeof(ChainNode));
    tailNode->next = NULL;
    ChainNode *tagNode = tailNode;
    
    int num[]= {1, 2, 3, 4, 5};
    int length = sizeof(num)/sizeof(num[0]);
    println("1- tailNodeåœ°å€:%p &tailNodeåœ°å€:%p \ntagNodeåœ°å€:%p &tagNodeåœ°å€:%p", tailNode, &tailNode, tagNode, &tagNode);

    for (int i = 0; i < length; i ++) {
        ChainNode *node = (ChainNode *)malloc(sizeof(ChainNode));
        node->next = NULL;
        node->num = num[i];
        
        tagNode->next = node;
        tagNode = node;
        println("2- nodeåœ°å€:%p &nodeåœ°å€:%p \ntagNodedåœ°å€:%p &tagNodeåœ°å€:%p", node, &node, tagNode, &tagNode);

    }
    
    ///æ³¨æ„: è¿™é‡ŒtailNodeä¸ä¼šåœ¨ç»§ç»­æŒ‡å‘tagNodeçš„åˆå§‹å€¼äº†,å› ä¸ºåæ¥tagNodeè¢«è¦†ç›–äº†.
    println("3- tailNodeåœ°å€:%p &tailNodeåœ°å€:%p \ntagNodeåœ°å€:%p &tagNodeåœ°å€:%p", tailNode, &tailNode, tagNode, &tagNode);
    
    ChainNode *node = tailNode->next;
    while (node != NULL) {
        println("é“¾è¡¨å°¾æ’æ³•:%d", node->num);
        
        node = node->next;
    }
    
}



///è°ƒç”¨
testStructureTypeTailInsert(void);
```

æ‰“å°:

```
ğŸŒ·ğŸŒ¹(Apr 16 2023:12:29:26 [20è¡Œ] testStructureTypeTailInsert) 1- tailNodeåœ°å€:0x6000007a4420 &tailNodeåœ°å€:0x7ffeef4bac28 
tagNodeåœ°å€:0x6000007a4420 &tagNodeåœ°å€:0x7ffeef4bac20
ğŸŒ·ğŸŒ¹(Apr 16 2023:12:29:26 [29è¡Œ] testStructureTypeTailInsert) 2- nodeåœ°å€:0x6000007a45b0 &nodeåœ°å€:0x7ffeef4bac10 
tagNodedåœ°å€:0x6000007a45b0 &tagNodeåœ°å€:0x7ffeef4bac20
ğŸŒ·ğŸŒ¹(Apr 16 2023:12:29:26 [29è¡Œ] testStructureTypeTailInsert) 2- nodeåœ°å€:0x6000007a4540 &nodeåœ°å€:0x7ffeef4bac10 
tagNodedåœ°å€:0x6000007a4540 &tagNodeåœ°å€:0x7ffeef4bac20
ğŸŒ·ğŸŒ¹(Apr 16 2023:12:29:26 [29è¡Œ] testStructureTypeTailInsert) 2- nodeåœ°å€:0x6000007a4480 &nodeåœ°å€:0x7ffeef4bac10 
tagNodedåœ°å€:0x6000007a4480 &tagNodeåœ°å€:0x7ffeef4bac20
ğŸŒ·ğŸŒ¹(Apr 16 2023:12:29:26 [29è¡Œ] testStructureTypeTailInsert) 2- nodeåœ°å€:0x6000007a4490 &nodeåœ°å€:0x7ffeef4bac10 
tagNodedåœ°å€:0x6000007a4490 &tagNodeåœ°å€:0x7ffeef4bac20
ğŸŒ·ğŸŒ¹(Apr 16 2023:12:29:26 [29è¡Œ] testStructureTypeTailInsert) 2- nodeåœ°å€:0x6000007a4a30 &nodeåœ°å€:0x7ffeef4bac10 
tagNodedåœ°å€:0x6000007a4a30 &tagNodeåœ°å€:0x7ffeef4bac20
ğŸŒ·ğŸŒ¹(Apr 16 2023:12:29:26 [34è¡Œ] testStructureTypeTailInsert) 3- tailNodeåœ°å€:0x6000007a4420 &tailNodeåœ°å€:0x7ffeef4bac28 
tagNodeåœ°å€:0x6000007a4a30 &tagNodeåœ°å€:0x7ffeef4bac20
ğŸŒ·ğŸŒ¹(Apr 16 2023:12:29:26 [38è¡Œ] testStructureTypeTailInsert) é“¾è¡¨å°¾æ’æ³•:1
ğŸŒ·ğŸŒ¹(Apr 16 2023:12:29:26 [38è¡Œ] testStructureTypeTailInsert) é“¾è¡¨å°¾æ’æ³•:2
ğŸŒ·ğŸŒ¹(Apr 16 2023:12:29:26 [38è¡Œ] testStructureTypeTailInsert) é“¾è¡¨å°¾æ’æ³•:3
ğŸŒ·ğŸŒ¹(Apr 16 2023:12:29:26 [38è¡Œ] testStructureTypeTailInsert) é“¾è¡¨å°¾æ’æ³•:4
ğŸŒ·ğŸŒ¹(Apr 16 2023:12:29:26 [38è¡Œ] testStructureTypeTailInsert) é“¾è¡¨å°¾æ’æ³•:5
```



<br/>
<br/>


><h1 id="å•é“¾è¡¨å…ƒç´ çš„åˆ é™¤">å•é“¾è¡¨å…ƒç´ çš„åˆ é™¤</h2>

![å•é“¾è¡¨åˆ é™¤](https://upload-images.jianshu.io/upload_images/2959789-8fa6608975cd7413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
typedef struct Node {
    int data;
    struct Node *next;
}Node;

typedef  struct Node* LinkList; //Node* ç­‰ä»·äº LinkList

//åˆå§‹æ¡ä»¶ï¼šé¡ºåºçº¿æ€§è¡¨Lå·²å­˜åœ¨,1â‰¤iâ‰¤ListLength(L)
//æ“ä½œç»“æœï¼šåœ¨Lä¸­ç¬¬iä¸ªä½ç½®ä¹‹å‰æ’å…¥æ–°çš„æ•°æ®å…ƒç´ eï¼ŒLçš„é•¿åº¦åŠ 1ï¼Œè‹¥æ˜¯i=1ï¼Œç›¸å½“äºå¤´æ’æ³•
Status chainedListInsert(LinkList *list, int i, int e){
    int j = 1;
    LinkList insertNode = (LinkList)malloc(sizeof(LinkList));
    LinkList tagNode = *list;
    
    if (!(*list) || j > i) {
        return FALSE;
    }
    
    //å¯»æ‰¾ç¬¬iä¸ªç»“ç‚¹
    while (tagNode && j < i) {
        tagNode = tagNode->next;
        ++ j;
        
    }
    
    if (tagNode != NULL || i > 1) {
        insertNode->next = tagNode->next;
        tagNode->next = insertNode;
        insertNode->data = e;
       
        return TRUE;
    }
    

    return TRUE;
}


/é“¾è¡¨çš„åˆ é™¤
//LinkList *listç”³æ˜çš„å˜é‡ä¸­ï¼Œ*listæ˜¯ä¸€ä¸ªå˜é‡ï¼Œè€Œä¸”æ˜¯ä¸€ä¸ªæŒ‡é’ˆå˜é‡ã€‚ç›¸å½“äº int aï¼Œè¿™ä¸ªaç›¸å½“äº *list
int deleteChainedList(LinkList *list){
    
    LinkList p = (*list)->next;
    LinkList q = NULL;
    
    while (p) {
        //å…ˆåˆ¤æ–­pæ˜¯å¦å­˜åœ¨ï¼Œå†å¯¹qèµ‹å€¼ï¼Œå¦åˆ™å®¹æ˜“é€ æˆå´©æºƒ
        q = p->next;
        free(p);
        p = q;
    }
    
    //å¤´ç»“ç‚¹æŒ‡é’ˆåŸŸä¸ºç©º
    (*list)->next = NULL;
    
    return TRUE;
}



//å•é“¾è¡¨å€¼çš„éå†
int chainedListTraverse(LinkList *list){
    if ((*list)->next == NULL) {
        return FALSE;
    }
    
    printf("é“¾è¡¨çš„å€¼æ˜¯ï¼š");
    
    LinkList traverse = (*list)->next;
    while (traverse) {
        printf("%d,  ", traverse->data);
        traverse = traverse->next;
    }
    return TRUE;
}



#pragma mark -- é“¾è¡¨æ–¹æ³•è°ƒç”¨
void chainedListTest(void){
    //åˆ é™¤æŸä¸€ä¸ªå…ƒç´ 
    for (j = 1; j <= 10; j ++) {
        chainedListInsert(&list, j, j);
    }
    printf("\n\nåœ¨listçš„è¡¨å°¾ä¾æ¬¡æ’å…¥1ï½10åï¼šlist.data=");
    chainedListTraverse(&list);
    j=5;
    i = deleteChainedListElement(&list,j,&e); /* åˆ é™¤ç¬¬5ä¸ªæ•°æ® */
    printf("\n\nåˆ é™¤å…ƒç´ åçš„å¸ƒå°”å€¼ï¼š%d(1:æ˜¯ 0:å¦),åˆ é™¤ç¬¬%dä¸ªçš„å…ƒç´ å€¼ä¸ºï¼š%d\n",i,j,e);
    printf("\n\nåœ¨listçš„è¡¨å°¾ä¾æ¬¡æ’å…¥1ï½9åï¼šlist.data=");
    chainedListTraverse(&list);
    i = deleteChainedList(&list);
    printf("\n\né“¾è¡¨åˆ é™¤åçš„å¸ƒå°”å€¼ï¼š%d(1:æ˜¯ 0:å¦)", i);
    
    
    //å¤´æ’æ³•åˆ›å»ºé“¾è¡¨
    
    printf("\n\n");
    
}


```
è¾“å‡ºï¼š

```
åœ¨listçš„è¡¨å°¾ä¾æ¬¡æ’å…¥1ï½10åï¼šlist.data=é“¾è¡¨çš„å€¼æ˜¯ï¼š1,  2,  3,  4,  5,  6,  7,  8,  9,  10,  

åˆ é™¤å…ƒç´ åçš„å¸ƒå°”å€¼ï¼š1(1:æ˜¯ 0:å¦),åˆ é™¤ç¬¬5ä¸ªçš„å…ƒç´ å€¼ä¸ºï¼š5


åœ¨listçš„è¡¨å°¾ä¾æ¬¡æ’å…¥1ï½9åï¼šlist.data=é“¾è¡¨çš„å€¼æ˜¯ï¼š1,  2,  3,  4,  6,  7,  8,  9,  10,  
```




<br/>


***
<br/>


> <h2 id="å¾ªç¯é“¾è¡¨">å¾ªç¯é“¾è¡¨</h2>


![å¾ªç¯é“¾è¡¨ç¤ºæ„å›¾](https://upload-images.jianshu.io/upload_images/2959789-2eb248ee9f51dc69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



<br/>

**2ä¸ªå¾ªç¯é“¾è¡¨è¿›è¡Œåˆå¹¶**
![å¾ªç¯é“¾è¡¨åˆå¹¶](https://upload-images.jianshu.io/upload_images/2959789-83a5326f42466165.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
//ä¿å­˜Aè¡¨å¤´çš„å¤´ç»“ç‚¹ï¼Œå³â‘ 
p = rearA->next;
//å°†æœ¬æ˜¯æŒ‡å‘Bè¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹(ä¸æ˜¯å¤´ç»“ç‚¹ï¼Œæ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹)èµ‹å€¼ç»™rearA->next,å³â‘¡
rearA->next = rearB->next->next;
//å°†åŸAè¡¨çš„å¤´ç»“ç‚¹èµ‹å€¼ç»™rearB->next,å³â‘¢
rearB->next = p;
//é‡Šæ”¾p
free(p);

```


å¾ªç¯é“¾è¡¨ï¼š

```
//
//  main.c
//  DataStruct
//
//  Created by Harley Huang on 20/5/2021.
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TRUE 1
#define FALSE 0

typedef int Status; // Statusæ˜¯å‡½æ•°ç»“æœçŠ¶æ€ï¼ŒæˆåŠŸè¿”å›TRUE,å¤±è´¥è¿”å›FALSE
typedef int ElemType;

/* çº¿æ€§è¡¨çš„å¾ªç¯é“¾è¡¨å­˜å‚¨ç»“æ„ */
typedef struct node
{
    ElemType data;
    struct node *next;
}Node, LinkList;

// åˆå§‹åŒ–é“¾è¡¨æ“ä½œ
void initList(LinkList **pList);
// æ’å…¥å…ƒç´ æ“ä½œ
Status insertList(LinkList *pList, int i, const ElemType e);
// åˆ é™¤å…ƒç´ æ“ä½œ
Status deleteList(LinkList *pList, int i, ElemType *e);
// è·å–å…ƒç´ æ“ä½œ
Status getElem(LinkList *pList, int i, ElemType *e);
// å¤´éƒ¨åæ’å…¥å…ƒç´ æ“ä½œ
Status insertListHead(LinkList *pList, const ElemType e);
// å°¾éƒ¨åæ’å…¥å…ƒç´ æ“ä½œ
Status insertListTail(LinkList *pList, const ElemType e);
// æ¸…ç©ºé“¾è¡¨æ“ä½œ
Status clearList(LinkList *pList);
// éå†é“¾è¡¨æ“ä½œ
void traverseList(LinkList *pList);
// è·å–é“¾è¡¨é•¿åº¦æ“ä½œ
int getLength(LinkList *pList);

int main(int argc, const char * argv[]) {
    
    
    LinkList *pList;
    
    // åˆå§‹åŒ–é“¾è¡¨
    initList(&pList);
    printf("åˆå§‹åŒ–é“¾è¡¨!\n\n");
    
    // å°¾éƒ¨åæ’å…¥ç»“ç‚¹
    insertListTail(pList, 1);
    printf("å°¾éƒ¨åæ’å…¥å…ƒç´ 1\n");
    insertListTail(pList, 2);
    printf("å°¾éƒ¨åæ’å…¥å…ƒç´ 2\n\n");
    
    // æ’å…¥ç»“ç‚¹
    insertList(pList, 1, 4);
    printf("ä½ç½®1æ’å…¥å…ƒç´ 4\n\n");
    
    // åˆ é™¤ç»“ç‚¹
    int val;
    deleteList(pList, 3, &val);
    printf("åˆ é™¤ä½ç½®3çš„ç»“ç‚¹ï¼Œåˆ é™¤ç»“ç‚¹çš„æ•°æ®ä¸ºï¼š %d\n", val);
    printf("\n");
    
    return 0;

    // éå†é“¾è¡¨å¹¶æ˜¾ç¤ºå…ƒç´ æ“ä½œ
    printf("éå†é“¾è¡¨ï¼š");
    traverseList(pList);
    printf("\n");
    
    // è·å¾—é“¾è¡¨é•¿åº¦
    printf("é“¾è¡¨é•¿åº¦: %d\n\n", getLength(pList));
    
    // é”€æ¯é“¾è¡¨
    clearList(pList);
    printf("é”€æ¯é“¾è¡¨\n\n");
    
    printf("\n\nHello, World!\n");
    return 0;
}


// åˆå§‹åŒ–é“¾è¡¨æ“ä½œ
// å¿…é¡»ä½¿ç”¨åŒé‡æŒ‡é’ˆï¼Œä¸€é‡æŒ‡é’ˆç”³è¯·ä¼šå‡ºé”™
void initList(LinkList **pList)
{
    *pList = (LinkList *)malloc(sizeof(LinkList));
    if (!pList)
    {
        printf("malloc error!\n");
        return;
    }
    
    (*pList)->data = 0;
    // å› ä¸ºæ˜¯å¾ªç¯é“¾è¡¨ï¼Œæ‰€ä»¥å°¾æŒ‡é’ˆæŒ‡å‘å¤´èŠ‚ç‚¹
    (*pList)->next = *pList;
}


// æ’å…¥å…ƒç´ æ“ä½œ
Status insertList(LinkList *pList, int i, const ElemType e)
{
    // æŒ‡å‘ä½ç½®iæ‰€åœ¨çš„å‰ä¸€ä¸ªç»“ç‚¹
    Node *front;
    // è®¡æ•°å™¨
    int j;
    
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return FALSE;
    }
    
    // åªèƒ½åœ¨ä½ç½®1ä»¥åŠåé¢æ’å…¥ï¼Œæ‰€ä»¥iè‡³å°‘ä¸º1
    if (i < 1)
    {
        printf("i is invalid!\n");
        return FALSE;
    }
    
    // æ‰¾åˆ°iä½ç½®æ‰€åœ¨çš„å‰ä¸€ä¸ªç»“ç‚¹
    front = pList;
    if (i != 1) // å¯¹i!=1çš„æƒ…å†µç‰¹æ®Šå¤„ç†
    {
        front = pList->next; // æŒ‡å‘ç¬¬2ä¸ªç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹ï¼Œä¸jå¯¹åº”
        for (j = 2; j < i; j++) // jä¸ºè®¡æ•°å™¨ï¼Œèµ‹å€¼ä¸º2ï¼Œå¯¹åº”frontæŒ‡å‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹
        {
            front = front->next;
            if (front == pList)
            {
                printf("dont find front!\n");
                return FALSE;
            }
        }
    }
    
    
    // åˆ›å»ºä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼Œå­˜æ”¾è¦æ’å…¥çš„æ–°å…ƒç´ 
    Node *temp = (Node *)malloc(sizeof(Node));
    if (!temp)
    {
        printf("malloc error!\n");
        return FALSE;
    }
    temp->data = e;
    
    // æ’å…¥ç»“ç‚¹
    temp->next = front->next;
    front->next = temp;
    
    return TRUE;
}


// åˆ é™¤å…ƒç´ æ“ä½œ
Status deleteList(LinkList *pList, int i, ElemType *e)
{
    Node *front; // æŒ‡å‘ä½ç½®iæ‰€åœ¨çš„å‰ä¸€ä¸ªç»“ç‚¹
    int j; // è®¡æ•°å™¨
    
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return FALSE;
    }
    // åªèƒ½åˆ é™¤ä½ç½®1ä»¥åŠä»¥åçš„ç»“ç‚¹
    if (i < 1)
    {
        printf("i is invalid!\n");
        return FALSE;
    }
    
    // æ‰¾åˆ°iä½ç½®æ‰€åœ¨çš„å‰ä¸€ä¸ªç»“ç‚¹
    front = pList;
    if (i != 1) // å¯¹i=1çš„æƒ…å†µç‰¹æ®Šå¤„ç†
    {
        front = pList->next; // æŒ‡å‘ç¬¬2ä¸ªç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹ï¼Œä¸jå¯¹åº”
        for (int j = 2; j < i; j++) // jä¸ºè®¡æ•°å™¨ï¼Œèµ‹å€¼ä¸º2ï¼Œå¯¹åº”frontæŒ‡å‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹
        {
            front = front->next;
            if (front->next == pList)
            {
                printf("dont find front!\n");
                return FALSE;
            }
        }
    }
    
    // æå‰ä¿å­˜è¦åˆ é™¤çš„ç»“ç‚¹
    Node *temp = front->next;
    *e = temp->data; // å°†è¦åˆ é™¤ç»“ç‚¹çš„æ•°æ®èµ‹ç»™e
    
    // åˆ é™¤ç»“ç‚¹
    front->next = front->next->next;
    
    // é”€æ¯ç»“ç‚¹
    free(temp);
    temp = NULL;
    
    return TRUE;
}

// è·å–å…ƒç´ æ“ä½œ
Status getElem(LinkList *pList, int i, ElemType *e)
{
    Node *cur;
    
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return FALSE;
    }
    // åªèƒ½è·å–ä½ç½®1ä»¥åŠä»¥åçš„å…ƒç´ 
    if (i < 1)
    {
        printf("i is invalid!\n");
        return FALSE;
    }
    
    // æ‰¾åˆ°iä½ç½®æ‰€åœ¨çš„ç»“ç‚¹
    cur = pList->next; // è¿™é‡Œæ˜¯è®©curæŒ‡å‘é“¾è¡¨çš„ç¬¬1ä¸ªç»“ç‚¹
    int j = 1; // jä¸ºè®¡æ•°å™¨ï¼Œèµ‹å€¼ä¸º1ï¼Œå¯¹åº”curæŒ‡å‘ç»“ç‚¹
    while (cur != pList && j < i)
    {
        cur = cur->next;
        j++;
    }
    // æœªæ‰¾åˆ°iä½ç½®æ‰€åœ¨çš„å‰ä¸€ä¸ªç»“ç‚¹
    if (cur == pList)
    {
        printf("dont find front!\n");
        return FALSE;
    }
    
    // å–ç¬¬iä¸ªç»“ç‚¹çš„æ•°æ®
    *e = cur->data;
    
    return TRUE;
}

// å¤´éƒ¨åæ’å…¥å…ƒç´ æ“ä½œ
Status insertListHead(LinkList *pList, const ElemType e)
{
    Node *head;
    Node *temp;
    
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return FALSE;
    }
    
    // è®©headæŒ‡å‘é“¾è¡¨çš„å¤´ç»“ç‚¹
    head = pList;
    
    // åˆ›å»ºå­˜æ”¾æ’å…¥å…ƒç´ çš„ç»“ç‚¹
    temp = (Node *)malloc(sizeof(Node));
    if (!temp)
    {
        printf("malloc error!\n");
        return FALSE;
    }
    temp->data = e;
    
    // å¤´ç»“ç‚¹åæ’å…¥ç»“ç‚¹
    temp->next = head->next;
    head->next = temp;
    
    return TRUE;
}

// å°¾éƒ¨åæ’å…¥å…ƒç´ æ“ä½œ
Status insertListTail(LinkList *pList, const ElemType e)
{
    Node *cur;
    Node *temp;
    
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return FALSE;
    }
    
    // æ‰¾åˆ°é“¾è¡¨å°¾èŠ‚ç‚¹
    cur = pList;
    while (cur->next != pList)
    {
        cur = cur->next;
    }
    
    // åˆ›å»ºå­˜æ”¾æ’å…¥å…ƒç´ çš„ç»“ç‚¹
    temp = (Node *)malloc(sizeof(Node));
    if (!temp)
    {
        printf("malloc error!\n");
        return -1;
    }
    temp->data = e;
    
    // å°¾ç»“ç‚¹åæ’å…¥ç»“ç‚¹
    temp->next = cur->next;
    cur->next = temp;
    
    return TRUE;
}

// æ¸…ç©ºé“¾è¡¨æ“ä½œ
Status clearList(LinkList *pList)
{
    Node *cur; // å½“å‰ç»“ç‚¹
    Node *temp; // äº‹å…ˆä¿å­˜ä¸‹ä¸€ç»“ç‚¹ï¼Œé˜²æ­¢é‡Šæ”¾å½“å‰ç»“ç‚¹åå¯¼è‡´â€œæ‰é“¾â€
    
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return FALSE;
    }
    
    cur = pList->next; // æŒ‡å‘å¤´ç»“ç‚¹åçš„ç¬¬ä¸€ä¸ªç»“ç‚¹
    while (cur != pList)
    {
        temp = cur->next; // äº‹å…ˆä¿å­˜ä¸‹ä¸€ç»“ç‚¹ï¼Œé˜²æ­¢é‡Šæ”¾å½“å‰ç»“ç‚¹åå¯¼è‡´â€œæ‰é“¾â€
        free(cur); // é‡Šæ”¾å½“å‰ç»“ç‚¹
        cur = NULL;
        cur = temp; // å°†ä¸‹ä¸€ç»“ç‚¹èµ‹ç»™å½“å‰ç»“ç‚¹p
    }
    pList->next = NULL; // å¤´ç»“ç‚¹æŒ‡é’ˆåŸŸæŒ‡å‘ç©º
    
    return TRUE;
}

// éå†é“¾è¡¨æ“ä½œ
void traverseList(LinkList *pList)
{
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return;
    }
    
    Node *cur = pList->next;
    while (cur != pList)
    {
        printf("%d ", cur->data);
        cur = cur->next;
    }
    printf("\n");
}

// è·å–é“¾è¡¨é•¿åº¦æ“ä½œ
int getLength(LinkList *pList)
{
    Node *cur = pList;
    int length = 0;
    
    while (cur->next != pList)
    {
        cur = cur->next;
        length++;
    }
    
    return length;
}
```

æ‰“å°ï¼š

```
åˆå§‹åŒ–é“¾è¡¨!

å°¾éƒ¨åæ’å…¥å…ƒç´ 1
å°¾éƒ¨åæ’å…¥å…ƒç´ 2

ä½ç½®1æ’å…¥å…ƒç´ 4

åˆ é™¤ä½ç½®3çš„ç»“ç‚¹ï¼Œåˆ é™¤ç»“ç‚¹çš„æ•°æ®ä¸ºï¼š 2

Program ended with exit code: 0
```




<br/>

***
<br/>


> <h1 id="åŒå‘é“¾è¡¨">åŒå‘é“¾è¡¨</h1>


![åŒå‘é“¾è¡¨çš„éç©ºé“¾è¡¨å’Œç©ºé“¾è¡¨](https://upload-images.jianshu.io/upload_images/2959789-e28b820baa20fcd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


<br/>

> <h2 id="åŒå‘é“¾è¡¨çš„æ’å…¥">åŒå‘é“¾è¡¨çš„æ’å…¥</h2>

![åŒå‘é“¾è¡¨çš„æ’å…¥](https://upload-images.jianshu.io/upload_images/2959789-00d156bcd57f5f58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



<br/>


> <h2 id="åŒå‘é“¾è¡¨çš„åˆ é™¤">åŒå‘é“¾è¡¨çš„åˆ é™¤</h2>

![åŒå‘é“¾è¡¨çš„åˆ é™¤](https://upload-images.jianshu.io/upload_images/2959789-3bd2dbc044214af7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
//æŠŠp->nextèµ‹å€¼ç»™p->priorçš„åç»§ï¼Œå³â‘ 
p->prior->next = p->next;
//æŠŠp->priorèµ‹å€¼ç»™p->nextçš„å‰ç¼€ï¼Œå³â‘¡
p->next->prior = p->prior;
//é‡Šæ”¾èŠ‚ç‚¹p
free(p);
```

ä»£ç æ¡ˆä¾‹ï¼š

```
//
//  main.c
//  DataStruct
//
//  Created by Harley Huang on 20/5/2021.
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TRUE 1
#define FALSE 0

// Statusæ˜¯å‡½æ•°ç»“æœçŠ¶æ€ï¼ŒæˆåŠŸè¿”å›TRUE,å¤±è´¥è¿”å›FALSE
typedef int Status;
typedef int ElemType;


typedef int ElemType;
// åŒå‘éå¾ªç¯é“¾è¡¨çš„ç»“æ„å®šä¹‰
typedef struct Node
{
    ElemType data;  //æ•°æ®åŸŸ
    struct Node *prior;   //æŒ‡å‘å‰é©±ç»“ç‚¹çš„æŒ‡é’ˆ
    struct Node *next;    //æŒ‡å‘åç»§ç»“ç‚¹çš„æŒ‡é’ˆ
}Node, DulList;

// åˆå§‹åŒ–é“¾è¡¨æ“ä½œ
void initList(DulList **pList);
// æ’å…¥å…ƒç´ æ“ä½œ
Status insertList(DulList *pList, int i, const ElemType e);
// åˆ é™¤å…ƒç´ æ“ä½œ
Status deleteList(DulList *pList, int i, ElemType *e);
// è·å–å…ƒç´ æ“ä½œ
Status getElem(DulList *pList, int i, ElemType *e);
// å¤´éƒ¨åæ’å…¥å…ƒç´ æ“ä½œ
Status insertListHead(DulList *pList, const ElemType e);
// å°¾éƒ¨åæ’å…¥å…ƒç´ æ“ä½œ
Status insertListTail(DulList *pList, const ElemType e);
// æ¸…ç©ºé“¾è¡¨æ“ä½œ
Status clearList(DulList *pList);
// éå†é“¾è¡¨æ“ä½œ
void traverseList(DulList *pList);
// è·å–é“¾è¡¨é•¿åº¦æ“ä½œ
int getLength(DulList *pList);




// åˆå§‹åŒ–é“¾è¡¨æ“ä½œ
void initList(DulList **pList) // å¿…é¡»ä½¿ç”¨åŒé‡æŒ‡é’ˆï¼Œä¸€é‡æŒ‡é’ˆç”³è¯·ä¼šå‡ºé”™
{
    *pList = (DulList *)malloc(sizeof(Node));
    if (!pList)
    {
        printf("malloc error!\n");
        return;
    }
    
    (*pList)->data = 0;
    (*pList)->prior = NULL;
    (*pList)->next = NULL;
}

// æ’å…¥å…ƒç´ æ“ä½œ
Status insertList(DulList *pList, int i, const ElemType e)
{
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return FALSE;
    }
    // åªèƒ½åœ¨ä½ç½®1ä»¥åŠåé¢æ’å…¥ï¼Œæ‰€ä»¥iè‡³å°‘ä¸º1
    if (i < 1)
    {
        printf("i is invalid!\n");
        return FALSE;
    }
    
    // æ‰¾åˆ°iä½ç½®æ‰€åœ¨çš„å‰ä¸€ä¸ªç»“ç‚¹
    Node *front = pList; // è¿™é‡Œæ˜¯è®©frontä¸iä¸åŒæ­¥ï¼Œå§‹ç»ˆæŒ‡å‘jå¯¹åº”çš„å‰ä¸€ä¸ªç»“ç‚¹
    for (int j = 1; j < i; j++) // jä¸ºè®¡æ•°å™¨ï¼Œèµ‹å€¼ä¸º1ï¼Œå¯¹åº”frontæŒ‡å‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œå³æ’å…¥ä½ç½®ç»“ç‚¹
    {
        front = front->next;
        if (front == NULL)
        {
            printf("dont find front!\n");
            return FALSE;
        }
    }
    
    // åˆ›å»ºä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼Œå­˜æ”¾è¦æ’å…¥çš„æ–°å…ƒç´ 
    Node *temp = (Node *)malloc(sizeof(Node));
    if (!temp)
    {
        printf("malloc error!\n");
        return FALSE;
    }
    temp->data = e;
    
    // æ’å…¥ç»“ç‚¹
    temp->prior = front;
    temp->next = front->next;
    // å½“ç©ºé“¾è¡¨ç¬¬ä¸€æ¬¡æ’å…¥ç»“ç‚¹æ—¶ï¼Œæ­¤æ—¶head->next = NULLï¼Œè°ƒç”¨NULL->priorä¼šå‡ºé”™
    if (front->next != NULL)
        front->next->prior = temp;
    front->next = temp;
    
    return TRUE;
}

// åˆ é™¤å…ƒç´ æ“ä½œ
Status deleteList(DulList *pList, int i, ElemType *e)
{
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return FALSE;
    }
    // åªèƒ½åˆ é™¤ä½ç½®1ä»¥åŠä»¥åçš„ç»“ç‚¹
    if (i < 1)
    {
        printf("i is invalid!\n");
        return FALSE;
    }
    
    // æ‰¾åˆ°iä½ç½®æ‰€åœ¨çš„å‰ä¸€ä¸ªç»“ç‚¹
    Node *front = pList; // è¿™é‡Œæ˜¯è®©frontä¸iä¸åŒæ­¥ï¼Œå§‹ç»ˆæŒ‡å‘jå¯¹åº”çš„å‰ä¸€ä¸ªç»“ç‚¹
    for (int j = 1; j < i; j++) // jä¸ºè®¡æ•°å™¨ï¼Œèµ‹å€¼ä¸º1ï¼Œå¯¹åº”frontæŒ‡å‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œå³æ’å…¥ä½ç½®ç»“ç‚¹
    {
        front = front->next;
        if (front->next == NULL)
        {
            printf("dont find front!\n");
            return FALSE;
        }
    }
    
    // æå‰ä¿å­˜è¦åˆ é™¤çš„ç»“ç‚¹
    Node *temp = front->next;
    *e = temp->data; // å°†è¦åˆ é™¤ç»“ç‚¹çš„æ•°æ®èµ‹ç»™e
    
    // åˆ é™¤ç»“ç‚¹
    if (front->next->next != NULL) // åˆ é™¤çš„ä¸æ˜¯å°¾ç»“ç‚¹ï¼Œæ‰è¿›å…¥
    {
        front->next->prior = front;
    }
    front->next = front->next->next;
    
    // é”€æ¯ç»“ç‚¹
    free(temp);
    temp = NULL;
    
    return TRUE;
}

// è·å–å…ƒç´ æ“ä½œ
Status getElem(DulList *pList, int i, ElemType *e)
{
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return FALSE;
    }
    // åªèƒ½è·å–ä½ç½®1ä»¥åŠä»¥åçš„å…ƒç´ 
    if (i < 1)
    {
        printf("i is invalid!\n");
        return FALSE;
    }
    
    // æ‰¾åˆ°iä½ç½®æ‰€åœ¨çš„ç»“ç‚¹
    Node *cur = pList->next; // è¿™é‡Œæ˜¯è®©curæŒ‡å‘é“¾è¡¨çš„ç¬¬1ä¸ªç»“ç‚¹ï¼Œä¸jåŒæ­¥
    for (int j = 1; j < i; j++) // jä¸ºè®¡æ•°å™¨ï¼Œèµ‹å€¼ä¸º1ï¼Œå¯¹åº”curæŒ‡å‘ç»“ç‚¹
    {
        cur = cur->next;
        if (cur == NULL)
        {
            printf("dont find front!\n");
            return FALSE;
        }
    }
    
    // å–ç¬¬iä¸ªç»“ç‚¹çš„æ•°æ®
    *e = cur->data;
    
    return TRUE;
}

// å¤´éƒ¨åæ’å…¥å…ƒç´ æ“ä½œ
Status insertListHead(DulList *plist, const ElemType e)
{
    Node *head;
    Node *temp;
    
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!plist)
    {
        printf("list not exist!\n");
        return FALSE;
    }
    
    // è®©headæŒ‡å‘é“¾è¡¨çš„å¤´ç»“ç‚¹
    head = plist;
    
    // åˆ›å»ºå­˜æ”¾æ’å…¥å…ƒç´ çš„ç»“ç‚¹
    temp = (Node *)malloc(sizeof(Node));
    if (!temp)
    {
        printf("malloc error!\n");
        return FALSE;
    }
    temp->data = e;
    
    // å¤´ç»“ç‚¹åæ’å…¥ç»“ç‚¹
    temp->prior = head;
    temp->next = head->next;
    // å½“ç©ºé“¾è¡¨ç¬¬ä¸€æ¬¡æ’å…¥ç»“ç‚¹æ—¶ï¼Œæ­¤æ—¶head->next = NULLï¼Œè°ƒç”¨NULL->priorä¼šå‡ºé”™
    if (head->next != NULL)
        head->next->prior = temp;
    head->next = temp;
    
    return TRUE;
}

// å°¾éƒ¨åæ’å…¥å…ƒç´ æ“ä½œ
Status insertListTail(DulList *pList, const ElemType e)
{
    Node *cur;
    Node *temp;
    
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return FALSE;
    }
    
    // æ‰¾åˆ°é“¾è¡¨å°¾èŠ‚ç‚¹
    cur = pList;
    while (cur->next)
    {
        cur = cur->next;
    }
    
    // åˆ›å»ºå­˜æ”¾æ’å…¥å…ƒç´ çš„ç»“ç‚¹
    temp = (Node *)malloc(sizeof(Node));
    if (!temp)
    {
        printf("malloc error!\n");
        return -1;
    }
    temp->data = e;
    
    // å°¾ç»“ç‚¹åæ’å…¥ç»“ç‚¹
    temp->prior = cur;
    temp->next = cur->next;
    cur->next = temp; // å°¾ç»“ç‚¹çš„ç›´æ¥åç»§æŒ‡é’ˆæ˜¯NULLï¼Œæ‰€ä»¥ä¸ç”¨æŒ‡å®šNULLçš„å‰é©±æŒ‡é’ˆ
    
    return TRUE;
}

// æ¸…ç©ºé“¾è¡¨æ“ä½œ
Status clearList(DulList *pList)
{
    Node *cur; // å½“å‰ç»“ç‚¹
    Node *temp; // äº‹å…ˆä¿å­˜ä¸‹ä¸€ç»“ç‚¹ï¼Œé˜²æ­¢é‡Šæ”¾å½“å‰ç»“ç‚¹åå¯¼è‡´â€œæ‰é“¾â€
    
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return FALSE;
    }
    
    cur = pList->next; // æŒ‡å‘ç¬¬ä¸€ä¸ªç»“ç‚¹
    while (cur)
    {
        temp = cur->next; // äº‹å…ˆä¿å­˜ä¸‹ä¸€ç»“ç‚¹ï¼Œé˜²æ­¢é‡Šæ”¾å½“å‰ç»“ç‚¹åå¯¼è‡´â€œæ‰é“¾â€
        free(cur); // é‡Šæ”¾å½“å‰ç»“ç‚¹
        cur = temp; // å°†ä¸‹ä¸€ç»“ç‚¹èµ‹ç»™å½“å‰ç»“ç‚¹p
    }
    pList->next = NULL; // å¤´ç»“ç‚¹æŒ‡é’ˆåŸŸæŒ‡å‘ç©º
    
    return TRUE;
}

// éå†é“¾è¡¨æ“ä½œ
void traverseList(DulList *pList)
{
    // åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨
    if (!pList)
    {
        printf("list not exist!\n");
        return;
    }
    
    Node *cur = pList->next;
    while (cur != NULL)
    {
        printf("%d ", cur->data);
        cur = cur->next;
    }
    printf("\n");
}

// è·å–é“¾è¡¨é•¿åº¦æ“ä½œ
int getLength(DulList *pList)
{
    Node *cur = pList;
    int length = 0;
    
    while (cur->next)
    {
        cur = cur->next;
        length++;
    }
    
    return length;
}

int main(int argc, const char * argv[]) {
    
    
    DulList *pList;
    
    // åˆå§‹åŒ–é“¾è¡¨
    initList(&pList);
    printf("åˆå§‹åŒ–é“¾è¡¨!\n\n");
    
    // å°¾éƒ¨åæ’å…¥ç»“ç‚¹
    printf("å°¾éƒ¨åæ’å…¥å…ƒç´ 1ã€2ã€3\n\n");
    for (int i = 0; i < 3; i++)
    {
        insertListTail(pList, i+1);
    }
    
    // å¤´éƒ¨åæ’å…¥å…ƒç´ 
    insertListHead(pList, 5);
    printf("å¤´éƒ¨åæ’å…¥å…ƒç´ 5\n\n");
    
    // æ’å…¥ç»“ç‚¹
    insertList(pList, 1, 9);
    printf("åœ¨ä½ç½®1æ’å…¥å…ƒç´ 9\n\n");
    
    // éå†é“¾è¡¨å¹¶æ˜¾ç¤ºå…ƒç´ æ“ä½œ
    printf("éå†é“¾è¡¨ï¼š");
    traverseList(pList);
    printf("\n");
    
    // åˆ é™¤ç»“ç‚¹
    int val;
    deleteList(pList, 2, &val);
    printf("åˆ é™¤ä½ç½®2çš„ç»“ç‚¹ï¼Œåˆ é™¤ç»“ç‚¹çš„æ•°æ®ä¸ºï¼š %d\n", val);
    printf("\n");
    
    // éå†é“¾è¡¨å¹¶æ˜¾ç¤ºå…ƒç´ æ“ä½œ
    printf("éå†é“¾è¡¨ï¼š");
    traverseList(pList);
    printf("\n");
    
    // è·å¾—é“¾è¡¨é•¿åº¦
    printf("é“¾è¡¨é•¿åº¦: %d\n\n", getLength(pList));
    
    // é”€æ¯é“¾è¡¨
    clearList(pList);
    printf("é”€æ¯é“¾è¡¨\n\n");
    
    
    printf("\n\nHello, World!\n");
    return 0;
}


```

æ‰“å°ï¼š

```
åˆå§‹åŒ–é“¾è¡¨!

å°¾éƒ¨åæ’å…¥å…ƒç´ 1ã€2ã€3

å¤´éƒ¨åæ’å…¥å…ƒç´ 5

åœ¨ä½ç½®1æ’å…¥å…ƒç´ 9

éå†é“¾è¡¨ï¼š9 5 1 2 3 

åˆ é™¤ä½ç½®2çš„ç»“ç‚¹ï¼Œåˆ é™¤ç»“ç‚¹çš„æ•°æ®ä¸ºï¼š 5

éå†é“¾è¡¨ï¼š9 1 2 3 

é“¾è¡¨é•¿åº¦: 4

é”€æ¯é“¾è¡¨

```




<br/>

***
<br/>



> <h1 id="é“¾æ ˆ">é“¾æ ˆ</h1>


**`å…¬å…±Code`**

```
typedef struct StackNode{
    int data;
    struct StackNode *next;
}StackNode, *LinkStackPtr;

typedef struct{
    LinkStackPtr top;
    int count;
} LinkStack;


void linkStackTestMethod(void);


//é“¾æ ˆçš„åˆå§‹åŒ–
int initWithStack(LinkStack *linkStack){
    linkStack->top = (LinkStackPtr)malloc(sizeof(StackNode));
    if (!linkStack->top) {
        return FALSE;
    }
    
    linkStack->top = NULL;
    linkStack->count = 0;
    return TRUE;
}

//åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
int isLinkStackEmpty(LinkStack *linkStack){
    if (linkStack->count > 0) {
        return TRUE;
    }else {
        return FALSE;
    }
}

//æ ˆå…ƒç´ éå†
int linkStackTraverse(LinkStack linkStack){
    if (linkStack.count > 0) {
        StackNode *node = linkStack.top;
        while (node) {
            printf(" %d,", node->data);
            node = node->next;
        }
    }else {
        return FALSE;
    }
    
    printf("\n\n");

    return TRUE;
}

```



<br/>

> <h2 id="è¿›æ ˆ">è¿›æ ˆ</h2>



![é“¾æ ˆ push](https://upload-images.jianshu.io/upload_images/2959789-2c0eb860c19ad0d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```

//æ ˆçš„push
int pushInStack(LinkStack *linkStack, int data){
    
    StackNode *insertNode = (StackNode *)malloc(sizeof(StackNode));
    insertNode->data = data;
    //æŠŠå½“å‰çš„æ ˆé¡¶å…ƒç´ èµ‹å€¼ç»™æ–°ç»“ç‚¹çš„ç›´æ¥åç»§ï¼Œè§å›¾ä¸­â‘ 
    insertNode->next = linkStack->top;
    
    //å°†æ–°çš„ç»“ç‚¹sèµ‹å€¼ç»™æ ˆé¡¶æŒ‡é’ˆï¼Œè§å›¾ä¸­â‘¡
    linkStack->top = insertNode;
    linkStack->count ++;
    
    return TRUE;
}

void linkStackTestMethod(void){
    
    LinkStack linkStack;
    
    int statusCode = initWithStack(&linkStack);
    if (statusCode) {
        for (int i = 0; i <11; i ++) {
            pushInStack(&linkStack, i);
        }
    }
    linkStackTraverse(linkStack);
}
```
è¾“å‡ºï¼š

```
10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
```

<br/>
<br/>


> <h2 id="å‡ºæ ˆ">å‡ºæ ˆ</h2>


![é“¾æ ˆå‡ºæ ˆ](https://upload-images.jianshu.io/upload_images/2959789-c5843a9274fcf77f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
//æ ˆçš„pop
int pushOutStack(LinkStack *linkStack,int *data){
    //å°†æ ˆé¡¶ç»“ç‚¹èµ‹å€¼ç»™pï¼Œè§å›¾ä¸­â‘¢
    StackNode *outNode = linkStack->top;
    *data = outNode->data;  //ä¸èƒ½æ˜¯data = &(outNode->data),è¿™æ˜¯æŠŠå®ƒçš„åœ°å€å€¼èµ‹ç»™data

    //ä½¿å¾—æ ˆé¡¶æŒ‡é’ˆä¸‹ç§»ä¸€ä½ï¼ŒæŒ‡å‘åä¸€ç»“ç‚¹ï¼Œè§å›¾ä¸­â‘£
    linkStack->top = outNode->next;
    //é‡Šæ”¾ç»“ç‚¹p
    free(outNode);
    linkStack->count--;
    
    return TRUE;
}


void linkStackTestMethod(void){
    
    LinkStack linkStack;
    
    int statusCode = initWithStack(&linkStack);
    if (statusCode) {
        for (int i = 0; i <11; i ++) {
            pushInStack(&linkStack, i);
        }
    }
    
    int popE;
    pushOutStack(&linkStack, &popE);
    printf("å‡ºæ ˆçš„å…ƒç´ popEæ˜¯ï¼š%d\n\n",popE);
    linkStackTraverse(linkStack);
}
```
è¾“å‡ºï¼š

```
å‡ºæ ˆçš„å…ƒç´ popEæ˜¯ï¼š10

9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
```

<br/>
<br/>

> <h2 id="æ¸…ç©ºæ ˆå…ƒç´ ">æ¸…ç©ºæ ˆå…ƒç´ </h2>


```
//æ¸…ç©ºæ ˆ
int clearLinkStack(LinkStack *linkStack){
    if (linkStack->count == 0) {
        return FALSE;
    }
    
    StackNode *deleteNode = linkStack->top;
    while (deleteNode) {
        linkStack->top = deleteNode->next;
        free(deleteNode);
        deleteNode = linkStack->top;
    }
    linkStack->count = 0;
    return TRUE;
}


void linkStackTestMethod(void){
    
    LinkStack linkStack;
    
    int statusCode = initWithStack(&linkStack);
    if (statusCode) {
        for (int i = 0; i <11; i ++) {
            pushInStack(&linkStack, i);
        }
    }


    statusCode = clearLinkStack(&linkStack);
    linkStackTraverse(linkStack);
    printf("æ¸…ç©ºæ ˆåï¼Œæ ˆç©ºå¦ï¼š%d(1:ç©º 0:å¦)", statusCode);
    
    printf("\n\n");
}
```

è¾“å‡ºï¼š

```
æ¸…ç©ºæ ˆåï¼Œæ ˆç©ºå¦ï¼š1(1:ç©º 0:å¦)
```


<br/>
<br/>

># <h2 id='å››åˆ™è¿ç®—è¡¨è¾¾å¼æ ˆçš„åº”ç”¨'>å››åˆ™è¿ç®—è¡¨è¾¾å¼(æ ˆçš„åº”ç”¨)</h2> 

ä¸­ç¼€è¡¨è¾¾å¼ï¼š` 9+(3-1)x3+10Ã·2 `

åç¼€è¡¨è¾¾å¼ï¼š` 9 3 1 - 3 x + 10 2 Ã· + `

- **`åç¼€è¡¨è¾¾å¼è§„åˆ™ï¼š`**
&emsp; ä»å·¦åˆ°å³éå†è¡¨è¾¾å¼çš„æ¯ä¸ªæ•°å­—å’Œç¬¦å·ï¼Œé‡åˆ°æ˜¯æ•°å­—å°±è¿›æ ˆï¼Œé‡åˆ°æ˜¯ç¬¦å·ï¼Œå°±å°†å¤„äºæ ˆé¡¶ä¸¤ä¸ªæ•°å­—å‡ºæ ˆï¼Œè¿›è¡Œè¿ç®—ï¼Œè¿ç®—ç»“æœè¿›æ ˆï¼Œä¸€ç›´åˆ°æœ€ç»ˆè·å¾—ç»“æœã€‚

- **`åç¼€è¡¨è¾¾å¼è®¡ç®—:`**
&emsp;  å°†åç¼€è¡¨è¾¾å¼ä»å·¦åˆ°å³ä¾æ¬¡éå†ï¼Œå¦‚æœå½“å‰å…ƒç´ ä¸ºæ•°å­—åˆ™å…¥ï¼ˆæ“ä½œæ•°ï¼‰æ ˆï¼Œå¦‚æœä¸ºæ“ä½œç¬¦ï¼Œåˆ™popå‡ºæ ˆé¡¶ä¸¤ä¸ªå…ƒç´ ï¼ˆç¬¬ä¸€æ¬¡popå‡ºçš„æ˜¯å³æ“ä½œæ•°ï¼Œç¬¬äºŒæ¬¡popå‡ºçš„æ˜¯å·¦æ“ä½œæ•°ï¼‰è¿›è¡Œè¿ç®—ï¼Œç„¶åå°†è®¡ç®—ç»“æœå†æ¬¡å…¥æ ˆï¼Œç›´è‡³è¡¨è¾¾å¼ç»“æŸï¼Œæ­¤æ—¶æ“ä½œæ•°æ ˆå†…ç†åº”åªå‰©ä¸€ä¸ªå…ƒç´ å³è¡¨è¾¾å¼ç»“æœã€‚


<br/>

- **`ä¸­ç¼€è½¬åç¼€è§„åˆ™ï¼š`**

&emsp;  â‘ .  ä»å·¦åˆ°å³éå†ä¸­ç¼€è¡¨è¾¾å¼ä¸­çš„æ¯ä¸ªæ•°å­—å’Œç¬¦å·ï¼›

&emsp;  â‘¡.  è‹¥æ˜¯æ•°å­—å°±è¾“å‡ºï¼Œå³æˆä¸ºåç¼€è¡¨è¾¾å¼çš„ä¸€éƒ¨åˆ†ï¼›

&emsp;  â‘¢.  è‹¥æ˜¯ç¬¦å·ï¼Œåˆ™åˆ¤æ–­å…¶ä¸æ ˆé¡¶ç¬¦å·çš„ä¼˜å…ˆçº§ï¼Œæ˜¯å³æ‹¬å·æˆ–ä¼˜å…ˆçº§ä½äºæ ˆé¡¶ç¬¦å·(ä¹˜é™¤ä¼˜å…ˆåŠ å‡)åˆ™æ ˆé¡¶å…ƒç´ å‡ºæ ˆå¹¶è¾“å‡ºï¼Œå¹¶å°†å½“å‰ç¬¦å·è¿›æ ˆï¼Œä¸€ç›´åˆ°æœ€ç»ˆè¾“å‡ºåç¼€è¡¨è¾¾å¼ä¸ºæ­¢ã€‚

<br/>

**`ä¸­ç¼€è½¬åç¼€è¯¦ç»†è¿‡ç¨‹ï¼š`**

&emsp;  â‘ . éå†ä¸­ç¼€è¡¨è¾¾å¼ï¼›

&emsp;  â‘¡. å¦‚æœå½“å‰ä¸­ç¼€å…ƒç´ ä¸ºæ“ä½œæ•°ï¼Œåˆ™ç›´æ¥å°†æ­¤æ“ä½œæ•°â€œè¾“å‡ºâ€åˆ°åç¼€è¡¨è¾¾å¼å°¾ç«¯ï¼›

&emsp;  â‘¢. å¦‚æœå½“å‰ä¸­ç¼€å…ƒç´ ä¸º'*'ï¼Œ'/'æˆ–'('ï¼Œç›´æ¥pushå…¥æ“ä½œç¬¦æ ˆï¼›

&emsp;  â‘£. å¦‚æœå½“å‰ä¸­ç¼€å…ƒç´ ä¸º')'ï¼Œåˆ™ä¾æ¬¡popå‡ºæ ˆé¡¶æ“ä½œç¬¦ï¼Œâ€œè¾“å‡ºâ€åˆ°åç¼€è¡¨è¾¾å¼å°¾ç«¯ï¼Œç›´è‡³popå¾—åˆ°çš„æ˜¯ä¸€ä¸ª'('æ‰åœæ­¢ï¼Œå¹¶ä¸¢å¼ƒè¯¥'('ï¼›

&emsp;  â‘¤. å¦‚æœå½“å‰ä¸­ç¼€å…ƒç´ ä¸º'+'æˆ–'-'ï¼Œåˆ™ä¾æ¬¡popå‡ºæ ˆé¡¶æ“ä½œç¬¦ã€â€œè¾“å‡ºâ€åˆ°åç¼€è¡¨è¾¾å¼å°¾ç«¯ï¼Œç›´è‡³æ ˆåº•ï¼ˆæ ˆç©ºï¼‰æˆ–popå¾—åˆ°äº†ä¸€ä¸ª'('ï¼Œè‹¥popå¾—åˆ°ä¸€ä¸ª'('ï¼Œå°†'('é‡æ–°pushå…¥æ ˆã€‚è¾¾åˆ°è¿™ä¸¤ä¸ªæ¡ä»¶ä¹‹ä¸€åï¼Œå°†æ­¤æ“ä½œç¬¦ï¼ˆ'+'æˆ–'-'ï¼‰å…¥æ ˆï¼›
&emsp; 

 â‘¥. å¦‚æœå½“å‰ä¸­ç¼€å…ƒç´ ä¸º'='ï¼Œåˆ™ä¾æ¬¡popå‡ºæ ˆé¡¶æ“ä½œç¬¦ã€â€œè¾“å‡ºâ€åˆ°åç¼€è¡¨è¾¾å¼å°¾ç«¯ï¼Œç›´è‡³æ ˆåº•ï¼ˆæ ˆç©ºï¼‰ã€‚

&emsp;  `æ³¨æ„`ï¼šæ ¹æ®â‘£ã€â‘¤ä¸¤ç‚¹ï¼Œå¯ä»¥çœ‹å‡ºï¼šåªæœ‰éå†åˆ°')'æ‰ä¼šå¯¼è‡´'('å¼¹å‡ºï¼Œå…¶å®ƒæ“ä½œç¬¦å‡ä¸ä¼šä½¿'('å¼¹å‡ºã€‚


<br/>

**`å®Œæ•´Code`**

`Arithmetic.h æ–‡ä»¶`

```
#ifndef Arithmetic_h
#define Arithmetic_h

#include <stdio.h>
#include <stdlib.h>

#include "LinearListStoragge.h"

typedef struct OperationNode{
    char operation;
    struct OperationNode *next;
} OperationNode;


typedef struct {
    struct OperationNode *top;
    int count;
} OperationStack;



typedef struct CharacterNode{
    char number;
    struct CharacterNode *next;
} CharacterNode;

//åç¼€è¡¨è¾¾å¼æ ˆ
typedef struct {
    struct CharacterNode *top;
    int count;
} PostfixStack;

void arithmeticCalculateTest(void);

#endif /* Arithmetic_h */
```


<br/>

`Arithmetic.c æ–‡ä»¶`

```

//
//  Arithmetic.c
//  DataStructure
//
//  Created by Harley on 2019/4/17.
//  Copyright Â© 2019 Harley'sMac. All rights reserved.
//

#include "Arithmetic.h"
#include <string.h>

//å‰ç¼€è¡¨è¾¾å¼å­—ç¬¦æ•°ç»„
char PrefixCharacter[100];

//æ“ä½œç¬¦æ ˆåˆå§‹åŒ–
int initWithOperationStack(OperationStack *operataionStack){
    operataionStack->top = (OperationNode *)malloc(sizeof(OperationNode));
    if (!operataionStack->top) {
        return FALSE;
    }
    operataionStack->top = NULL;
    operataionStack->count = 0;
    
    return TRUE;
}

//åç¼€è¡¨è¾¾å¼æ ˆåˆå§‹åŒ–
int initWithPostfixStack(PostfixStack *postfixStack){
    postfixStack->top = (CharacterNode *)malloc(sizeof(CharacterNode));
    if (!postfixStack->top) {
        return FALSE;
    }
    
    postfixStack->top = NULL;
    postfixStack->count = 0;
    
    return TRUE;
}

//æ“ä½œæ•°è¿›æ ˆ
int pushOperand(PostfixStack *postfixStack, char character){
    CharacterNode *insertNode = (CharacterNode *)malloc(sizeof(CharacterNode));
    if (!insertNode) {
        return FALSE;
    }
    insertNode->number = character;
    insertNode->next = postfixStack->top;
    
    postfixStack->top = insertNode;
    postfixStack->count ++;
    
    
    return TRUE;
}

//æ“ä½œæ•°å‡ºæ ˆ
int popOperand(PostfixStack *postfixStack, char *character){

    CharacterNode *deleteNode = postfixStack->top;
    *character = deleteNode->number;
    postfixStack->top = deleteNode->next;
    postfixStack->count--;
    
    free(deleteNode);
    
    return TRUE;
}

//æ“ä½œç¬¦è¿›æ ˆ
int pushOperator(OperationStack *operationStack, char character){
    if (!character) {
        return FALSE;
    }
    
    OperationNode *insertNode = (OperationNode *)malloc(sizeof(OperationNode));
    insertNode->next = operationStack->top;
    insertNode->operation = character;
    
    operationStack->top = insertNode;
    operationStack->count ++;
    
    return TRUE;
}


//æ“ä½œç¬¦å‡ºæ ˆ
int popOperator(OperationStack *operationStack, char *character){
    OperationNode *deleteNode = operationStack->top;
    if (deleteNode == NULL) {
        return FALSE;
    }
    *character = deleteNode->operation;
    operationStack->top = deleteNode->next;
    operationStack->count --;

    free(deleteNode);
    
    return TRUE;
}

//å¯¹å­—ç¬¦å’Œæ•°å­—è¿›è¡Œå­˜å‚¨
void judgeNumberOrCharacter(char character){
    
    //åˆ¤æ–­ä¸ºæ•°å­—
//    if (character >= '0' && character <= '9') {
//        pushOperand(<#PostfixStack *postfixStack#>, <#char character#>)
//    }
}

void traversePostfixStack(PostfixStack postfixStack){
    printf("åç¼€è¡¨è¾¾å¼æ˜¯ï¼š");
    while (postfixStack.top != NULL) {
        CharacterNode *node = postfixStack.top;
        printf("%c  ", node->number);
        postfixStack.top = node->next;
    }
    printf("\n\n");
}

void traverseOperationStack(OperationStack operationStack){
    printf("ç¬¦å·æ ˆæ˜¯ï¼š");
    while (operationStack.top != NULL) {
        OperationNode *node = operationStack.top;
        printf("%c  ", node->operation);
        operationStack.top = node->next;
    }
    printf("\n\n");
}

//åç¼€è¡¨è¾¾å¼è®¡ç®—
int postfixExpressionCalculate(PostfixStack postfixStack){
    CharacterNode *node = postfixStack.top;
    if (node == NULL) {
        return FALSE;
    }
    
    PostfixStack inverseOrder;
    PostfixStack resultStack;
    
    int statusDatus = initWithPostfixStack(&resultStack);
    int statusCode = initWithPostfixStack(&inverseOrder);
    printf("åç¼€è¡¨è¾¾å¼é€†åº%d(1 æˆåŠŸ  0 å¤±è´¥)\n\n", statusCode);
    
    while (postfixStack.top != NULL) {
        char character = '\0';
        popOperand(&postfixStack, &character);
        pushOperand(&inverseOrder, character);
    }
    
    traversePostfixStack(inverseOrder);
    
    //è®¡ç®—åç¼€è¡¨è¾¾å¼
    while (inverseOrder.top != NULL) {
        char character = '\0';
        char leftNumber = '\0';
        char rightNumber = '\0';
        int result = 0;
        
        popOperand(&inverseOrder, &character);
        
        if (character >= '0' && character <= '9') {
            pushOperand(&resultStack, character);
        }else {
            switch (character) {
                case '+':{
                    popOperand(&resultStack, &rightNumber);
                    popOperand(&resultStack, &leftNumber);
                    
                    leftNumber -= 48;
                    rightNumber -= 48;
                    result = rightNumber + leftNumber;
                }
                    break;
                    
                case '-':{
                    popOperand(&resultStack, &rightNumber);
                    popOperand(&resultStack, &leftNumber);
                    
                    leftNumber -= 48;
                    rightNumber -= 48;
                    result = leftNumber - rightNumber;
                }
                    break;
                    
                case '*':{
                    popOperand(&resultStack, &rightNumber);
                    popOperand(&resultStack, &leftNumber);
                    
                    leftNumber -= 48;
                    rightNumber -= 48;
                    result = leftNumber * rightNumber;
                }
                    break;
                    
                case '/':{
                    popOperand(&resultStack, &rightNumber);
                    popOperand(&resultStack, &leftNumber);
                    
                    leftNumber -= 48;
                    rightNumber -= 48;
                    result = leftNumber / rightNumber;
                }
                    break;
                    
                default:
                    break;
            }
            //å°†è®¡ç®—çš„ç»“æœè¿›è¡Œå…¥æ ˆ,å­—ç¬¦ä¸æ•°å€¼ç›¸å·®48
            pushOperand(&resultStack, (result +48));
            printf("%d %c %d = %d \n", leftNumber, character, rightNumber, result);

        }
    }
    
    char result = '\0';
    popOperand(&resultStack, &result);
    printf("ç»“æœå€¼æ˜¯ï¼š%d", (result -48));

    return TRUE;
    
}


void arithmeticCalculateTest(void){
    
    //çŠ¶æ€ç 
    int statusCode = 0;
    //å­—ç¬¦æ ˆ
    OperationStack operationStack;
    PostfixStack postfixStack;
    
    statusCode = initWithOperationStack(&operationStack);
    printf("æ“ä½œç¬¦æ ˆåˆå§‹åŒ–æˆåŠŸ%d(1æ˜¯ 0å¦)\n\n", statusCode);
    
    statusCode = initWithPostfixStack(&postfixStack);
    printf("åç¼€è¡¨è¾¾å¼æ ˆåˆå§‹åŒ–æˆåŠŸ%d(1æ˜¯ 0å¦)\n\n", statusCode);
    
    //å­—ç¬¦ä¸²æ•°ç»„ï¼ŒCè¯­è¨€æ²¡æœ‰å­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²ä½¿ç”¨å­—ç¬¦ç»„æˆçš„æ•°ç»„
    char prefixCharacter[] = "9+(3-1)*3+8/2=";
    printf("ä¸­ç¼€è¡¨è¾¾å¼æ˜¯ï¼š%s\n\n", prefixCharacter);

    for (int i = 0; i< strlen(prefixCharacter); i++) {
        
        traversePostfixStack(postfixStack);
        traverseOperationStack(operationStack);
        
        //åˆ¤æ–­ä¸ºæ•°å­—
        if (prefixCharacter[i] >= '0' && prefixCharacter[i] <= '9') {
            pushOperand(&postfixStack, prefixCharacter[i]);
        }else {
            printf("-->> %c\n", prefixCharacter[i]);

            switch (prefixCharacter[i]) {            //å¦‚æœå½“å‰ä¸­ç¼€å…ƒç´ ä¸º'+'æˆ–'-'ï¼Œåˆ™ä¾æ¬¡popå‡ºæ ˆé¡¶æ“ä½œç¬¦ã€â€œè¾“å‡ºâ€åˆ°åç¼€è¡¨è¾¾å¼å°¾ç«¯ï¼Œç›´è‡³æ ˆåº•ï¼ˆæ ˆç©ºï¼‰æˆ–popå¾—åˆ°äº†ä¸€ä¸ª'('ï¼Œè‹¥popå¾—åˆ°ä¸€ä¸ª'('ï¼Œå°†'('é‡æ–°pushå…¥æ ˆã€‚è¾¾åˆ°è¿™ä¸¤ä¸ªæ¡ä»¶ä¹‹ä¸€åï¼Œå°†æ­¤æ“ä½œç¬¦ï¼ˆ'+'æˆ–'-'ï¼‰å…¥æ ˆï¼›
                case '+':{
                    char character = '\0';
                    while (character != '(') {
                        popOperator(&operationStack, &character);
                        if (character != '(' && character != '\0') {
                            pushOperand(&postfixStack, character);
                            if (operationStack.top == NULL) {//å‡ºæ ˆåˆ°æ ˆé¡¶ï¼Œè·³å‡ºå¾ªç¯å°†ç°åœ¨çš„'+'å…¥æ ˆ
                                pushOperator(&operationStack, '+');
                                break;
                            }
                        }else {
                            pushOperator(&operationStack, character);
                            pushOperator(&operationStack, '+');
                            break;
                        }
                    }
                }
                    break;
                    
                case '-':{
                    char character = '\0';
                    while (character != '(') {
                        popOperator(&operationStack, &character);
                        if (character != '('  && character != '\0') {
                            pushOperand(&postfixStack, character);
                            if (operationStack.top == NULL) {//å‡ºæ ˆåˆ°æ ˆé¡¶ï¼Œè·³å‡ºå¾ªç¯å°†ç°åœ¨çš„'+'å…¥æ ˆ
                                pushOperator(&operationStack, '-');
                                break;
                            }
                        }else {//é‡åˆ°'('è·³å‡ºå¾ªç¯
                            pushOperator(&operationStack, character);
                            pushOperator(&operationStack, '-');
                            break;
                        }
                    }
                }
                    break;
                    
                case '*':{
                    pushOperator(&operationStack, '*');
                }
                    break;
                    
                case '/':{
                    pushOperator(&operationStack, '/');
                }
                    break;
                    
                case '(':{
                    pushOperator(&operationStack, '(');
                }
                    break;
                    
                case ')':{  //å¦‚æœå½“å‰ä¸­ç¼€å…ƒç´ ä¸º')'ï¼Œåˆ™ä¾æ¬¡popå‡ºæ ˆé¡¶æ“ä½œç¬¦ï¼Œâ€œè¾“å‡ºâ€åˆ°åç¼€è¡¨è¾¾å¼å°¾ç«¯ï¼Œç›´è‡³popå¾—åˆ°çš„æ˜¯ä¸€ä¸ª'('æ‰åœæ­¢ï¼Œå¹¶ä¸¢å¼ƒè¯¥'('
                    char character = '\0';
                    while (character != '(') {
                        popOperator(&operationStack, &character);
                        if (character != '(') {
                            pushOperand(&postfixStack, character);
                        }else{
                            break;
                        }
                    }
                }
                    break;
                    
                case '=':{
                    char character = '\0';
                    while (operationStack.top != NULL) {
                        popOperator(&operationStack, &character);
                        pushOperand(&postfixStack, character);
                    }
                    
                }
                    break;
                    
                default:
                    break;
            }
        }
    }
    
    traversePostfixStack(postfixStack);
    
    postfixExpressionCalculate(postfixStack);
    
}



```

`è¾“å‡ºæ‰“å°ï¼š`

```

æ“ä½œç¬¦æ ˆåˆå§‹åŒ–æˆåŠŸ1(1æ˜¯ 0å¦)

åç¼€è¡¨è¾¾å¼æ ˆåˆå§‹åŒ–æˆåŠŸ1(1æ˜¯ 0å¦)

ä¸­ç¼€è¡¨è¾¾å¼æ˜¯ï¼š9+(3-1)*3+8/2=

åç¼€è¡¨è¾¾å¼æ˜¯ï¼š

ç¬¦å·æ ˆæ˜¯ï¼š

åç¼€è¡¨è¾¾å¼æ˜¯ï¼š9  

ç¬¦å·æ ˆæ˜¯ï¼š

-->> +
åç¼€è¡¨è¾¾å¼æ˜¯ï¼š9  

ç¬¦å·æ ˆæ˜¯ï¼š+  

-->> (
åç¼€è¡¨è¾¾å¼æ˜¯ï¼š9  

ç¬¦å·æ ˆæ˜¯ï¼š(  +  

åç¼€è¡¨è¾¾å¼æ˜¯ï¼š3  9  

ç¬¦å·æ ˆæ˜¯ï¼š(  +  

-->> -
åç¼€è¡¨è¾¾å¼æ˜¯ï¼š3  9  

ç¬¦å·æ ˆæ˜¯ï¼š-  (  +  

åç¼€è¡¨è¾¾å¼æ˜¯ï¼š1  3  9  

ç¬¦å·æ ˆæ˜¯ï¼š-  (  +  

-->> )
åç¼€è¡¨è¾¾å¼æ˜¯ï¼š-  1  3  9  

ç¬¦å·æ ˆæ˜¯ï¼š+  

-->> *
åç¼€è¡¨è¾¾å¼æ˜¯ï¼š-  1  3  9  

ç¬¦å·æ ˆæ˜¯ï¼š*  +  

åç¼€è¡¨è¾¾å¼æ˜¯ï¼š3  -  1  3  9  

ç¬¦å·æ ˆæ˜¯ï¼š*  +  

-->> +
åç¼€è¡¨è¾¾å¼æ˜¯ï¼š+  *  3  -  1  3  9  

ç¬¦å·æ ˆæ˜¯ï¼š+  

åç¼€è¡¨è¾¾å¼æ˜¯ï¼š8  +  *  3  -  1  3  9  

ç¬¦å·æ ˆæ˜¯ï¼š+  

-->> /
åç¼€è¡¨è¾¾å¼æ˜¯ï¼š8  +  *  3  -  1  3  9  

ç¬¦å·æ ˆæ˜¯ï¼š/  +  

åç¼€è¡¨è¾¾å¼æ˜¯ï¼š2  8  +  *  3  -  1  3  9  

ç¬¦å·æ ˆæ˜¯ï¼š/  +  

-->> =
åç¼€è¡¨è¾¾å¼æ˜¯ï¼š+  /  2  8  +  *  3  -  1  3  9  

åç¼€è¡¨è¾¾å¼é€†åº1(1 æˆåŠŸ  0 å¤±è´¥)

åç¼€è¡¨è¾¾å¼æ˜¯ï¼š9  3  1  -  3  *  +  8  2  /  +  

3 - 1 = 2 
2 * 3 = 6 
9 + 6 = 15 
8 / 2 = 4 
15 + 4 = 19 

```

&emsp;  ä½†æ˜¯è¿™ä¸ªç¨‹åºæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯å½“æ“ä½œæ•°æ˜¯å¤§äº10ä»¥ä¸Šçš„æ•°ï¼Œè®¡ç®—ä¼šå¤±è¯¯ã€‚è¿™æ˜¯å› ä¸ºå½“æˆ‘æŠŠå››åˆ™è¿ç®—å­—ç¬¦ä¸²åˆ†å‰²æˆäº†ä¸€ä¸ªæ•°ç»„ï¼Œå¯¹äºå¤§äº10çš„æ•°ï¼Œå°±åˆ†å‰²ä¸º2ä½äº†ï¼Œæ‰€ä»¥å‡ºé”™ã€‚è‹¥æ˜¯ï¼Œä½ æœ‰è§£å†³åŠæ³•ï¼Œè¯·éº»çƒ¦å‘ŠçŸ¥ä¸‹ï¼Œè°¢è°¢ï¼





<br/>

***
<br/>

> <h1 id="é˜Ÿåˆ—">é˜Ÿåˆ—</h1>


&emsp;  `é˜Ÿåˆ—æ˜¯åªå…è®¸åœ¨ä¸€ç«¯è¿›è¡Œæ’å…¥æ“ä½œï¼Œè€Œåœ¨å¦ä¸€ç«¯è¿›è¡Œåˆ é™¤æ“ä½œçš„çº¿æ€§è¡¨ã€‚`

&emsp;  é˜Ÿåˆ—æ˜¯ä¸€ç§`å…ˆè¿›å…ˆå‡º(First In First Out)`çš„çº¿æ€§è¡¨ï¼Œç®€ç§°FIFOã€‚åªå…è®¸æ’å…¥çš„ä¸€ç«¯ä¸ºé˜Ÿå°¾ï¼Œå…è®¸åˆ é™¤çš„ä¸€ç«¯ç§°ä¸ºé˜Ÿå¤´ã€‚

![é¡ºåºé˜Ÿåˆ—](https://upload-images.jianshu.io/upload_images/2959789-e156da434f5d2459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



<br/>
<br/>

> <h2 id="é“¾å¼é˜Ÿåˆ—">é“¾å¼é˜Ÿåˆ—</h2>

![é“¾å¼é˜Ÿåˆ—æœ‰å…ƒç´ ](https://upload-images.jianshu.io/upload_images/2959789-47523e8275820489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


![ç©ºé˜Ÿåˆ—æ˜¾ç¤º](https://upload-images.jianshu.io/upload_images/2959789-4801340f9d997793.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


**`å…¬å…±ä»£ç `**

```

typedef struct QueueNode{
    int data;
    struct QueueNode *next;
}QueueNode, *QueuePtr;

typedef struct {
    QueueNode *front, *rear;
} LinkQueue;

void linkQueueTest(void);



//éå†é˜Ÿåˆ—å…ƒç´ 
int printQueueElement(LinkQueue linkQueue){
    if (linkQueue.front == NULL) {
        return FALSE;
    }
    
    QueueNode *node = linkQueue.front->next;
    while (node) {
        printf("    %d", node->data);
        node = node->next;
    }
    printf("\n\n");
    
    return TRUE;
}

//é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
int isQueueEmpty(LinkQueue linkQueue){
    if (linkQueue.front == linkQueue.rear) {
        return TRUE;
    }
    
    return FALSE;
}

//é˜Ÿåˆ—çš„é•¿åº¦
int queueLength(LinkQueue linkQueue){
    int length = 0;
    QueueNode *node = linkQueue.front;
    while (linkQueue.rear != node) {
        length ++;
        node = node->next;
    }
    return length;
}


//é”€æ¯é˜Ÿåˆ—
int destoryQueue(LinkQueue *linkQueue){
/*
    //é”™è¯¯ä»£ç 
    QueueNode *deleteNode = linkQueue->front->next;
    while (deleteNode) {
        linkQueue->front = deleteNode->next;
        free(deleteNode);
        deleteNode = linkQueue->front;
    }
    linkQueue->rear = linkQueue->front;
 */
    
    //é”€æ¯ï¼Œè¿ç€é˜Ÿåˆ—çš„å¤´ç»“ç‚¹å’Œé˜Ÿåˆ—çš„èŠ‚ç‚¹ä¸€å—é”€æ¯æ‰äº†
    while (linkQueue->front) {
        linkQueue->rear = linkQueue->front->next;
        free(linkQueue->front);
        linkQueue->front = linkQueue->rear;
    }
    
    return TRUE;
}


//åˆå§‹åŒ–é˜Ÿåˆ—
int initWithQueue(LinkQueue *linkQueue){
    //ç”³è¯·ä¸€ä¸ªå¤´ç»“ç‚¹çš„ç©ºé—´ï¼Œä½¿frontå’Œrearéƒ½æŒ‡å‘å®ƒ
    linkQueue->front = linkQueue->rear = (QueueNode *)malloc(sizeof(QueueNode));

    if (!linkQueue->front) {
        exit(OVERFLOW);
        return FALSE;
    }
    linkQueue->front->next = NULL;
    
    return TRUE;
    
}



```


<br/>

> <h2 id="å…¥é˜Ÿåˆ—">å…¥é˜Ÿåˆ—</h2>


![é“¾å¼å…¥é˜Ÿåˆ—](https://upload-images.jianshu.io/upload_images/2959789-5135a86f81a4793b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


```
//é˜Ÿåˆ—è¿›å…¥
int enterQueue(LinkQueue *linkQueue, int data){
    QueueNode *insertNode = (QueuePtr)malloc(sizeof(QueueNode));
    if (!insertNode) {  //å­˜å‚¨ç©ºé—´åˆ†é…å¤±è´¥
        exit(OVERFLOW);
        return FALSE;
    }
    
    insertNode->data = data;
    insertNode->next = NULL;
    //æŠŠæ‹¥æœ‰å…ƒç´ eçš„æ–°ç»“ç‚¹sèµ‹å€¼ç»™åŸé˜Ÿå°¾ç»“ç‚¹çš„åç»§ï¼Œè§å›¾ä¸­â‘ 
    linkQueue->rear->next = insertNode;
    //æŠŠå½“å‰çš„sè®¾ç½®ä¸ºé˜Ÿå°¾ç»“ç‚¹ï¼ŒrearæŒ‡å‘sï¼Œè§å›¾ä¸­â‘¡
    linkQueue->rear = insertNode;
    
    return TRUE;
};

void linkQueueTest(void){
    LinkQueue linkQueue;
    int statusCode;
    int element;
    
    statusCode = initWithQueue(&linkQueue);
    printf("åˆå§‹åŒ–æˆåŠŸ%d(1æ˜¯ 0å¦)\n\n", statusCode);
    
    for (int i = 0; i <= 10; i ++) {
        enterQueue(&linkQueue, i);
    }
    printQueueElement(linkQueue);
}

```
è¾“å‡ºï¼š

```
åˆå§‹åŒ–æˆåŠŸ1(1æ˜¯ 0å¦)

0    1    2    3    4    5    6    7    8    9    10
```


<br/>
<br/>

> <h2 id="é“¾å¼å‡ºé˜Ÿåˆ—">é“¾å¼å‡ºé˜Ÿåˆ—</h2>


![å‡ºé˜Ÿ](https://upload-images.jianshu.io/upload_images/2959789-3777a545d7560735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




```
//å‡ºé˜Ÿåˆ—
int outQueue(LinkQueue *queue, int *data){
    if (queue->front == queue->rear) {
        return FALSE;
    }
    
    //å°†æ¬²åˆ é™¤çš„é˜Ÿå¤´ç»“ç‚¹æš‚å­˜ç»™deleteNodeï¼Œè§å›¾ä¸­â‘ 
    QueueNode *deleteNode = queue->front->next;
    //å°†æ¬²åˆ é™¤çš„é˜Ÿå¤´ç»“ç‚¹çš„å€¼èµ‹å€¼ç»™data
    *data = deleteNode->data;
    //å°†åŸé˜Ÿå¤´ç»“ç‚¹çš„åç»§deleteNode->nextèµ‹å€¼ç»™å¤´ç»“ç‚¹åç»§ï¼Œè§å›¾ä¸­â‘¡
    queue->front->next = deleteNode->next;
    
    if (queue->rear == deleteNode) {
        queue->rear = queue->front;
    }
    free(deleteNode);
    
    return TRUE;
};

void linkQueueTest(void){
    LinkQueue linkQueue;
    int statusCode;
    int element;
    
    statusCode = initWithQueue(&linkQueue);
    printf("åˆå§‹åŒ–æˆåŠŸ%d(1æ˜¯ 0å¦)\n\n", statusCode);
    
    for (int i = 0; i <= 10; i ++) {
        enterQueue(&linkQueue, i);
    }
    printQueueElement(linkQueue);
    
    statusCode = outQueue(&linkQueue, &element);
    printf("å‡ºé˜Ÿåˆ—æˆåŠŸ%d(1æ˜¯ 0å¦),å…ƒç´ æ˜¯ï¼š%d\n\n", statusCode, element);
    printQueueElement(linkQueue);
    
}
```
è¾“å‡ºï¼š

```
1    2    3    4    5    6    7    8    9    10

å‡ºé˜Ÿåˆ—æˆåŠŸ1(1æ˜¯ 0å¦),å…ƒç´ æ˜¯ï¼š0

1    2    3    4    5    6    7    8    9    10
```




<br/>

***
<br/>
<br/>

> <h1 id='äºŒå‰æ ‘'>äºŒå‰æ ‘</h1>


<br/>

># <h2 id='æ€§è´¨'>æ€§è´¨</h2>


- æ€§è´¨1ï¼š`äºŒå‰æ ‘çš„ç¬¬iå±‚ä¸Šè‡³å¤šæœ‰ 2^(i-1) ä¸ªèŠ‚ç‚¹(iâ‰¥1)ã€‚`
i = 4 , 2^(4-1) = 8.

- æ€§è´¨2ï¼š`æ·±åº¦ä¸ºkçš„äºŒå‰æ ‘è‡³å¤šæœ‰  2^(k-1) ä¸ªèŠ‚ç‚¹(kâ‰¥1).`
k = 4, æœ‰ 1+2+4+8 = 15 = 2^(4-1) ä¸ªèŠ‚ç‚¹ã€‚

- æ€§è´¨3ï¼š`ä»»ä½•ä¸€æ£µä¸€æ£µäºŒå‰æ ‘Tï¼Œå¦‚æœå…¶ç»ˆç«¯ç»“ç‚¹æ•°ä¸º n0 ï¼Œåº¦ä¸º2çš„èŠ‚ç‚¹æ•°ä¸º n2ï¼Œåˆ™ n0 = n2 +1ï¼›`
å¶å­èŠ‚ç‚¹æ•°ä¸º 5ï¼Œ åº¦ä¸º2çš„èŠ‚ç‚¹æ•°ä¸º4ï¼Œåˆ™ 5 = 4 +1;

- æ€§è´¨4ï¼š`å…·æœ‰nä¸ªèŠ‚ç‚¹çš„å®Œå…¨äºŒå‰æ ‘çš„æ·±åº¦ä¸ºã€Œlog2nã€+1(ã€Œxã€è¡¨ç¤ºä¸å¤§äºxçš„æœ€å¤§æ•´æ•°)ã€‚`

- æ€§è´¨5ï¼š`å¦‚æœå¯¹ä¸€ä¸ªæœ‰nä¸ªç»“ç‚¹çš„å®Œå…¨äºŒå‰æ ‘(å…¶æ·±åº¦ä¸ºã€Œlog2nã€+1)çš„èŠ‚ç‚¹æŒ‰å±‚åºç¼–å·(ä»ç¬¬1å±‚åˆ°ç¬¬ã€Œlog2nã€+1 å±‚ï¼Œæ¯å±‚ä»å·¦åˆ°å³)ï¼Œå¯¹ä»»ä¸€èŠ‚ç‚¹i (1â‰¤iâ‰¤n
)æœ‰ï¼š`


<br/>

&emsp;  `â‘ . å¦‚æœi=1ï¼Œåˆ™ç»“ç‚¹iæ˜¯ä»äºŒå‰æ ‘çš„æ ¹ï¼Œæ— åŒäº²ï¼›å¦‚æœi>1,åˆ™å…¶åŒäº²æ˜¯ç»“ç‚¹ã€Œi/2ã€ï¼›`

&emsp;  `â‘¡. å¦‚æœ 2i>n,åˆ™ç»“ç‚¹iæ— å·¦å­©å­(ç»“ç‚¹iä¸ºå¶å­ç»“ç‚¹)ï¼Œå¦åˆ™å…¶å·¦å­©å­æ˜¯ç»“ç‚¹2iï¼›`

&emsp; ` â‘¢. å¦‚æœ 2i+1 > n,åˆ™ç»“ç‚¹iæ— å³å­©å­ï¼Œå¦åˆ™å…¶å³å­©å­æ˜¯ç»“ç‚¹ 2i +1.`


<br/>
<br/>


># <h2 id='éå†'>éå†</h2>


- **`å‰åºéå†ï¼šè‹¥äºŒå‰æ ‘ä¸ºç©ºï¼Œåˆ™è¿”å›ã€‚å¦åˆ™å…ˆè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œç„¶åå‰åºéå†å·¦å­æ ‘ï¼Œå†å‰åºéå†å³å­æ ‘ã€‚`**

![z28.png](./../Pictures/z28.png)

<br/>

```
//å‰åºéå†
void preorderTraverse(BinaryTree *binaryTree){
    if (*binaryTree == NULL) {
        return;
    }
    
    printf("%c",(*binaryTree)->data);
    preorderTraverse(&(*binaryTree)->leftChild);
    preorderTraverse(&(*binaryTree)->rightChild);
}
```


<br/>
<br/>

- **`ä¸­åºéå†ï¼šè‹¥æ ‘ä¸ºç©ºï¼Œåˆ™ç©ºè¿”å›ã€‚å¦åˆ™å…ˆä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¸­åºéå†æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ï¼Œç„¶åè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œæœ€åä¸­åºéå†å³å­æ ‘`**

![z29.png](./../Pictures/z29.jpeg)

<br/>

```
//ä¸­åºéå†
void infixOrderTraverse(BinaryTree *binaryTree){
    if (*binaryTree == NULL) {
        return;
    }
    
    infixOrderTraverse(&(*binaryTree)->leftChild);
    printf("%c",(*binaryTree)->data);
    infixOrderTraverse(&(*binaryTree)->rightChild);
    
    return;
}
```


<br/>
<br/>

- **`ååºéå†ï¼šè‹¥æ ‘ä¸ºç©ºï¼Œåˆ™ç©ºè¿”å›ã€‚å¦åˆ™ä»å·¦åˆ°å³å…ˆå¶å­åèŠ‚ç‚¹çš„æ–¹å¼éå†è®¿é—®å·¦å³å­æ ‘ï¼Œæœ€åè®¿é—®æ ¹èŠ‚ç‚¹`**

![z30.png](./../Pictures/z30.jpeg)

<br/>

```
//ååºéå†
void epilogueOrderTraverse(BinaryTree *binaryTree){
    if (*binaryTree == NULL) {
        return;
    }
    
    epilogueOrderTraverse(&(*binaryTree)->leftChild);
    epilogueOrderTraverse(&(*binaryTree)->rightChild);
    printf("%c",(*binaryTree)->data);
    
    return;
}
```

<br/>
<br/>
<br/>

> <h2 id='æ˜“é”™ç‚¹'>æ˜“é”™ç‚¹</h2>


`.h æ–‡ä»¶`

```
#ifndef BinaryTree_h
#define BinaryTree_h

#include <stdio.h>
#include <stdlib.h>
#include "math.h"
#include "string.h"

#include "LinearListStoragge.h"


typedef struct BinaryTreeNode {
    char data;
    struct BinaryTreeNode *leftChild;
    struct BinaryTreeNode *rightChild;
} BinaryTreeNode;


void binaryTreeTest(void);

#endif
```

**`.cæ–‡ä»¶`**

```
int initBinaryTree(BinaryTreeNode *binaryTree){
    binaryTree = (BinaryTreeNode *)malloc(sizeof(BinaryTreeNode));
    if (!binaryTree) {
        return FALSE;
    }
    
    binaryTree->data = '$';
    binaryTree->leftChild = NULL;
    binaryTree->rightChild = NULL;

   return TRUE;
}

void  setTest(BinaryTreeNode *node){
    node = (BinaryTreeNode *)malloc(sizeof(BinaryTreeNode));
    node->data = 'S';
}


void binaryTreeTest(void){
    BinaryTreeNode binaryTree;
    
    int statusCode = 0;
    

    statusCode = initBinaryTree(&binaryTree);
    setTest(&binaryTree);
}
```

æ‰“å°ï¼š


```
(lldb) po binaryTree->data
<nil>
```

&emsp;  è¿™æ˜¯å› ä¸ºåœ¨ `initBinaryTree` æ–¹æ³•ä¸­æœ‰ ` binaryTree = (BinaryTreeNode *)malloc(sizeof(BinaryTreeNode));` ç›¸å½“äºåˆé‡æ–°åˆå§‹åŒ–äº†ä¸€ä¸ªç»“æ„ä½“ `BinaryTreeNode `,è‹¥æ²¡æœ‰è¿™æ®µä»£ç ï¼Œå¯ä»¥æ‰“å°å‡º `S` å­—ç¬¦ã€‚



<br/>
<br/>

># <h2 id='äºŒå‰æ ‘çš„å‰ä¸­åéå†'>äºŒå‰æ ‘çš„å‰ã€ä¸­ã€åéå†</h2>

`.hæ–‡ä»¶`

```
#ifndef BinaryTree_h
#define BinaryTree_h

#include <stdio.h>
#include <stdlib.h>
#include "math.h"
#include "string.h"

#include "LinearListStoragge.h"

typedef struct BinaryTreeNode {
    char data;
    struct BinaryTreeNode *leftChild;
    struct BinaryTreeNode *rightChild;
} BinaryTreeNode, *BinaryTree;


void binaryTreeTest(void);


#endif 

```


# `.cæ–‡ä»¶`

```
#include "BinaryTree.h"
char characters[24] = "ABDH#K###E##CFI###G#J##";//BDH#K###E##CFI###G#J##
int number = 0;

void createBinaryTree(BinaryTree *binaryTree){
    char data = characters[number++];
    
    if (data == '#' || data == '\0') {
        *binaryTree = NULL;
    }else {
        *binaryTree = (BinaryTree)malloc(sizeof(BinaryTreeNode));
        if (!*binaryTree) {
            exit(OVERFLOW);
        }
        
        (*binaryTree)->data = data;
        createBinaryTree(&(*binaryTree)->leftChild);
        createBinaryTree(&(*binaryTree)->rightChild);
    }
    
}

//åˆ¤æ–­äºŒå‰æ ‘æ˜¯å¦ä¸ºç©º
int isEmptyBinaryTree(BinaryTree *binaryTree){
    if (binaryTree != NULL) {
        return TRUE;
    }
    return FALSE;
}

//è®¡ç®—äºŒå‰æ ‘çš„æ·±åº¦
int caculateBinaryTreeDepth(BinaryTree *binaryTree){
    int i, j;
    if (*binaryTree == NULL) {
        return 0;
    }
    
    if ((*binaryTree)->leftChild) {
        i = caculateBinaryTreeDepth(&(*binaryTree)->leftChild);
    }else {
        i = 0;
    }
    
    if ((*binaryTree)->rightChild) {
        j = caculateBinaryTreeDepth(&(*binaryTree)->rightChild);
    }else {
        j = 0;
    }
    
    
    return i>j ? i+1 : j+1;
}


//ä¸­åºéå†
void infixOrderTraverse(BinaryTree *binaryTree){
    if (*binaryTree == NULL) {
        return;
    }
    
    infixOrderTraverse(&(*binaryTree)->leftChild);
    printf("%c",(*binaryTree)->data);
    infixOrderTraverse(&(*binaryTree)->rightChild);
    
    return;
}


//ååºéå†
void epilogueOrderTraverse(BinaryTree *binaryTree){
    if (*binaryTree == NULL) {
        return;
    }
    
    epilogueOrderTraverse(&(*binaryTree)->leftChild);
    epilogueOrderTraverse(&(*binaryTree)->rightChild);
    printf("%c",(*binaryTree)->data);
    
    return;
}

//å‰åºéå†
void preorderTraverse(BinaryTree *binaryTree){
    if (*binaryTree == NULL) {
        return;
    }
    
    printf("%c",(*binaryTree)->data);
    preorderTraverse(&(*binaryTree)->leftChild);
    preorderTraverse(&(*binaryTree)->rightChild);
}

int initBinaryTree(BinaryTree *binaryTree){
    *binaryTree = NULL;
    
    return TRUE;
}


//æ–¹æ³•è°ƒç”¨
void binaryTreeTest(void){
    BinaryTree binaryTree; //ç­‰ä»·äºï¼šBinaryTreeNode* binaryTree;
    
    int statusCode = 0;
    
    statusCode = initBinaryTree(&binaryTree);
    
    //åˆ›å»ºäºŒå‰æ ‘
    createBinaryTree(&binaryTree);
    
    statusCode = isEmptyBinaryTree(&binaryTree);
    printf("\n\nç©ºæ ‘ï¼š%d(1å¦ 0æ˜¯)", statusCode);
    
    statusCode = caculateBinaryTreeDepth(&binaryTree);
    printf("\n\näºŒå‰æ ‘çš„æ·±åº¦ä¸ºï¼š%d", statusCode);
    
    printf("\n\nå‰åºéå†ï¼š");
    preorderTraverse(&binaryTree);
    
    printf("\n\nä¸­åºéå†ï¼š");
    infixOrderTraverse(&binaryTree);
    
    
    printf("\n\nååºéå†ï¼š");
    epilogueOrderTraverse(&binaryTree);
    
    
    
}

```
æ‰“å°ï¼š

```
ç©ºæ ‘ï¼š1(1å¦ 0æ˜¯)

äºŒå‰æ ‘çš„æ·±åº¦ä¸ºï¼š5

å‰åºéå†ï¼šABDHKECFIGJ

ä¸­åºéå†ï¼šHKDBEAIFCGJ

ååºéå†ï¼šKHDEBIFJGCA
```



<br/>

***
<br/>
<br/>


> <h1 id=""></h1>


<br/>

> <h2 id=""></h2>



<br/>

***
<br/>
<br/>


> <h1 id=""></h1>


<br/>

> <h2 id=""></h2>



<br/>

***
<br/>
<br/>


> <h1 id=""></h1>


<br/>

> <h2 id=""></h2>





<br/>

***
<br/>
<br/>


> <h1 id=""></h1>


<br/>
<br/>

> <h2 id=""></h2>

```
```



<br/>

***
<br/>
<br/>


> <h1 id=""></h1>



<br/>
<br/>

> <h2 id=""></h2>


<br/>







<br/>
<br/>





<br/>

***
<br/>
<br/>


> <h1 id=""></h1>


<br/>

***
<br/>
<br/>


> <h1 id=""></h1>

