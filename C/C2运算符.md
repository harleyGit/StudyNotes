
运算符函数声明方式与一般的函数相似，不过必须在运算符符号前面加上operator关键字。声明格式如下所示：

`返回数据类型operator运算符符号(数据类型 参数1, ……)`

<br/>

- *运算符定义规则：*
<br/>
&emsp;	++程序内建的基本运算符有所区别，在声明运算符函数重载时，有以下几点定义规则：
<br/>
（1）在声明运算符函数时，其函数参数行内的个数必须符合原运算符的个数。举例来说，一元运算符只能拥有一个参数，在声明运算符函数时，该函数参数行内的参数个数就必须只有一个参数。
<br/>
（2）假如运算符本身拥有一元和二元运算符的特性，我们就可以分别定义一元以及二元运算符函数。以“+”运算符来说，可以定义如下重载函数：
```

    int operator+(Student&);                     // 一元运算符￼     int operator+(Student&, Student&);              // 二元运算符
 ```
（3）运算符重载只是用来扩充基本运算符的功能，即使定义新的运算符函数，也无法更改原先运算符的优先级。另外，在C++中，大部分的基本运算符都可以定义成运算符重载。至于不可重载定义的运算符，如表13-1所示。
表13-1 不可重载定义的运算符
![z1](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/z1.png)

<br/>

（4）运算符函数既可以声明成一般的函数（非成员函数），也可以声明成类内的成员函数。以下面重载`“+”`运算符的表达式语句来进行比较：
```

￼     非成员函数的定义方式：
￼     Student operator+(Student& var1, Student& var2, Student& var3, ......, Student& varN);
￼   
  成员函数的定义方式：
  ￼     Student operator+(Student& var2, Student& var3, ......, Student& varN);

```

&emgg34大家是否发现在以上成员函数的定义方式中Student& var1不见了，这是因为如果这个运算符函数是类内的成员函数，就可以使用this指针来获取对象本身的数据成员，进而取代其中一个原来必须传递给函数的参数。
因此，在类中声明运算符函数时，该函数的参数会比以非成员函数定义的参数少一个。另外，当运算符函数被声明成类成员函数时，左操作数必须是该类的对象，否则此运算符函数就必须声明成非成员函数。


<br/>
<br/>

&emsp;&emsp;当程序使用非成员函数的方式来定义运算符重载时，除了public区块的数据成员外，其他区块的成员将无法存取。此时可以在类中把该运算符函数声明为友元函数。例如，下面的加号函数并非Student类的成员函数，所以必须将其声明为友元函数后才可以存取private区块的数据成员Score：
```
￼     class Student
￼     {
	￼         friend Student operator+(Student, Student); // 将加号函数声明为友元函数
	￼         private:
	￼           int Score;
	         // 非public数据成员
	  };

	  Student operator+(Student, Student)￼     {……}

```


<br/>


- *一元运算符重载*
简单来说，一元运算符函数按定义类型的不同可分为下面两种声明方式：
	- 定义成员函数的一元运算符函数：
￼               `返回数据类型operator运算符();`
	- 定义非成员函数的一元运算符函数：
￼               `返回数据类型operator运算符(参数);`
&emsp;例如，要重载类的运算符，只需要编写运算符成员函数即可。由于参与运算的操作数即为this对象本身，因此不需要传递任何参数给函数，如下所示：
`
￼     返回类型operator运算符();
`


