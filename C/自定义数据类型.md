># 结构体

- 结构是一种类型，而不是变量，因此结构声明是在创建一种新类型，声明后才能创建结构变量来加以使用。结构的声明方式如下：
```
￼ struct结构类型名称￼ 
   {
￼         数据类型 结构成员1；
￼         数据类型 结构成员2；
￼         ……
￼     };
```


- `结构的存取`
定义完新的结构类型及声明结构变量后就可以开始使用所定义的结构成员了。只要在结构变量后加上成员运算符“.”与结构成员名称，就可以直接存取该结构成员了：

`结构变量．结构成员名称；`

```
#include <iostream>
#include <cstdlib>￼     
using namespace std;￼     
 ￼     
int main()￼     
{￼     
   struct student￼     
   {￼     
       char name[10];￼     
       int score;￼     
     } s1, s2; // 结构类型的声明与定义￼     
￼     
      cout<<"学生姓名=";￼     
      cin>>s1.name; //输入s1结构变量的name成员￼     
      cout<<"学生成绩=";￼     
      cin>>s1.score; // 输入s1结构变量的score成员￼     
      s2 = s1; //结构变量的赋值￼     
       cout<<"s1.name ="<<s1.name<<endl;￼     
       cout<<"s1.score ="<<s1.score<<endl;￼     
       cout<<"s2.name ="<<s2.name<<endl;￼     
       cout<<"s2.score ="<<s2.score<<endl;￼     
￼     
       system("pause");￼     
       return 0;￼     
  }

```

*`总结：`*根据上面所得，结构体在声明以后是已经申请好了一块内存，然后才对其内的各个成员变量进行赋值。



<br/>

***
<br/>


>#	结构变量可以直接对其成员进行存取，但是由于结构指针是以此结构为数据类型的指针变量，所存储的内容是地址，因此还是和一般指针变量一样，必须先指定结构变量的地址给指针才能间接存取其指向的结构变量的成员，如下所示：
`
￼     结构指针 = &结构变量；
`
基本上，结构指针的数据访问方法有以下两种方式。
（1）使用->符号指向结构指针的数据成员：
￼     `结构指针->结构成员名称；`
（2）使用取值运算符`“*”`以及小数点`“.”`存取结构变量的数据成员：
￼     `(＊结构指针)．结构成员名称；`

```
#include <iostream>￼     
#include <cstdlib>￼     
using namespace std;￼     
￼     
struct circle￼     
{￼            
	float r;￼     
    float pi;￼     
           float area;￼     
      };  //声明circle结构￼     
      int main()￼     
      {￼     
   	       struct circle myCircle;￼     
   	       struct circle ＊getData;￼     
   	￼     
   	      //getData指向myCircle￼     
   	       getData = &myCircle;￼     
   	      //设置圆半径￼     
   	       myCircle.r=5;￼     
   	       myCircle.pi = 3.14159;￼     
   	      //设置圆周率￼     
   	       myCircle.area = myCircle.r＊myCircle.r＊myCircle.pi;￼     
   	      //计算圆面积￼     
   	￼            
  		   cout<<"getData->r ="<<getData->r<<endl;￼     
  	       cout<<"getData->pi ="<<getData->pi<<endl;￼     
  	       cout<<"getData->area ="<<getData->area<<endl;￼     
  	      //第一种结构指针的存取方式￼     
  	       cout<<"--------------------------------------"<<endl;￼     31       cout<<"(＊getData).r ="<<(＊getData).r<<endl;￼     
  	       cout<<"(＊getData).pi ="<<(＊getData).pi<<endl;￼     
  	       cout<<"(＊getData).area ="<<(＊getData).area<<endl;￼     
  	      //第二种结构指针的存取方式￼     
  	       system("pause");￼     
  	       return 0;￼     
  	  }
```
![a35](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/a35.png)



- 结构指针数组
```
#include <iostream>￼     
#include <cstdlib>￼     
  using namespace std;￼     
￼     
  int main()￼     
  {￼     
       struct student￼     
       {￼     
           char name[10];￼     
           int score;￼     
       };￼     
       struct student s1[5] = { {"Justin", 90},￼ 
       							{"Momor",  95},
       							{"Becky",  98},
       							{"Bush",   75},
       							{"Snoopy", 80} }; // 设置5个成员的初始值￼           struct student ＊s2[5]; // 声明成结构指针数组￼     
       int i;￼     
￼     
       for(i = 0; i < 5; i++)￼     
          s2[i] = &s1[i]; //复制结构成员￼     
￼     
       for(i = 0; i < 5; i++)￼     
       {￼     
          cout<<"姓名："<<s2[i]->name<<'\t';￼     
          cout<<"成绩："<<s2[i]->score<<endl;￼     
      }//显示结构成员￼     
     
       system("pause");￼     
       return 0;￼     
  }
```
![a31](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/a31.png)


<br/>

***
<br/>


>#	嵌套结构
所谓嵌套结构，就是在一个结构中声明创建另一个结构，就如同一个书包（外层结构）里面还装有数个文件夹（内层结构），如图10-6所示。
<br/>
￼
![a32](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/a32.png)



<br/>

***
<br/>


>#	函数与结构
由于结构是一种用户自定义数据类型，因此也可以在函数与函数之间传递结构变量。结构数据类型并不是C++的基本数据类型，因此要在函数中传递结构类型，就必须在全局范围内事先声明，其他函数才可以使用此结构类型来定义变量。
在C++的函数间传递参数，可分为`传值（call by value）、传址（call by address）与传引用（call by reference）`三种方式。当然，函数中的结构数据传递也可以使用这几种参数传递方法。


-	结构传值调用
传值调用会将整个结构变量复制到函数里，结构的所有成员项会一直存在函数中，以供函数内的语句直接使用。但是，当结构对象容量很大时，不仅占用许多内存空间，还会降低程序运行的效率。

```
函数类型 函数名称(struct结构类型名称 结构变量);
￼     或￼     
函数类型 函数名称(struct结构类型名称);
```
例如：
￼     `int calculate(struct product inbook);`
调用时，直接将结构变量传入函数即可：
￼     `calculate(book);`


- 结构传址调用
传址调用所传入的参数为结构变量的内存地址，并以“&”运算符将地址传给函数，在函数内则通过结构指针来存取结构数据。这样的方式可解决传值调用时所造成的占用内存与效率降低的问题。不过，如果在函数中更改了传来的参数值，那么主函数内结构变量的值也会同步更改。函数原型声明如下：
```
￼     函数类型 函数名称(struct结构类型名称 ＊结构变量);
￼     或￼
    函数类型 函数名称(struct结构类型名称 ＊);
```
例如：
￼     `int calculate(struct product ＊inbook);`
调用时，直接将结构变量的地址传入函数即可：
￼     `calculate(&book);`


-	结构传引用调用
C++中的传引用调用方式也是类似于传址调用的一种，当然结构类型也可以使用传引用调用方式。当在函数内更改了形式参数的值时，也就更改了原先调用函数中的实际参数。在使用结构传引用调用时，只需要在函数原型和定义函数所要传递的参数前加上&运算符即可。函数原型声明如下：
```
￼     函数类型 函数名称(struct结构类型名称 &结构变量);
￼     或
￼     函数类型 函数名称(struct结构类型名称 &);
```
例如：
￼     `int calculate(struct product &inbook);`
调用时，直接将结构变量的地址传入函数即可：
￼     `calculate(book);`



- 其他自定义数据类型

所谓自定义数据类型，就是根据设计需要自行定义的数据类型。在程序中，可以用自定义类型来定义这种自定义数据类型的变量。除了上述的struct可自定义数据类型外，还有枚举（enum）、联合（union）与类型定义（typedef）三种方式。本节中会针对这三种类型特性分别进行说明。

类型定义指令
类型定义指令（typedef）可用来重新定义数据类型，将原有的类型或结构使用typedef指令以有意义的新名称来取代，让程序可读性更高。声明语法如下：
￼     typedef原类型 新定义类型；
要让类型名称更有意义，程序员可以使用typedef指令将int重新定义为integer：
￼     typedef int integer;￼     integer age=20;
经过以上声明，int和integer就都声明为整数类型了。如果要重新定义结构类型，程序代码声明就不必每次都加上struct保留字了，例如：
￼     typedef struct house￼     {￼         int roomNumber;￼         char houseName[10];￼     } house_Info;￼ ￼ ￼     house_Info  myhouse;



<br/>

***
<br/>


>#	枚举类型
枚举类型（enum）也是一种由用户自行定义的数据类型，内容是由一组常数集合成的枚举成员，并给予各个常数值不同的命名。枚举类型的优点在于把变量值限定在枚举成员的常数集合里，并使用名称的方式来进行赋值，使得程序的可读性大为提高。
```

enum枚举类型名称
￼      {
	￼             枚举成员1,
	￼             枚举成员2,
	￼             ……￼           
	};￼       enum枚举类型名称 枚举类型变量；

例如：
￼       enum Drink
￼             {
	￼             coffee,  //默认值为0
	￼             milk,    //默认值为1
	￼             tea,      //默认值为2
	￼             water    //默认值为3
	￼             };
```


<br/>

***
<br/>


>#	联合类型（union）与结构类型（struct）无论是在定义方法还是成员存取上都十分相似，但结构类型所定义的每个成员拥有各自的内存空间，而联合却是共享内存空间，如图10-11所示。

<br/>

![a33](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/a33.png)


联合变量的定义与声明方式如下：
```
￼     union联合类型名称
￼     {
	￼         数据类型 数据成员1;
	￼         数据类型 数据成员2;
	￼     数据类型 数据成员3;
	￼         ……
	￼     };
```
	￼ ￼ ￼     
union联合类型名称 联合变量；
联合变量内的各个成员以同一个内存区块来存储数据，并以占最大内存空间的成员作为联合类型的内存空间大小。例如，定义下面的联合类型Data, u1联合对象所占内存空间的大小则会以字符数组name为主，也就是20个字节：
```
￼     union Data
￼     {
	￼         int a;
	￼         int b;
	￼         char name[20];
	￼     } u1;
```

定义完新的联合类型和声明联合变量后就可以开始使用所定义的数据成员了。只要在联合变量后加上成员运算符“.”与数据成员名称就可以直接存取该数据成员：

联合对象．数据成员；

```
 #include <iostream>￼ 
#include <cstdlib>￼ 
using namespace std;￼ 
int encode(int);    // 加密函数￼ 
int decode(int);    // 解密函数￼ 

int main(int argc, const char * argv[])￼ {
    ￼ 
    int pwd;
    cout<<"请输入密码：";
    cin>>pwd;￼ 
    pwd = encode(pwd);
    
    cout<<"加密后："<<pwd<<endl;
    ￼pwd = decode(pwd);
    cout<<"解密后："<<pwd<<endl;
    system("pause");
    
    return 0;
    
}
    ￼// 参  数：未加密的密码
    // 返回值：加密后的密码
int encode(int pwd){
    ￼int i;
    ￼union{
        int num;
        ￼char c[sizeof(int)];
    ￼} u1;

    u1.num = pwd;￼
    for(i = 0; i< sizeof(int); i++){
        u1.c[i] += 32;
    }
        ￼return u1.num;￼
}
int decode(int pwd)
{
    int i;
    union{
        int num;
        char c[sizeof(int)];
    } u1;

    u1.num = pwd;
    
    for(i = 0; i< sizeof(int); i++)
        u1.c[i] -= 32;

    return u1.num;
}


```

![a34](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/a34.png)






















发自我的iPad
