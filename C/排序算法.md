> <h1 id=""></h1>

- [排序](#排序)
	- [快速排序](#快速排序)


<br/>

***
<br/>

**算法（Algorithm）:** 代表着用系统的方法描述解决问题的策略机制，可以通过一定规范的 输入，在有限时间内获得所需要的 输出。

**算法的好坏**

&emsp; 一个算法的好坏是通过 时间复杂度 与 空间复杂度 来衡量的。就是代码需要的时间和内存，也就你时间成本和空间成本。其实这个一个动态的调整，到一定程度，往往就是用空间去换取时间，或者去时间去换取空间（dp其实就是在用空间去换取时间）。当然优秀的代码就是很优秀，排序也是这样，他们的目标都是把一堆数字进行排序。

常见时间复杂度的 **“大O表示法”** 描述有以下几种：

![大O表示法<br/>](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/c2_0.png)

一个算法在N规模下所消耗的时间消耗从大到小如下：

**O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(n^3) < O(2^n)**

指数级的增长是非常快的。




<br/>
<br/>


> <h1 id="排序">排序</h1>
> [<br/>](https://www.cnblogs.com/BobHuang/p/11263183.html)

常见的排序算法
根据时间复杂度的不同，常见的算法可以分为3大类。

- **O(n²) 的排序算法**
	- 冒泡排序
	- 选择排序
	- 插入排序

- **O(n log n) 的排序算法**
	- 希尔排序
	- 归并排序
	- 快速排序
	- 堆排序

- **线性的排序算法**
	- 计数排序
	- 桶排序
	- 基数排序

<br/>


<br/>

> <h2 id="冒泡排序">冒泡排序</h2>
冒泡排序（Bubble Sort） 是一种基础的 交换排序。

冒泡排序之所以叫冒泡排序，是因为它每一种元素都像小气泡一样根据自身大小一点一点往数组的一侧移动。

算法步骤如下：

- 比较相邻的元素。如果第一个比第二个大，就交换他们两个；

- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；

- 针对所有的元素重复以上的步骤，除了最后一个；

- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

图示如下：

![冒泡排序<br/>](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/c2_1.gif)

```

int* bubbleSort(char methodName[],int array[], int length);

int main(int argc, const char * argv[]) {
    //冒泡排序
    int a[] = {9,0,6,5,8,2,1,7,4,3};
    char methodName[] = "冒泡排序";
    int *b = bubbleSort(methodName,a, 10);
    
    for (int i=0; i< 10; i++) {
        printf("%i ", *(b+i));
    }

}


//交换数组中的元素
void swap(int *a, int *b){
    int c = *a;
    *a = *b;
    *b = c;

}


//冒泡排序
int* bubbleSort(char methodName[],int array[], int length){
    printf("=================%s=================", methodName);
   
    for (int i = 0; i < (length - 1); i ++) {
        for (int k = 0; k < length - 1 - i; k ++) {
            if (array[k] <= array[k+1]) {
                continue;
            }else {
//                int a = 0;
//                a = array[k];
//                array[k] = array[k+1];
//                array[k+1] = a;
                swap((array+k), (array+k+1));
            }
            
        }
    }
    printf("\n");
    
    return array;
}


```

打印：

```
=================冒泡排序=================
0 1 2 3 4 5 6 7 8 9 
```



<br/>
<br/>

> <h2 id="选择排序">选择排序（Selection Sort）</h2>

**选择排序（Selection sort）** 是一种简单直观的排序算法。

选择排序的主要优点与数据移动有关。

如果某个元素位于正确的最终位置上，则它不会被移动。

选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素的表进行排序总共进行至多 n - 1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

- 选择排序的算法步骤如下：

	- 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；
	
	- 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；
	
	- 以此类推，直到所有元素均排序完毕。

图示如下：

![选择排序<br/>](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/c2_2.gif)

```


int* selectSort(char methodName[], int array[], int length);

int main(int argc, const char * argv[]) {
	//    选择排序
    int a[] = { 3,  5,  2,  9,  7,  8,  4,  1,  6,  10 };//{9,0,6,5,8,2,1,7,4,3};
    char methodName[] = "选择排序";
    int *b = bubbleSort(methodName,a, 10);
    for (int i=0; i< 10; i++) {
        printf("%i ", *(b+i));
    }

//选择排序
int* selectSort(char methodName[], int array[], int length){
    
    for (int i = 0; i < (length-1); i ++) {//需要循环的次数
        for (int k = 0; k < (length - i); k++) {//按照从小往大的排，末尾的是排好的，所以前面还有（length-i）个没有排好
            if (*(array+k)>*(array+k+1)) {
                int a = *(array+k);
                *(array+k) = *(array+k+1);
                *(array+k+1) = a;
            }
        }
    }
    
    return  array;
}

```

打印：

```
=================选择排序=================
1 2 3 4 5 6 7 8 9 10 
```



<br/>
<br/>


> <h2 id="插入排序">插入排序（Insertion Sort）</h2>

**插入排序（Insertion sort）** 是一种简单直观的排序算法。

它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

- 插入排序的算法步骤如下：

	- 1). 从第一个元素开始，该元素可以认为已经被排序；

	- 2). 取出下一个元素，在已经排序的元素序列中从后向前扫描；

	- 3). 如果该元素（已排序）大于新元素，将该元素移到下一位置；

	- 4). 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；

	- 5). 将新元素插入到该位置后；

	- 6). 重复步骤2~5。

图示如下：

![插入排序 <br/>](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/c2_3.gif)


```
int* insertionSort(char methodName[], int array[], int length);

int main(int argc, const char * argv[]) {
    
    //    插入排序
    int a[] = {9,0,6,5,8,2,1,7,4,3};
    char methodName[] = "插入排序";
    int *b = insertionSort(methodName,a, 10);
    for (int i=0; i< 10; i++) {
        printf("%i ", *(b+i));
    }
}

//插入排序
int* insertionSort(char methodName[], int array[], int length) {
    printf("=================%s=================\n", methodName);

    for (int i = 0, j, temp; i < length -1; i ++) {
        
        j = i;
        temp = *(array+i+1);//{9,0,6,5,8,2,1,7,4,3}
        
        //作用：1.用来比较前后2个元素的大小，当后面的比前面的大时就调换位置；
        //2.遇到最前面的元素小于temp时，跳出这个while循环
        while (j >= 0 && array[j] > temp) {
            array[j+1] = array[j]; //第一次时array[j+1]是最大的，但是随着j越来越小array[j+1]不是最大的了，如：j第一次为5，后来变成了4，3，2，1分别越来越对应最初的元素了{0,6,9
            --j;
        }
        //把要插入的值插入进去，因为在上面j已经减去1了，所以这里面j要加1
        array[j+1] = temp;
    }
    return  array;
}


```

打印结果：

```
=================插入排序=================
0 1 2 3 4 5 6 7 8 9 
```


<br/>
<br/>

> <h2 id="希尔排序">希尔排序（Shell Sort）</h2>
**希尔排序**，也称 递减增量排序算法，是 插入排序 的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到 线性排序 的效率；

但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

步长的选择是希尔排序的重要部分。

只要最终步长为1任何步长序列都可以工作。

算法最开始以一定的步长进行排序。

然后会继续以一定步长进行排序，最终算法以步长为1进行排序。

当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。

- 插入排序的算法步骤如下：

	- 定义一个用来分割的步长；
	
	- 按步长的长度K，对数组进行K趟排序；
	
	- 不断重复上述步骤。

图示如下：


![<br/>](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/c2_4.gif)

```


```


<br/>
<br/>


![<br/>](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/c2_5.gif)


<br/>
<br/>


![<br/>](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/c2_6.gif)



<br/>
<br/>



![<br/>](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/c2_7.1.png)

![<br/>](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/c2_7.2.png)

![<br/>](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/c2_7.3.png)


<br/>
<br/>



![<br/>](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/c2_8.gif)









<br/>
<br/>




> <h2 id="快速排序">快速排序</h2>
- [x] [快速排序](http://c.biancheng.net/view/198.html)