- **性质**
- **遍历**
- **二叉树的前、中、后遍历**



<br/>

***
<br/>

># 性质
性质1：`二叉树的第i层上至多有 2^(i-1) 个节点(i≥1)。`
i = 4 , 2^(4-1) = 8.

性质2：`深度为k的二叉树至多有  2^(k-1) 个节点(k≥1).`
k = 4, 有 1+2+4+8 = 15 = 2^(4-1) 个节点。

性质3：`任何一棵一棵二叉树T，如果其终端结点数为 n0 ，度为2的节点数为 n2，则 n0 = n2 +1；`
叶子节点数为 5， 度为2的节点数为4，则 5 = 4 +1;

性质4：`具有n个节点的完全二叉树的深度为「log2n」+1(「x」表示不大于x的最大整数)。`

性质5：`如果对一个有n个结点的完全二叉树(其深度为「log2n」+1)的节点按层序编号(从第1层到第「log2n」+1 层，每层从左到右)，对任一节点i (1≤i≤n
)有：`
&emsp;  `①. 如果i=1，则结点i是从二叉树的根，无双亲；如果i>1,则其双亲是结点「i/2」；`
&emsp;  `②. 如果 2i>n,则结点i无左孩子(结点i为叶子结点)，否则其左孩子是结点2i；`
&emsp; ` ③. 如果 2i+1 > n,则结点i无右孩子，否则其右孩子是结点 2i +1.`


<br/>

***
<br/>


># 遍历

- **`前序遍历：若二叉树为空，则返回。否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。`**
![](https://raw.githubusercontent.com/harleyGit/StudyNotes/master/Pictures/a0.jpg)


- **`中序遍历：若树为空，则空返回。否则先从根节点开始，中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树`**
- **`后序遍历：若树为空，则空返回。否则从左到右先叶子后节点的方式遍历访问左右子树，最后访问根节点`**


<br/>
<br/>

# `易错点`

`.h 文件`

```
#ifndef BinaryTree_h
#define BinaryTree_h

#include <stdio.h>
#include <stdlib.h>
#include "math.h"
#include "string.h"

#include "LinearListStoragge.h"


typedef struct BinaryTreeNode {
    char data;
    struct BinaryTreeNode *leftChild;
    struct BinaryTreeNode *rightChild;
} BinaryTreeNode;


void binaryTreeTest(void);

#endif
```

`.c文件`

```
int initBinaryTree(BinaryTreeNode *binaryTree){
    binaryTree = (BinaryTreeNode *)malloc(sizeof(BinaryTreeNode));
    if (!binaryTree) {
        return FALSE;
    }
    
    binaryTree->data = '$';
    binaryTree->leftChild = NULL;
    binaryTree->rightChild = NULL;

   return TRUE;
}

void  setTest(BinaryTreeNode *node){
    node = (BinaryTreeNode *)malloc(sizeof(BinaryTreeNode));
    node->data = 'S';
}


void binaryTreeTest(void){
    BinaryTreeNode binaryTree;
    
    int statusCode = 0;
    

    statusCode = initBinaryTree(&binaryTree);
    setTest(&binaryTree);
}
```

打印：
<br/>
`(lldb) po binaryTree->data`
<br/>
`<nil>`
<br/>

&emsp;  这是因为在 `initBinaryTree` 方法中有 ` binaryTree = (BinaryTreeNode *)malloc(sizeof(BinaryTreeNode));` 相当于又重新初始化了一个结构体 `BinaryTreeNode `,若没有这段代码，可以打印出 `S` 字符。



<br/>
<br/>

># `二叉树的前、中、后遍历`

`.h文件`

```
#ifndef BinaryTree_h
#define BinaryTree_h

#include <stdio.h>
#include <stdlib.h>
#include "math.h"
#include "string.h"

#include "LinearListStoragge.h"

typedef struct BinaryTreeNode {
    char data;
    struct BinaryTreeNode *leftChild;
    struct BinaryTreeNode *rightChild;
} BinaryTreeNode, *BinaryTree;


void binaryTreeTest(void);


#endif 

```


# `.c文件`

```
#include "BinaryTree.h"
char characters[24] = "ABDH#K###E##CFI###G#J##";//BDH#K###E##CFI###G#J##
int number = 0;

void createBinaryTree(BinaryTree *binaryTree){
    char data = characters[number++];
    
    if (data == '#' || data == '\0') {
        *binaryTree = NULL;
    }else {
        *binaryTree = (BinaryTree)malloc(sizeof(BinaryTreeNode));
        if (!*binaryTree) {
            exit(OVERFLOW);
        }
        
        (*binaryTree)->data = data;
        createBinaryTree(&(*binaryTree)->leftChild);
        createBinaryTree(&(*binaryTree)->rightChild);
    }
    
}

//判断二叉树是否为空
int isEmptyBinaryTree(BinaryTree *binaryTree){
    if (binaryTree != NULL) {
        return TRUE;
    }
    return FALSE;
}

//计算二叉树的深度
int caculateBinaryTreeDepth(BinaryTree *binaryTree){
    int i, j;
    if (*binaryTree == NULL) {
        return 0;
    }
    
    if ((*binaryTree)->leftChild) {
        i = caculateBinaryTreeDepth(&(*binaryTree)->leftChild);
    }else {
        i = 0;
    }
    
    if ((*binaryTree)->rightChild) {
        j = caculateBinaryTreeDepth(&(*binaryTree)->rightChild);
    }else {
        j = 0;
    }
    
    
    return i>j ? i+1 : j+1;
}


//中序遍历
void infixOrderTraverse(BinaryTree *binaryTree){
    if (*binaryTree == NULL) {
        return;
    }
    
    infixOrderTraverse(&(*binaryTree)->leftChild);
    printf("%c",(*binaryTree)->data);
    infixOrderTraverse(&(*binaryTree)->rightChild);
    
    return;
}


//后序遍历
void epilogueOrderTraverse(BinaryTree *binaryTree){
    if (*binaryTree == NULL) {
        return;
    }
    
    epilogueOrderTraverse(&(*binaryTree)->leftChild);
    epilogueOrderTraverse(&(*binaryTree)->rightChild);
    printf("%c",(*binaryTree)->data);
    
    return;
}

//前序遍历
void preorderTraverse(BinaryTree *binaryTree){
    if (*binaryTree == NULL) {
        return;
    }
    
    printf("%c",(*binaryTree)->data);
    preorderTraverse(&(*binaryTree)->leftChild);
    preorderTraverse(&(*binaryTree)->rightChild);
}

int initBinaryTree(BinaryTree *binaryTree){
    *binaryTree = NULL;
    
    return TRUE;
}


//方法调用
void binaryTreeTest(void){
    BinaryTree binaryTree; //等价于：BinaryTreeNode* binaryTree;
    
    int statusCode = 0;
    
    statusCode = initBinaryTree(&binaryTree);
    
    //创建二叉树
    createBinaryTree(&binaryTree);
    
    statusCode = isEmptyBinaryTree(&binaryTree);
    printf("\n\n空树：%d(1否 0是)", statusCode);
    
    statusCode = caculateBinaryTreeDepth(&binaryTree);
    printf("\n\n二叉树的深度为：%d", statusCode);
    
    printf("\n\n前序遍历：");
    preorderTraverse(&binaryTree);
    
    printf("\n\n中序遍历：");
    infixOrderTraverse(&binaryTree);
    
    
    printf("\n\n后序遍历：");
    epilogueOrderTraverse(&binaryTree);
    
    
    
}

```
打印：

`空树：1(1否 0是)`

`二叉树的深度为：5`

`前序遍历：ABDHKECFIGJ`

`中序遍历：HKDBEAIFCGJ`

`后序遍历：KHDEBIFJGCA`

<br/>

***
<br/>


<br/>

***
<br/>
