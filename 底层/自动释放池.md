- **Autorelease原理**
- **Autorelease 释放时刻**




<br/>

***
<br/>

># Autorelease原理

自动释放池的创建和释放，销毁的时机如下所示

- `kCFRunLoopEntry`; // 进入runloop之前，创建一个自动释放池
- `kCFRunLoopBeforeWaiting`; // 休眠之前，销毁自动释放池，创建一个新的自动释放池
- `kCFRunLoopExit`; // 退出runloop之前，销毁自动释放池

<br/>

**`AutoreleasePoolPage`**

&emsp;  `ARC`下,使用`@autoreleasepool{}`来使用一个`AutoreleasePool`，随后编译器将其改写成下面的样子：

```
void *context = objc_autoreleasePoolPush();
{// {}中的代码

}
objc_autoreleasePoolPop(context);
```
&emsp;  而这两个函数都是对`AutoreleasePoolPage`的简单封装，所以自动释放机制的核心就在于这个类。
&emsp;  `AutoreleasePoolPage`是一个C++实现的类
![image.png](https://upload-images.jianshu.io/upload_images/2959789-62fa537bae05bd0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

-  `AutoreleasePool`并没有单独的结构，而是由若干个`AutoreleasePoolPage`以双向链表的形式组合而成（分别对应结构中的parent指针和child指针）
-  `AutoreleasePool`是按线程一一对应的（结构中的`thread`指针指向当前线程）
`AutoreleasePoolPage`每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存 `autorelease`对象的地址
-  上面的`id *next`指针作为游标指向栈顶最新`add进来的autorelease对象`的下一个位置。
-  一个`AutoreleasePoolPage`的空间被占满时，会新建一个`AutoreleasePoolPage`对象，连接链表，后来的autorelease对象在新的page加入。



<br/>

&emsp;  若当前线程中只有一个AutoreleasePoolPage对象，并记录了很多autorelease对象地址时内存如下图：
![AutoreleasePoolPage 存储对象](https://upload-images.jianshu.io/upload_images/2959789-756d667be4634175.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&emsp;  图中的情况，这一页再加入一个autorelease对象就要满了（也就是next指针马上指向栈顶），这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。

&emsp;  所以，`向一个对象发送- autorelease消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置。`


<br/>
># Autorelease 释放时刻
&emsp;  每当进行一次`objc_autoreleasePoolPush`调用时，runtime向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是个nil）， 如下图：
![push 哨兵对象](https://upload-images.jianshu.io/upload_images/2959789-acbe34052c078645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&emsp; `objc_autoreleasePoolPush` 的返回值是这个哨兵对象的地址，被`objc_autoreleasePoolPop` (哨兵对象)作为入参，于是根据传入的哨兵对象地址找到哨兵对象所处的page。

&emsp; 在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置

&emsp; 补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page。`objc_autoreleasePoolPop`执行后，最终变成了下面的样子：
![pop 哨兵对象](https://upload-images.jianshu.io/upload_images/2959789-1eadbb5ba52c2f98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**`嵌套的AutoreleasePool`**
&emsp;  知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。

<br/>

- **释放条件**

1）手动释放Autorelease pool

2）Runloop结束后自动释放

&emsp; 对于autorelease pool内部的对象在引用计数的retain == 0的时候释放。release和autorelease pool 的 drain都会触发retain事件。

<br/>

- **释放原理**

&emsp; 程序在main()调用的时候会自动调用一个autorelease，然后在每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的 Autorelease pool（main()里的autorelease）会被销毁，这样这个pool里的每个Object会被release。

&emsp; 可以把autorelease pool理解成一个类似父类与子类的关系，main()创建了父类，每个Runloop自动生成的或者开发者自定义的autorelease pool都会成为该父类的子类。当父类被释放的时候，没有被释放的子类也会被释放，这样所有子类中的对象也会收到release消息。

&emsp; 那什么是一个Runloop呢？ 一个UI事件，Timer call， delegate call， 一个鼠标事件,键盘按下(MAC OSX),或者iphone上的触摸事件，异步http连接下后当接收完数据时，都会是一个新的Runloop。


