- **Autorelease原理**
- **Autorelease 释放时刻**




<br/>

***
<br/>

># Autorelease原理

自动释放池的创建和释放，销毁的时机如下所示

- `kCFRunLoopEntry`; // 进入runloop之前，创建一个自动释放池
- `kCFRunLoopBeforeWaiting`; // 休眠之前，销毁自动释放池，创建一个新的自动释放池
- `kCFRunLoopExit`; // 退出runloop之前，销毁自动释放池

<br/>

**`AutoreleasePoolPage`**

&emsp;  `ARC`下,使用`@autoreleasepool{}`来使用一个`AutoreleasePool`，随后编译器将其改写成下面的样子：

```
void *context = objc_autoreleasePoolPush();
{// {}中的代码

}
objc_autoreleasePoolPop(context);
```
&emsp;  而这两个函数都是对`AutoreleasePoolPage`的简单封装，所以自动释放机制的核心就在于这个类。
&emsp;  `AutoreleasePoolPage`是一个C++实现的类
![image.png](https://upload-images.jianshu.io/upload_images/2959789-62fa537bae05bd0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

-  `AutoreleasePool`并没有单独的结构，而是由若干个`AutoreleasePoolPage`以双向链表的形式组合而成（分别对应结构中的parent指针和child指针）
-  `AutoreleasePool`是按线程一一对应的（结构中的`thread`指针指向当前线程）
`AutoreleasePoolPage`每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存 `autorelease`对象的地址
-  上面的`id *next`指针作为游标指向栈顶最新`add进来的autorelease对象`的下一个位置。
-  一个`AutoreleasePoolPage`的空间被占满时，会新建一个`AutoreleasePoolPage`对象，连接链表，后来的autorelease对象在新的page加入。



<br/>

&emsp;  若当前线程中只有一个AutoreleasePoolPage对象，并记录了很多autorelease对象地址时内存如下图：
![AutoreleasePoolPage 存储对象](https://upload-images.jianshu.io/upload_images/2959789-756d667be4634175.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&emsp;  图中的情况，这一页再加入一个autorelease对象就要满了（也就是next指针马上指向栈顶），这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。

&emsp;  所以，`向一个对象发送- autorelease消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置。`


<br/>
># Autorelease 释放时刻
&emsp;  每当进行一次`objc_autoreleasePoolPush`调用时，runtime向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是个nil）， 如下图：
![push 哨兵对象](https://upload-images.jianshu.io/upload_images/2959789-acbe34052c078645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&emsp; `objc_autoreleasePoolPush` 的返回值是这个哨兵对象的地址，被`objc_autoreleasePoolPop` (哨兵对象)作为入参，于是根据传入的哨兵对象地址找到哨兵对象所处的page。

&emsp; 在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置

&emsp; 补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page。`objc_autoreleasePoolPop`执行后，最终变成了下面的样子：
![pop 哨兵对象](https://upload-images.jianshu.io/upload_images/2959789-1eadbb5ba52c2f98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**`嵌套的AutoreleasePool`**
&emsp;  知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。

