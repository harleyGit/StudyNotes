>
- [**方法关键字**](#方法关键字)
	- [@required](#@required)
	- [with](#with)




<br/>

***
<br/><br/>

> <h1 id='方法关键字'>方法关键字</h1>

<br/><br/>

> <h2 id='@required'>@required</h2>

使用 @required 注释表示参数是 required 性质的命名参数， 该方式可以在任何 Dart 代码中使用（不仅仅是Flutter）。


```
const Scrollbar({Key key, @required Widget child})
```

此时 Scrollbar 是一个构造函数， 当 child 参数缺少时，分析器会提示错误。



<br/><br/>

> <h2 id='with'>with</h2>

- Mixins : 指能够将另一个或多个类的功能添加到您自己的类中，而无需继承这些类。
- implements : 将一个类作为接口使用

```
class A {
  void a() {
    print('fun a => by a');
  }
}

class B implements A {
  @override
  void a() {
    print('fun a => by b');
  }
}

class C {

  void a() {
    print('fun a => by c');
  }

  void c() {
    print('fun c => by c');
  }

  void s(){
    print('fun s => by c');
  }
}

class E {
  String e = 'eeee';

  void s(){
    print('fun s => by e');
  }
}

class D extends A with C, E {
  void c() {
    print('fun c => by d');
  }
}

void main() {
  D d = new D();
  d.a();
  d.s();
  d.c();
}
```

**Log:**

```
fun a => by c
fun s => by e
fun c => by d
```

首先看B implements A，所以此时A相对于B来说就是一个接口，所以他要实现B中的方法。换句话说，Dart每个类都是接口

然后看D extends A with C ,D继承于A,由于单继承特性，这个时候D不能再使用extends关键字继承其他类，但是可以使用with关键字折叠其他类以实现代码重用。当属性和方法重复时，以当前类为准。，比如以上例子就是 A => C => E => D 



