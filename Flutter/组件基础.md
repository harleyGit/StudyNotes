># <h2 id=''>[《Flutter实战·第二版》](https://book.flutterchina.club/)</h2>
- [**App生命周期**](#App生命周期)
	- [WidgetsBinding](#WidgetsBinding)
	- [WidgetsBindingObserver生命周期事件](#WidgetsBindingObserver生命周期事件)
- [**Widget 、Element、RenderObject三者联系**](#Widget、Element、RenderObject三者联系)
	- [Flutter 的 Widget更新机制](#Flutter的Widget更新机制)
	- [角色分析](#角色分析)
	- [Element与Widget和renderObject的联系](#Element与Widget和renderObject的联系)
		- [context使用条件](#context使用条件)
- [**`StatelessWidget`**](#StatelessWidget)
	- [context属性](#context属性)
	- [StatelessWidget生命周期](#StatelessWidget生命周期)
- [**`StatefulWidget`**](#StatefulWidget)
	- [StatefulWidget生命周期](#StatefulWidget生命周期)
		- [createState ](#createState)
		- [initState](#initState)
		- [didChangeDependencies](#didChangeDependencies)
		- [build](#build)
		- [addPostFrameCallback](#addPostFrameCallback)
		- [didUpdateWidget](#didUpdateWidget)
		- [deactivate](#deactivate)
		- [dispose](#dispose)
- [**`Flutter SDK自带组件库`**](#FlutterSDK自带组件库)
- [**功能型组件**](#功能型组件)
	- [MaterialApp](#MaterialApp)
	- [Scaffold](#Scaffold)
	- [导航返回拦截（WillPopScope）](#导航返回拦截（WillPopScope）)
	- [按需rebuild（ValueListenableBuilder）](#按需rebuild（ValueListenableBuilder）)
	- [Widget管理自身状态](#Widget管理自身状态)
		- [父Widget管理子Widget的状态](#父Widget管理子Widget的状态)
		- [跨组件状态共享](#跨组件状态共享)
			- [InheritedWidget](#InheritedWidget)
				- [dependOnInheritedWidgetOfExactType方法](#dependOnInheritedWidgetOfExactType方法)
				- [findAncestorWidgetOfExactType方法](#findAncestorWidgetOfExactType方法)
				- [区别](#区别)
				- [widget之间的交互](#widget之间的交互)
			- [Provider](#Provider)
				- [**提供者**](#提供者)
					- [ChangeNotifier使用](#ChangeNotifier使用) 
					- [`FutureProvider`（异步加载数据）](#`FutureProvider`（异步加载数据）)
					- [`StreamProvider`（监听数据流）](#`StreamProvider`（监听数据流）)
					- [` MultiProvider `](#MultiProvider)
					- [` ProxyProvider `](#ProxyProvider)
					- [`ChangNotifierProxyProvider`](#ChangNotifierProxyProvider)
					- [`ListenableProvider`](#ListenableProvider)
					- [`‌ListenableProxyProvider`](#ListenableProxyProvider)
					- [`‌ValueListenableProvider`](#ValueListenableProvider)
				- [**消费者**](#消费者)
					- [`Provider.of`](#Provider.of)
					- [Consumer组件使用](#Consumer组件使用)	
					- [`Selector`](#Selector)
					- [`InheritedContext`](#InheritedContext)
						- [`BuildContext.read`](#BuildContext.read)
						- [`BuildContext.watch`](#BuildContext.watch)
			- [context获取widget树中state对象](#context获取widget树中state对象)
			- [Builder](#builder)
	- [异步UI更新（FutureBuilder、StreamBuilder）](#异步UI更新（FutureBuilder、StreamBuilder）)
		- [FutureBuilder](#FutureBuilder)
		- [StreamBuilder](#StreamBuilder)
			- [详解AsyncSnapshot](#详解AsyncSnapshot)
- [系统方法调用顺序](#系统方法调用顺序)
	- [状态 setState方法调用](#状态setState方法调用)
	- [导航 Navigation](#导航Navigation)
- [**`路由管理`**](#路由管理)
	- [详解WidgetBuilder](#详解WidgetBuilder)
	- [路由导航](#路由导航)
- [**Stream**](#Stream)
	- [分类](#分类)
		- [StreamController](#StreamController)
		- [listen](#listen)
	- [单订阅](#单订阅)
	- [多订阅流](#多订阅流)
- [异常抛出](#异常抛出)
	- [Throw](#Throw)
	- [Catch](#Catch)
		- [关键字On](#关键字On)
	- [再次抛出异常rethrow](#再次抛出异常rethrow)
	- [Finally](#Finally)
- [**行、列布局**](#行、列布局)
- [**iOS项目嵌入Flutter模块**](#iOS项目嵌入Flutter模块) 
	- [构建FlutterModule到原生](#构建FlutterModule到原生)
	- [OC中调用FlutterModule的2种方式](#OC中调用FlutterModule的2种方式)
		- [直接使用FlutterViewController](#直接使用FlutterViewController)
		- [使用FlutterEngine的方式](#使用FlutterEngine的方式)
- **资料**
	- [Flutter实战教程pdf](https://book.flutterchina.club/)
	- [Flutter实现详解PDF](https://guoshuyu.cn/home/wx/)
	- [Provider状态管理---介绍、类图分析、基本使用](https://www.liujunmin.com/flutter/provider/introduction.html)
	- [核心概念详解：Widget、State、Context及InheritedWidget(泪已无痕-掘金)](https://juejin.cn/post/6844903784187953165#heading-24)
	- [异步编程：Future、Isolate 和事件循环(泪已无痕-掘金)](https://juejin.cn/post/6844903796334673933#heading-7)
	- [Flutter导航和路由教程示例](https://yiibai.com/flutter/flutter-navigation-and-routing.html)
	- [路由管理、资源管理](https://www.jianshu.com/p/257bc7e72709)
	- [创建自定义路由过渡动画](https://coldstone.fun/post/2019/12/10/flutter-route-transition/)
	- [进阶：路由、路由栈详解及案例分析](https://juejin.cn/post/6844903789816709128)
	- [组件可选参数Key的见解](https://juejin.im/post/5ca2152f6fb9a05e1a7a9a26)
	- [深入浅出Key(Vadaski-掘金)](https://juejin.cn/post/6844903811870359559)
	- [Widget管理自身状态](https://juejin.cn/entry/6844903864852807694)







<br/><br/><br/><br/><br/>

***
<br/>

> <h1 id='App生命周期'>App生命周期</h1>
[详解Flutter中各种Binding](https://blog.csdn.net/weixin_43740011/article/details/131344147)

<br/><br/><br/>
> <h2 id='WidgetsBinding'>WidgetsBinding</h2>
**简介**

`WidgetsBinding.instance.addObserver(this)` 是 Flutter 中用于向 Flutter 的核心框架注册一个生命周期观察者的方法。这句话出现在一个实现了 WidgetsBindingObserver 接口的类中，通常是自定义的 StatefulWidget 或 StatelessWidget 的子类。

通过调用 addObserver，该类将能够接收到 Flutter 框架特定生命周期事件的通知，从而能够在这些关键时刻执行相应的操作。

<br/>

**以下是对此语句的详细解释：**

- **WidgetsBinding:** WidgetsBinding 是 Flutter 框架中 Binding 类的一个实例，它是 Flutter 应用程序与 Flutter 引擎之间的桥梁。它负责管理应用程序的生命周期、事件循环、系统事件处理、渲染流程等关键任务。`WidgetsBinding.instance` 提供了对全局单例 WidgetsBinding 实例的访问。

- **addObserver:** addObserver 是 WidgetsBinding 类提供的一个方法，用于注册一个实现了 WidgetsBindingObserver 接口的对象。当应用程序进入特定的生命周期阶段或发生特定的系统事件时，WidgetsBinding 会通知已注册的观察者。

- **this:** 这里的 this 指向当前正在调用 addObserver 方法的类实例，该类必须实现了 WidgetsBindingObserver 接口。通过将 this 作为参数传递，意味着当前类将作为生命周期观察者注册到 WidgetsBinding 中。


<br/><br/><br/>
> <h2 id='WidgetsBindingObserver生命周期事件'>WidgetsBindingObserver生命周期事件</h2>
**WidgetsBindingObserver:** `WidgetsBindingObserver` 是一个接口，定义了一系列与 Flutter 应用生命周期相关的回调方法。当一个类实现了这个接口并注册为观察者后，它将有机会在以下生命周期事件发生时得到通知：

- **didChangeAppLifecycleState:** 当应用程序的生命周期状态（如：inactive、paused、resumed、detached）发生变化时调用。这对于管理应用程序在后台、前台之间切换时的资源、状态更新非常有用。

<br/>

- **didChangeMetrics:** 当窗口尺寸、屏幕方向等与窗口相关的度量信息发生变化时调用。这对于响应屏幕旋转、窗口缩放等场景下的布局调整非常关键。

<br/>

- **didHaveMemoryPressure:** 当系统内存压力增大时调用，提示观察者释放不必要的资源以减少内存占用。

<br/>

- **didChangePlatformBrightness:** 当设备的亮度模式（如：亮屏模式、暗屏模式）发生变化时调用，可用于调整界面主题以适应不同的亮度环境。

<br/>

- **didChangeLocales:** 当系统的语言区域设置发生变化时调用，可以用来更新界面语言或重新加载本地化资源。


<br/><br/>

- **使用场景:**

	- **资源管理：**根据应用程序的生命周期状态（如进入后台或恢复前台）释放或重新加载资源，如暂停网络请求、停止定时器、恢复动画等。
	
	- **UI 更新**：当窗口尺寸、屏幕方向变化时，重新计算布局或调整界面元素的显示方式。
	
	- **性能优化**：在内存压力增大时，清理缓存、释放非关键内存以避免应用被系统强制关闭。
	
	- **用户体验：** 响应系统亮度变化，调整界面主题以提供更好的夜间阅读体验；或在语言切换时更新界面文字以匹配用户偏好。


<br/><br/>
&emsp; 想要知道 Flutter App 的生命周期，例如 Flutter 是在前台还是在后台，就需要使用到 WidgetsBindingObserver 了，**使用如下Demo：**

State 的类 mix WidgetsBindingObserver：

```dart
class _MyHomePageState extends State<MyHomePage> with WidgetsBindingObserver {
    ...
}
```

<br/>

在 State 的 initState 里添加监听：

```dart
@override
  void initState(){
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }
  ```


<br/>
在 State 的 dispose 里移除监听：

```dart
@override
void dispose() {
// TODO: implement dispose
super.dispose();
WidgetsBinding.instance.removeObserver(this);
}
```

<br/>
在 State 里 override didChangeAppLifecycleState

```
@override
void didChangeAppLifecycleState(AppLifecycleState state) {
  super.didChangeAppLifecycleState(state);
  
  // 根据生命周期状态执行相应操作
  if (state == AppLifecycleState.paused) {
    // went to Background
  }
  if (state == AppLifecycleState.resumed) {
    // came back to Foreground
  }
}
```

<br/><br/>
AppLifecycleState 就是 App 的生命周期，有：

- **resumed：** 表示应用程序处于活动状态并且正在与用户交互
	- 在 iOS 上，此状态对应于应用程序在前台并可响应用户输入。
<br/>

- **inactive：** 表示应用程序处于非活动状态，并且不能与用户交互。通常在应用程序过渡到其他状态时出现，例如当应用程序正在从 paused 状态变为 resumed 状态时。
	- 在 iOS 上，当应用程序收到电话、短信或者其他系统通知时会进入此状态

<br/>

- **paused：** 表示应用程序处于后台，并且不会与用户交互，但仍在内存中运行
	- 在 iOS 上，此状态对应于应用程序不在前台运行，但仍在内存中。

<br/>

- **suspending：** 仅适用于旧版本的 Flutter，并且在最新版本中已被弃用
	- 表示应用程序即将暂停，并且不能保证恢复。此状态主要用于在应用程序挂起之前执行一些清理工作。
	- 在 iOS 上，当应用程序即将被系统挂起时会进入此状态

<br/>

- **detached：** （在较新的 Flutter 版本中，当前推荐使用 detached 作为取代 suspending 的状态）
	- 表示应用程序已经从主机视图分离，通常是因为应用程序将被销毁



<br/><br/><br/>

***
<br/>

> <h1 id='Widget、Element、RenderObject三者联系'>Widget 、Element、RenderObject三者联系</h1>
&emsp; Widget 这个角色是Flutter SDK 封装好的一些接口以便开发者便捷开发应用程序，实际绘制到手机屏幕上时是通过 RenderObject 这个角色来处理的，也就是 一个 Widget如Text要显示出来，要经历 Widget --> Element --> RenderObject 这三个阶段的转换。

<br/><br/><br/>
> <h2 id="Flutter的Widget更新机制">Flutter 的 Widget 更新机制</h2>

- **Flutter 主要有三个核心概念：**
	- Widget（不可变，描述 UI 结构）
	- Element（可变，管理 Widget 的生命周期）
	- RenderObject（底层渲染，真正绘制 UI）

<br/>

当 setState() 触发 UI 变化时，Flutter 不是直接重建整个 UI，而是遵循以下流程：

- 1.Widget Rebuild（重建 Widget）
	- build() 方法会被重新调用，创建新的 Widget。
	- 但 Widget 只是配置数据，它不会直接影响 UI 性能。

- 2.Element Tree Diff（Element 复用）
	- Flutter 不会销毁整个 UI，而是对比新的 Widget 树和旧的 Element 树。
	- 如果Widget 类型相同，Flutter 复用现有的 Element，只更新 Widget 数据。
	- 如果Widget 类型不同，Flutter 销毁旧的 Element 并创建新的 Element。

- 3.RenderObject 复用
	- 只要 Element 复用了，RenderObject 也会尽量复用，从而避免昂贵的绘制开销。


[那如何优化Widget的复用呢？](./优化.md#widget复用优化)

<br/><br/>
> <h2 id='角色分析'>角色分析</h2>
&emsp; 在 Flutter 的 Engine 层向  层的暴露了 Canvas, PictureRecorder 等接口，利用这些接口可以绘制自己想要的图像，通过 Canvas, PictureRecorder 等接口来绘制图像，这操作有点复杂，不利于便捷开发，所以一般常使用 Widget。

&emsp; 如下代码 一个 线性布局 Column 中排列了两个 文本 Text ：

```dart
Widget buildColumnWidget(){
    return Column(children: [
      Text("张三"),
      Text("李四"),
    ],);
  }
```

实际项目中的显示效果如下图所示，为两个文本在竖直方向线性排列：

![flutter1_81_0.png](./../Pictures/flutter1_81_0.png)

在这里构建了三个Widget，Column 与两个Text，它们的Widgets树形结构排列如下：


![flutter1_81_1.png](./../Pictures/flutter1_81_1.png)

&emsp; Widget的构建相当于是构建一定的配置信息，或者说是 Widget 的组合构建，**相当于是将封装的一些特定的绘制指令进行组合**。

&emsp; 组合好的Widget在程序执行到build方法时，会**通过 createRenderObject 方法来创建对应的renderObject渲染对象**。

&emsp; 一个图像要绘制出来，首先要进行**测量计算（位置与大小）**，然后再根据测量计算的结果**进行排版（layout）**,最后再进行**绘制（Paint）**，这整一个操作过程是通过 renderObject对象来实现的，也就是说renderObject是最终真正的渲染对象。

<br/>

- **Element的由来:** `renderObject`对象第一步进行的计算数据的基础配制是在 Widget中构建的，所以需要从Widget中获取这些数据，renderObject对象的这一系列操作也需要一个载体，所以就有了 Element。

<br/>

- **Element树:** 每一个 Widget都包含者绘制图像的配置信息，每一个配置信息都需要对应的一个renderObject对象来实现操作，所以有Widgets树，就也有renderObjects树，widget与renderObject之间需要 Element来协调配合，所以也有了 Element树。

<br/>
如在上图 Widget树，当Column与Text被构建时，同时当前的 StatelessWidget或者是StatefulWidget中通过Widget.createElement方法来创建Element，框架层通过调用mount方法来将新创建的Element添加到**给定父级中给定槽点的树上**，所以对应着就构建了第二颗树如下图所示：

![flutter1_81_2.png](./../Pictures/flutter1_81_2.png)

同时函数mount被调用的时候，框架层会调用`RenderObjectWidget.createRenderObject()`来实例化RenderObject，此时对应的第三颗树也就形成.



<br/><br/>
> <h2 id='Element与Widget和renderObject的联系'>Element与Widget和renderObject的联系</h2>


&emsp; Element 负责协调 Widget 与 renderObject，Element 同时持有 Widget 和 RenderObject，Element存放Widget上下文， Element 也就是我们在开发中通常使用到的 context，通过context 可以获取 Widget树中的信息，也可以获取对应的 renderObject中的信息。


<br/><br/>
> <h2 id=''>context使用条件</h2>

<br/>

&emsp; 我们在调用build时候的入参BuildContex其实返回的就是Element，在实际开发中，通常也会使用到 context，实际上context的返回也是element实例，如下:

```dart
BuildContext get context => _element;
```

所以在实际项目开发中，在StatefulWidget的initState方法中，是不可使用 context ,因为此时的StatefulWidget对应的Element（也就是BuildContext）才刚刚创建，还没有形成绑定关系，也没有与对应的RenderObject绑定起来,所以不能使用。

同理在 方法 dispose中，StatefulWidget 与 Element 、RenderObject已解绑，所以也不能使用。

只有在绑定期间才可使用，在绑定与解绑都会回调生命周期方法 didChangeDependencies，所以可以在didChangeDependencies这个方法中使用 context做一些相关的操作，代码如下：

```dart
@override
void didChangeDependencies() {
	super.didChangeDependencies();
	
	///是否是路由栈中的第一个页面
	bool isFirst = ModalRoute.of(context).isFirst;
	///当前手机屏幕上显示的是否是这个页面Widget
	bool isCurrent = ModalRoute.of(context).isCurrent;
	///当前Widget是否是活跃可用的
	///当调用 pop 或者是关闭当前Widget时 isActive 为false
	bool isActive = ModalRoute.of(context).isActive;
	
	if(isActive){
	  ///页面 活跃状态
	}else{
	  ///页面将要解绑
	}
}
```


<br/><br/>

所以在实际项目开发中，可以为每一个 Widget  绑定一个GlobalKey，通过 GlobalKey来获取对应的Element（BuildContext），然后通过Element来获取对应的RenderObject，从而获取这个Widget 在手机 屏幕上对应的位置与大小 信息，代码如下：


```dart
///第一步 创建 GlobalKey
GlobalKey globalKey = GlobalKey();

///第二步在 对应的Widget 引用 ，如这里的Text
Text('张三',key:globalKey);

///第三步 通过 globalKey 来获取 对应的Element（BuildContext） 
BuildContext stackContext = globalKey.currentContext;
///第四步 获取对应的 RenderObject
///RenderObject是抽象的，它的一些基础信息封装在子类RenderBox中
RenderBox renderBox = stackContext.findRenderObject();
///然后通过 RenderBox 来获取对应的Text在手机屏幕上显示的位置 与大小 信息
///相对于全局的位置
Offset offset = renderBox.localToGlobal(Offset.zero);
///获取指定的Widget的大小 信息
Size size = renderBox.paintBounds.size;
```


<br/><br/><br/>

***
<br/>

># <h1 id='StatelessWidget'>StatelessWidget</h1>
&emsp;  `StatelessWidget`用于不需要维护状态的场景，它通常在build方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget。

```dart
class Echo extends StatelessWidget {

  final String text;
  final Color backgroundColor;

  const Echo({
    Key key,
    @required this.text,
    this.backgroundColor: Colors.grey,
  }): super(key: key);  
//Key: 这个key属性类似于React/Vue中的key;
//主要的作用是决定是否在下一次build时复用旧的widget，决定的条件在canUpdate()方法中

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Container(
        color: backgroundColor,
        child: Text(text),
      ),
    );
  }
}


//调用
Widget build(BuildContext context) {
  return MaterialApp(
    color: Colors.white,
    home: Echo(text: "welcome to 我的家", backgroundColor: Colors.white),
  );
}
```

&emsp;  widget的构造函数参数应使用命名参数，`命名参数中的必要参数要添加@required标注`，这样有利于静态代码分析器进行检查。

&emsp;  另外，`在继承widget时，第一个参数通常应该是Key`.另外，如果Widget需要接收子Widget，那么child或children参数通常应被放在参数列表的最后。同样是按照惯例，`Widget的属性应尽可能的被声明为final，防止被意外改变`。

![flutter1_61.png](./../Pictures/flutter1_61.png)

<br/>
> <h2 id='context属性'>context属性</h2>


&emsp;  `build`方法有一个`context`参数，它是`BuildContext`类的一个实例，表示当前widget在widget树中的上下文，每一个widget都会对应一个context对象（因为每一个widget都是widget树上的一个节点）。

&emsp;  实际上，context是当前widget在widget树中位置中执行”相关操作“的一个句柄，比如它提供了从当前widget开始向上遍历widget树以及按照widget类型查找父级widget的方法。

```dart
@override
Widget build(BuildContext context) {
  return Scaffold(
    appBar: AppBar(
      title: Text("Context 测0000000试"),
    ),
    body: Container(
      child: Builder(builder: (context) {
	    //寻找InheritedWidget的子类，可以以O(1)的复杂度查找上级Widget
        Scaffold scaffold = context.findAncestorWidgetOfExactType();
        return (scaffold.appBar as AppBar).title;
      }),
    ),
  );
}
```

![flutter1_62.png](./../Pictures/flutter1_62.png)

<br/><br/>
> <h2 id='StatelessWidget生命周期'>StatelessWidget生命周期</h2>
StatelessWidget 的生命周期只有一个，就是：`build`

<br/>


&emsp; build 是用来创建 Widget 的，但因为 build 在每次界面刷新的时候都会调用，所以不要在 build 里写业务逻辑，可以把业务逻辑写到你的 StatelessWidget 的构造函数里。

```dart
class TestWidget extends StatelessWidget{
  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    print('StatelessWidget build');
    return Text('Test');
  }
}
```


<br/><br/> <br/>

***
<br/>

># <h1 id='StatefulWidget '>StatefulWidget </h1>


**方法:**
- `createState()` 用于创建和Stateful widget相关的状态，它在Stateful widget的生命周期中可能会被多次调用。例如，当一个Stateful widget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例，其实，本质上就是一个StatefulElement对应一个State实例。
> &emsp;  在说`“widget树”`时它可以指`widget结构树`，但由于`widget与Element有对应关系（一可能对多）`，在有些场景（Flutter的SDK文档中）也代指“UI树”的意思。而在`stateful widget`中，`State对象也和StatefulElement具有对应关系（一对一）`，所以在Flutter的SDK文档中，可以经常看到“从树中移除State对象”或“插入State对象到树中”这样的描述。其实，无论哪种描述，其意思都是在描述“一棵构成用户界面的节点元素的树”。



<br/>

- **`State `**

&emsp;  一个`StatefulWidget`类会对应一个`State类`，State表示与其对应的`StatefulWidget`要维护的状态，State中的保存的状态信息有：

- 在widget 构建时可以被同步读取。

- 在widget生命周期中可以被改变，当State被改变时，可以手动调用其 `setState()`方法通知Flutter framework状态发生改变，Flutter framework在收到消息后，会重新调用其build方法`重新构建widget树`，从而达到更新UI的目的。


<br/>

- State中有两个常用属性：
	- `widget`，它表示与该`State实例关联的widget实例`，由Flutter framework动态设置。`注意`，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，`如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例`。
	- `context`, `StatefulWidget`对应的`BuildContext`，作用同`StatelessWidget的BuildContext`。

<br/><br/>
> <h2 id='StatefulWidget生命周期'>StatefulWidget生命周期</h2>
- 生命周期比较复杂，依次为：
	- **createState**
	- **initState**
	- **didChangeDependencies**
	- **build**
	- **addPostFrameCallback**
	- **didUpdateWidget**
	- **deactivate**
	- **dispose**

![z16](./../Pictures/z16.png)

<br/><br/>
> <h3 id='createState'>createState</h3>
createState 是 StatefulWidget 里创建 State 的方法，当要创建新的 StatefulWidget 的时候，会立即执行 createState，而且只执行一次，createState 必须要实现：

```
class MyScreen extends StatefulWidget {
@override
_MyScreenState createState() => _MyScreenState();
}
```

<br/><br/>
> <h3 id='initState'>initState</h3>
前面的 createState 是在创建 StatefulWidget 的时候会调用，initState 是 StatefulWidget 创建完后调用的第一个方法，而且只执行一次，类似于 Android 的 onCreate、iOS 的 viewDidLoad()，所以在这里 View 并没有渲染，但是这时 StatefulWidget 已经被加载到渲染树里了。

这时 StatefulWidget 的 mount 的值会变为 true，直到 dispose 调用的时候才会变为 false。可以在 initState 里做一些初始化的操作

在 override initState 的时候必须要调用 super.initState()：

```
@override
void initState() {
  super.initState();
  ...
}
```

<br/><br/>
> <h3 id='didChangeDependencies'>didChangeDependencies</h3>
&emsp; 当 StatefulWidget 第一次创建的时候，didChangeDependencies 方法会在 initState 方法之后立即调用，之后当 StatefulWidget 刷新的时候，就不会调用了.

&emsp; 除非你的 StatefulWidget 依赖的 InheritedWidget 发生变化之后，didChangeDependencies 才会调用，所以 didChangeDependencies 有可能会被调用多次


<br/><br/>
> <h3 id='build'>build</h3>

&emsp; 在 StatefulWidget 第一次创建的时候，build 方法会在 didChangeDependencies 方法之后立即调用.

&emsp; 另外一种会调用 build 方法的场景是，每当 UI 需要重新渲染的时候，build 都会被调用，所以 build 会被多次调用，然后 返回要渲染的 Widget。千万不要在 build 里做除了创建 Widget 之外的操作，因为这个会影响 UI 的渲染效率。


<br/><br/>
> <h3 id='addPostFrameCallback'>addPostFrameCallback</h3>
&emsp； addPostFrameCallback 是 StatefulWidge 渲染结束的回调，只会被调用一次，之后 StatefulWidget 需要刷新 UI 也不会被调用，addPostFrameCallback 的使用方法是在 initState 里添加回调：

```
import 'package:flutter/scheduler.';
@override
void initState() {
	super.initState();
	SchedulerBinding.instance.addPostFrameCallback((_) => {
	
	});
}

```


&emsp； 渲染完成后，在这个方法里我们可以在[获取页面中Widget大小和位置](https://juejin.cn/post/6844903950257242119)，而且还可以进行网络接口请求

<br/><br/>
> <h3 id='didUpdateWidget'>didUpdateWidget</h3>


&emsp; didUpdateWidget 这个生命周期我们一般不会用到，只有在使用[key对 Widget进行复用](https://juejin.cn/post/6844904085007630349)的时候才会调用。

&emsp; 要注意的是Key是Widget、Element和SemanticsNode的标识符。 只有当新的Widget的Key与当前Element中Widget的Key相同时，它才会被用来更新现有的Element。 Key在具有相同父级的Element之间必须是唯一的。


<br/><br/>
> <h3 id='deactivate'>deactivate</h3>

&emsp; 当要将 State 对象从渲染树中移除的时候，就会调用 deactivate 生命周期，这标志着 StatefulWidget 将要销毁，但是有时候 State 不会被销毁，而是重新插入到渲染树种。


<br/><br/>
> <h3 id='dispose'>dispose</h3>
&emsp; 当 View 不需要再显示，从渲染树中移除的时候，State 就会永久的从渲染树中移除，就会调用 dispose 生命周期，这时候就可以在 dispose 里做一些取消监听、动画的操作，和 initState 是相反的

<br/><br/><br/>

***
<br/>

># <h1 id='FlutterSDK自带组件库'>Flutter SDK自带组件库</h1>

**基础组件**

- `import 'package:flutter/widgets.';`

&emsp;  `Flutter` 提供了一套丰富、强大的基础组件，在基础组件库之上`Flutter`又提供了一套`Material风格（Android默认的视觉风格）`和一套`Cupertino风格（iOS视觉风格）的组件库`。

<br/>

- **Material组件**
	- `import 'package:flutter/material.';`

&emsp;  `Material`组件，它可以帮助我们构建遵循Material Design设计规范的应用程序。Material应用程序以[`MaterialApp`](https://docs.flutter.io/flutter/material/MaterialApp-class.html) 组件开始， 该组件在应用程序的根部创建了一些必要的组件，比如`Theme`组件，它用于配置应用的主题。


<br/>

- **Cupertino组件**
	- `import 'package:flutter/cupertino.';`

&emsp;  `Cupertino风格的组件`，尽管目前还没有Material 组件那么丰富，但是它仍在不断的完善中。值得一提的是在Material 组件库中有一些组件可以根据实际运行平台来切换表现风格，比如MaterialPageRoute，在路由切换时，如果是Android系统，它将会使用Android系统默认的页面切换动画(从底向上)；如果是iOS系统，它会使用iOS系统默认的页面切换动画（从右向左）。


<br/>

`cupertinoTestRoute. 文件`

```
import 'package:flutter/cupertino.';

class cupertinoTestRoute extends StatelessWidget {

  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return CupertinoPageScaffold(
      navigationBar: CupertinoNavigationBar(
        middle: Text("Cupertino 组件库测试"),
      ),
      child: Center(
        child: CupertinoButton(
            color: CupertinoColors.activeOrange,
            child: Text("点击"),
            onPressed: () {}),
      ),
    );
  }
}

```


<br/>

**main. 文件**

```
//自定义类文件
import 'package:flutter_demo/customWidget/cupertinoWidget.';

//调用
Widget build(BuildContext context) {

  return MaterialApp(
    title: 'Flutter Demo',
    theme: ThemeData(
      primarySwatch: Colors.cyan,
    ),
    home: cupertinoTestRoute(),//初始化
  );
}

```

效果：

![flutter1_63.png](./../Pictures/flutter1_63.png)


<br/>

***
<br/><br/><br/>

># <h1 id='功能型组件'>功能型组件</h1>
> <h2 id="MaterialApp">MaterialApp</h2>
MaterialApp 是一个Flutter应用的顶级组件，它提供了应用的许多基础设施，包括主题、路由和本地化支持。主要功能包括：

- 主题（Theme）：提供了应用程序级别的主题设置，包括颜色、字体等，可以通过 theme 属性来设置全局的视觉风格。
- 路由（Routing）：管理应用的导航和页面路由，可以通过 routes 属性来定义应用的路由表，通过 Navigator 来实现页面跳转。
- 本地化（Localization）：支持多语言，可以通过 localizationsDelegates 和 supportedLocales 属性来配置应用的本地化设置。
- 导航控制（Navigator）：提供了一个默认的导航器，管理应用的页面堆栈和页面导航。

```
import 'package:flutter/material.';

void main() {
  runApp(MaterialApp(
    title: 'My Flutter App',
    theme: ThemeData(
      primarySwatch: Colors.blue,
    ),
    home: MyHomePage(),
  ));
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Home Page'),
      ),
      body: Center(
        child: Text('Welcome to My Home Page!'),
      ),
    );
  }
}
```


MaterialApp 是一个顶级组件，提供应用的全局配置和基础设施，如主题、路由和本地化等。

<br/><br/><br/>
> <h2 id="Scaffold">Scaffold</h2>

Scaffold

Scaffold 是一个实现了Material Design视觉结构的布局组件，用于构建应用的基本视觉布局结构。它提供了许多常用的布局元素，例如应用栏（AppBar）、抽屉（Drawer）、底部导航栏（BottomNavigationBar）等。主要功能包括：

- 应用栏（AppBar）：一个顶部应用栏，通常用于显示标题、导航控件和其他操作。
- 抽屉（Drawer）：一个侧边栏菜单，通常用于显示导航链接。
- 浮动操作按钮（FloatingActionButton）：一个浮动的圆形按钮，通常用于触发主要操作。
- 底部导航栏（BottomNavigationBar）：一个底部导航栏，通常用于切换不同的页面或视图。
- SnackBar 和 BottomSheet：提供了展示短暂消息和底部弹出层的功能。


```
class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Home Page'),
      ),
      drawer: Drawer(
        child: ListView(
          children: <Widget>[
            DrawerHeader(
              child: Text('Drawer Header'),
              decoration: BoxDecoration(
                color: Colors.blue,
              ),
            ),
            ListTile(
              title: Text('Item 1'),
              onTap: () {
                // Update the state of the app
                // ...
              },
            ),
            ListTile(
              title: Text('Item 2'),
              onTap: () {
                // Update the state of the app
                // ...
              },
            ),
          ],
        ),
      ),
      body: Center(
        child: Text('Welcome to My Home Page!'),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // Add your onPressed code here!
        },
        child: Icon(Icons.add),
      ),
    );
  }
}

```


Scaffold 是一个页面级组件，提供了Material Design的基础布局结构，如应用栏、抽屉、底部导航栏和浮动操作按钮等。

<br/><br/><br/>
> <h2 id='导航返回拦截（WillPopScope）'>导航返回拦截（WillPopScope）</h2>


为了避免用户误触返回按钮而导致 App 退出，在很多 App 中都拦截了用户点击返回键的按钮，然后进行一些防误触判断，比如当用户在某一个时间段内点击两次时，才会认为用户是要退出（而非误触）。

Flutter中可以通过WillPopScope来实现返回按钮拦截;

<br/>

**main.文件**

```
void _pushToWillPopScopeTestPage() {
    Navigator.push(context,
        MaterialPageRoute(builder: (context) => WillPopScopeTestPage()));
  }
```

<br/>

**WillPopScopeTestPage.**

```
import 'package:flutter/material.';

class WillPopScopeTestPage extends StatefulWidget {
  @override
  _WillPopScopeTestPageState createState() => _WillPopScopeTestPageState();
}

class _WillPopScopeTestPageState extends State<WillPopScopeTestPage> {
  DateTime? _lastPressedAt; //上次点击时间

  Future<bool> _solveQuickClick() async {
    if (_lastPressedAt == null ||
        DateTime.now().difference(_lastPressedAt!) > Duration(seconds: 1)) {
      //两次点击间隔超过1秒则重新计时
      _lastPressedAt = DateTime.now();
      return false;
    }
    return true;
  }


  @override
  Widget build(BuildContext context) {
    return WillPopScope(
      child: Scaffold(
        appBar: AppBar(title: Text('My Page')),
        body: Center(
          child: Text('This is my page content.'),
        ),
      ),
      onWillPop: _solveQuickClick,
    );
  }
}

```

效果如下:

![flutter1_0.0.png](./../Pictures/flutter1_0.0.png)



<br/><br/><br/>
> <h2 id='Widget管理自身状态'>Widget管理自身状态</h2>

```dart
import 'package:flutter/cupertino.';
import 'package:flutter/material.';

///TapboxA 类
class TapboxA extends StatefulWidget {
  TapboxA({Key key}) : super(key: key);

  @override
  _TapboxAState createState() => new _TapboxAState();
  
}

class _TapboxAState extends State<TapboxA> {

  bool _active = false;
  void _handleTap() {
    setState(() {
      _active = !_active;
    });
  }

  @override
  Widget build(BuildContext context) {

    return new GestureDetector(
      onTap: _handleTap,
      child: new Container(
        child: new Center(
          child: new Text(
            _active ? 'Active' : 'No Active',
            style: new TextStyle(fontSize: 32.0, color: Colors.white),
          ),
        ),
        width: 200.0,
        height: 200.0,
        decoration: new BoxDecoration(
          color:_active ? Colors.lightGreen[700] : Colors.grey[600],
        ),
      ),
    );
  }
  
}
```

<br/>

**调用**

```dart
void main() {
  runApp(MyApp());
  // runApp(Text("hellosjglajgl"));
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home:Scaffold(
        appBar: AppBar(
          title: Text('Hello Flutter'),
        ),
        body: TapboxA(),
      )
    );
  }
  
}
```

效果图：

![flutter1_54.png](./../Pictures/flutter1_54.png)

点击灰色色块，进行变色。

<br/><br/>
> <h2 id='父Widget管理子Widget的状态'>父Widget管理子Widget的状态</h2>

```dart
///------------------------- ParentWidgetState 类 ----------------------------------
///父组件
class ParentWidgetState extends StatefulWidget {
  @override
  _ParentWidgetState createState()  => new _ParentWidgetState();
  
}

class _ParentWidgetState extends State<ParentWidgetState> {

  bool _active = false;

  ///回掉函数
  void _handleTapboxChaned(bool newValue){
    setState(() {
      //修改状态
      _active = newValue;
    });
  }

  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return new Container(
      child: new TapboxB (
        active: _active,
        //将_handleTapboxChaned函数赋值给TapboxB的onChanged
        onChanged: _handleTapboxChaned,
      ),
    );
  }
  
}

///------------------------- TapboxB ----------------------------------
///子组件
class TapboxB extends StatelessWidget {

  final bool active;
  ///定义接收父类回调函数的指针
  final ValueChanged<bool> onChanged;

  TapboxB({Key key, this.active: false, @required this.onChanged}) : super(key: key);

  void _handleTap() {
    onChanged(!active);
  }



  @override
  Widget build(BuildContext context) {

    return new GestureDetector(
      //调用回调函数传值
      onTap: _handleTap,
      child: new Container(
        child: new Center(
          child: new Text(
            active ? "Active【激活】" : "No Active【没激活】",
            style: new TextStyle(
              fontSize: 18.0,
              color: Colors.white,
            ),
          ),
        ),
        width: 200,
        height: 200,
        decoration: new BoxDecoration(
          color: active ? Colors.lightGreen[700] : Colors.grey[600],
        ),
      ),
    );
  }
  
}

```

<br/>

**调用**

```dart
void main() {
  runApp(MyApp());
  // runApp(Text("hellosjglajgl"));
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home:Scaffold(
        appBar: AppBar(
          title: Text('Hello Flutter'),
        ),
        body: ParentWidgetState(),
      )
    );
  }
  
}
```

效果图：

![flutter1_55.png](./../Pictures/flutter1_55.png)

<br/><br/><br/>
> <h2 id='跨组件状态共享'>跨组件状态共享</h2>


```dart
import ':collection';
import ':typed_data';

import 'package:flutter/cupertino.';
import 'package:flutter/material.';

// 一个通用的InheritedWidget，保存任需要跨组件共享的状态
class InheritedProvider<T> extends InheritedWidget {
  //共享状态使用泛型
  final T data;  


  InheritedProvider({@required this.data, Widget child}) : super(child: child);
  
  @override
  //在此简单返回true，则每次更新都会调用其依赖的子孙节点didChangeDependencies
  bool updateShouldNotify(InheritedProvider<T> oldWidget) {
    return true;
  }
  
}



Type _typeOf<T>() => T;
class ChangeNotifierProvider<T extends ChangeNotifier> extends StatefulWidget {
  final Widget child;
  final T data;
    

  ChangeNotifierProvider({
    Key key,
    this.data,
    this.child,
  });

  //定义一个便捷方法，方便子树中的widget获取共享数据
  static T of<T> (BuildContext context) {
    final type = _typeOf<InheritedProvider<T>>();
    //final provider = context.inheritFromWidgetOfExactType(type) as InheritedProvider<T>;
    //final provider = context.dependOnInheritedWidgetOfExactType(aspect: type) as InheritedProvider<T>;
    final provider = context.dependOnInheritedWidgetOfExactType<InheritedProvider<T>>();
    print("商品的Model是：${(provider.data as CartModel).totalPrice}");
    return provider.data;
  }

  @override
  _ChangeNotifierProviderState<T> createState() {
    return _ChangeNotifierProviderState<T>();
  }
  
}

/*
* _ChangeNotifierProviderState 主要作用就是监听到共享状态（model）改变时重新构建Widget树
* 
*/
class _ChangeNotifierProviderState<T extends ChangeNotifier> extends State<ChangeNotifierProvider<T>> {
  
  ///如果数据发生变化（model类调用了notifyListeners），重新构建InheritedProvider
  //void update() => setState(() => {});
  void update() {
    //build方法会被执行
    setState(() => {});
  }
  

  @override
  void didUpdateWidget(ChangeNotifierProvider<T> oldWidget) {
    // 当Provider更新时，如果新旧数据不"=="，则解绑旧数据监听，同时添加新数据监听
    if (widget.data != oldWidget.data) {
      oldWidget.data.removeListener(update);
      widget.data.addListener(update);
    }
    super.didUpdateWidget(oldWidget);
  }

  @override
  void initState() {
    // 给model添加监听器
    widget.data.addListener(update);
    super.initState();
  }

  @override
  void dispose() {
    // 移除model的监听器
    widget.data.removeListener(update);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return InheritedProvider<T>(
      data: widget.data,
      child: widget.child,
    );
  }
  
}


/*
* 定义一个Item类，用于表示商品信息 
*
*/
class Item {
  //商品单价
  double price;
  // 商品份数
  int count;

  Item(this.price, this.count);
}


/*
* 定义一个保存购物车内商品数据的CartModel类
* CartModel即要跨组件共享的model类
*/
class CartModel extends ChangeNotifier {
  //用于保存购物车中商品列表
  final List<Item> _items = [];
  ///禁止改变购物车里的商品信息
  UnmodifiableListView<Item> get items => UnmodifiableListView(_items);
  ///购物车中商品的总价
  double get totalPrice => _items.fold(0, (value, item) => value + item.count * item.price);


  //将 [item] 添加到购物车。这是唯一一种能从外部改变购物车的方法
  void add(Item item) {
    _items.add(item);
    //通知监听器（订阅者），重新构建InheritedProvider， 更新状态
    notifyListeners();
  }
}

/*
* 构建示例页面类：ProviderRoute
*
*/
class ProviderRoute extends StatefulWidget {
  @override
  _ProviderRouteState createState() => _ProviderRouteState();
  
}

class _ProviderRouteState extends State<ProviderRoute> {
  
  
  @override
  Widget build(BuildContext context) {

    return Center(
      child:ChangeNotifierProvider<CartModel>(
        data: CartModel(),
        child: Builder(builder: (context) {
          return Column(
            children:<Widget>[
              Text(""),
              Text(""),
              Text(""),
              Text(""),
              Builder(builder: (context) {
                var cart = ChangeNotifierProvider.of<CartModel>(context);
                return Text("总价: ${cart.totalPrice}");
              }),
              Builder(builder: (context) {
                //在后面优化部分会用到
                print("RaisedButton build");
                return RaisedButton(
                  child: Text("添加商品"),
                  onPressed: (){
                    ChangeNotifierProvider.of<CartModel>(context).add(Item(20.0, 1));
                  },
                );
              }),
            ],
          );
        }),
      ),
    );
  }
  
}
```

效果图：

![flutter1_56.png](./../Pictures/flutter1_56.png)

<br/><br/>
># <h2 id='InheritedWidget'>[InheritedWidget](https://juejin.cn/post/7063286816492748836)</h2>
<br/>

**介绍:**

&emsp; InheritedWidget是 Flutter 中非常重要的一个功能型组件，它提供了一种在 widget 树中从上到下共享数据的方式，比如我们在应用的根 widget 中通过InheritedWidget共享了一个数据，那么我们便可以在任意子widget 中来获取该共享的数据！这个特性在一些需要在整个 widget 树中共享数据的场景中非常方便！如Flutter SDK中正是通过 InheritedWidget 来共享**应用主题（Theme）** 和 **Locale (当前语言环境)** 信息的。

> InheritedWidget和 React 中的 context 功能类似，和逐级传递数据相比，它们能实现组件跨级传递数据。InheritedWidget的在 widget 树中数据传递方向是**从上到下的**，这和通知Notification（将在下一章中介绍）的**传递方向正好相反**。


<br/>


- **InheritedWidget共享自增数据**
	- InheritedWidget 允许在 widget 树中有效地向下传播（和共享）信息。
	
	- InheritedWidget 是一个特殊的 Widget，它将作为另一个子树的父节点放置在 Widget 树中。该子树的所有 widget 都必须能够与该 InheritedWidget 暴露的数据进行交互。


<br/>
&emsp; 开发做多了，完全跟`iOS的设计模式单例`差不多在存储数据方面。但是在`单例上`又加了`通知`和`全局刷新整个app组件`，相当简单暴力。

好了，先看第一个代码Demo：

**ShareDataWidget组件**

```dart
import 'package:flutter/cupertino.';
import 'package:flutter/material.';

class ShareDataWidget extends InheritedWidget {

  ///需要在子树中共享的数据，保存点击次数
  final int data;

  ShareDataWidget({
    @required this.data,
    Widget child
  }) : super(child: child);

  /// 定义一个便捷方法，方便子树中的widget获取共享数据 
  /// 允许所有子 widget 通过包含的 context 获得最近的 MyInheritedWidget 实例（
  static ShareDataWidget of(BuildContext context) {
    
    //return context.inheritFromWidgetOfExactType(ShareDataWidget);// 废弃了
    
    return context.dependOnInheritedWidgetOfExactType(aspect: ShareDataWidget);
  }

  //重写 updateShouldNotify 方法用来告诉 InheritedWidget 如果对数据进行了修改，是否必须将通知传递给所有子 widget
  //该回调决定当data发生变化时，是否通知子树中依赖data的Widget重新build
  @override
  bool updateShouldNotify(ShareDataWidget oldWidget) {
    // TODO: implement updateShouldNotify
    // 如果返回true，则子树中依赖(build函数中有调用)本widget
    // 的子widget的`state.didChangeDependencies`会被调用
    return oldWidget.data != data;
  }
  
}
```


<br/><br/>

**_TestWidget组件**


 &emsp; 实现一个子组件_TestWidget，在其build方法中引用ShareDataWidget中的数据。
 
 &emsp; 同时，在其didChangeDependencies() 回调中打印日志

```dart
class  _TestWidget extends StatefulWidget {
  @override
  _TestWidgetState createState() => new _TestWidgetState();
  
}

class  _TestWidgetState extends State<_TestWidget> {
  
  @override
  Widget build(BuildContext context) {
    print("共享数据： ${ShareDataWidget.of(context).data.toString()}");
    
    //使用InheritedWidget中的共享数据，也就产生了依赖
    return Text(
      "依赖产生：" + ShareDataWidget.of(context)
                      .data
                      .toString()
                      
    );
  }


@override
  void didChangeDependencies() {
    // TODO: implement didChangeDependencies
    super.didChangeDependencies();
    
    //父或祖先widget中的InheritedWidget改变(updateShouldNotify返回true)时会被调用。
    //如果build中没有依赖InheritedWidget，则此回调不会被调用。
    print("Dependencies change【依赖发生了改变】");
  }
  
}
```


<br/><br/>
&emsp; 在之前介绍StatefulWidget时，我们提到State对象有一个didChangeDependencies回调，它会在“依赖”发生变化时被Flutter 框架调用。而这个“依赖”指的就是子 widget 是否使用了父 widget 中InheritedWidget的数据！

&emsp; 如果使用了，则代表子 widget 有依赖；如果没有使用则代表没有依赖。这种机制可以使子组件在所依赖的InheritedWidget变化时来更新自身！比如当主题、locale(语言)等发生变化时，依赖其的子 widget 的didChangeDependencies方法将会被调用。

&emsp; 最后，我们创建一个按钮，每点击一次，就将ShareDataWidget的值自增.

<br/>

&emsp; 但是读者要注意，如果_TestWidget的build方法中没有使用ShareDataWidget的数据，那么它的didChangeDependencies()将不会被调用，因为**它并没有依赖ShareDataWidget**(也就是变相地说,依赖还是没有依赖取决于有没有使用ShareDataWidget中的data数据)。


<br/><br/>
**InheritedWidgetTestRoute组件**

```dart
class  InheritedWidgetTestRoute extends StatefulWidget {

  @override
  _InheritedWidgetTestRouteState createState() => new _InheritedWidgetTestRouteState();
  
}

class  _InheritedWidgetTestRouteState extends State<InheritedWidgetTestRoute> {

  int count = 0;

  @override
  Widget build(BuildContext context) {

    return Center(
      //为了能够传播/共享某些数据，需要将 InheritedWidget子类ShareDataWidget放置在 widget 树的顶部
      //这解释了传递给 InheritedWidget 基础构造函数的 @required Widget child 参数
      child: ShareDataWidget(
        data: count,//这个改变
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children:<Widget>[
            Padding(padding: const EdgeInsets.only(bottom: 20.0),
            child: _TestWidget(),// 子widget中依赖ShareDataWidget
            ),
            RaisedButton(
              ////每点击一次，将count自增，然后重新build,ShareDataWidget的data将被更新
              onPressed: () => setState(() => ++count),
              child: Text("Increment"),
              )
          ]
        ),
        ),
    );
  }
}

```

<br/>

**调用**

```dart
void main() {
  runApp(MyApp());
  // runApp(Text("hellosjglajgl"));
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home:Scaffold(
        appBar: AppBar(
          title: Text('Hello Flutter'),
        ),
        body: InheritedWidgetTestRoute(),
      )
    );
  }
  
}
```

运行效果：

![flutter1_58.png](./../Pictures/flutter1_58.png)

&emsp;  感觉这个可以做app的用户信息展示，感觉很棒。

&emsp;  一般来说，子widget很少会重写`didChangeDependencies()`方法，因为在依赖改变后framework也都会调用build()方法。但是，如果你需要在依赖改变后执行一些昂贵的操作，比如网络请求，这时最好的方式就是在`didChangeDependencies()`方法中执行，这样可以避免每次build()都执行这些昂贵操作。


如果层级嵌套的widget想共享同一份数据的话，便可通过调用ShareDataWidget.of(context).data 来实现获取共享数据，不用一层一层的传递数据了。

<br/><br/><br/>
> <h3 id='dependOnInheritedWidgetOfExactType方法'>dependOnInheritedWidgetOfExactType方法</h3>

&emsp; inheritFromWidgetOfExactType方法已经不再使用了，取而代之的是dependOnInheritedWidgetOfExactType。

- **dependOnInheritedWidgetOfExactType:**
	- 获取最近给定类型的Widget，该widget必须是InheritedWidget的子类(比如上文的ShareDataWidget类)，并向该widget注册传入的context;
	- 当该widget改变时，这个context会重新构建以便从该widget获得新的值;
	- 这就是child向InheritedWidget注册的方法。


<br/><br/>
> <h3 id='findAncestorWidgetOfExactType方法'>findAncestorWidgetOfExactType方法</h3>
- **findAncestorWidgetOfExactType:**
	- 功能与dependOnInheritedWidgetOfExactType一样，但是只会寻找InheritedWidget的子类，可以以O(1)的复杂度查找上级Widget;



<br/><br/><br/>
>### <h3 id='区别'>[区别](https://blog.csdn.net/hjjdehao/article/details/114985547)</h3>

当调用`findAncestorWidgetOfExactType`这个方法的时候，相应的子widget不会调用didChangeDependencies这个方法。为什么会这样呢？

&emsp; 原因在于dependOnInheritedWidgetOfExactType这个方法里面注册了InheritedWidget和其子widget注册了依赖关系。而findAncestorWidgetOfExactType没有。想看具体的话可以点进这两个方法的源码看看就知道了。


<br/><br/><br/>
> <h3 id='widget之间的交互'>widget之间的交互</h3>

![flutter1_67.png](./../Pictures/flutter1_67.png)

为了说明交互方式，我们做以下假设：

‘Widget A’ 是一个将项目添加到购物车里的按钮；
‘Widget B’ 是一个显示购物车中商品数量的文本；
‘Widget C’ 位于 Widget B 旁边，是一个内置任意文本的文本；
我们希望 ‘Widget A’ 在按下时 ‘Widget B’ 能够自动在购物车中显示正确数量的项目，但我们不希望重建 ‘Widget C’

针对该场景，InheritedWidget 是唯一一个合适的 Widget 选项！


**代码**

```dart
class Item {
   String reference;

   Item(this.reference);
}

class _MyInherited extends InheritedWidget {
  _MyInherited({
    Key key,
    @required Widget child,
    @required this.data,
  }) : super(key: key, child: child);

  final MyInheritedWidgetState data;

  @override
  bool updateShouldNotify(_MyInherited oldWidget) {
    return true;
  }
}

class MyInheritedWidget extends StatefulWidget {
  MyInheritedWidget({
    Key key,
    this.child,
  }): super(key: key);

  final Widget childWidget;

  @override
  MyInheritedWidgetState createState() => new MyInheritedWidgetState();

  static MyInheritedWidgetState of(BuildContext context){
    return (context.inheritFromWidgetOfExactType(_MyInherited) as _MyInherited).data;
  }
}

class MyInheritedWidgetState extends State<MyInheritedWidget>{
  /// List of Items
  List<Item> _items = <Item>[];

  /// Getter (number of items)
  int get itemsCount => _items.length;

  /// Helper method to add an Item
  void addItem(String reference){
    setState((){
      _items.add(new Item(reference));
    });
  }

  @override
  Widget build(BuildContext context){
    return new _MyInherited(
      data: this,
      child: widget.childWidget,
    );
  }
}

class MyTree extends StatefulWidget {
  @override
  _MyTreeState createState() => new _MyTreeState();
}

class _MyTreeState extends State<MyTree> {
  @override
  Widget build(BuildContext context) {
    return new MyInheritedWidget(
      child: new Scaffold(
        appBar: new AppBar(
          title: new Text('Title'),
        ),
        body: new Column(
          children: <Widget>[
            new WidgetA(),
            new Container(
              child: new Row(
                children: <Widget>[
                  new Icon(Icons.shopping_cart),
                  new WidgetB(),
                  new WidgetC(),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class WidgetA extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final MyInheritedWidgetState state = MyInheritedWidget.of(context);
    return new Container(
      child: new RaisedButton(
        child: new Text('Add Item'),
        onPressed: () {
          state.addItem('new item');
        },
      ),
    );
  }
}

class WidgetB extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final MyInheritedWidgetState state = MyInheritedWidget.of(context);
    return new Text('${state.itemsCount}');
  }
}

class WidgetC extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return new Text('I am Widget C');
  }
}
```

![flutter0.0.3.png](./../Pictures/flutter0.0.3.png)

**说明**

- 在这个非常基本的例子中：

	- _MyInherited 是一个 **InheritedWidget**，每次我们通过 **‘Widget A’** 按钮添加一个项目时它都会重新创建
	
	- **MyInheritedWidget** 是一个 State 包含了项目列表的 Widget。可以通过 **static MyInheritedWidgetState of(BuildContext context)** 访问该 `State`
	
	- `MyInheritedWidgetState` 暴露了一个获取 `itemsCount` 的 `getter` 方法 和一个 `addItem` 方法，以便它们可以被 widget 使用，这是子 widget 树的一部分
	
	- 每次我们将项目添加到 State 时，`MyInheritedWidgetState` 都会重建
	
	- MyTree 类仅构建了一个 widget 树，并将 `MyInheritedWidget` 作为树的根节点
	
	- WidgetA 是一个简单的 `RaisedButton`，当按下它时，它将从最近的 `MyInheritedWidget` 实例中调用 addItem 方法
	
	- `WidgetB` 是一个简单的 `Text`，用来显示最近 级别 `MyInheritedWidget` 的项目数


<br/><br/>


**这一切是如何运作的呢？**

**为后续的通知注册 Widget**

&emsp; 当一个子 Widget 调用 MyInheritedWidget.of(context) 时，它传递自身的 context 并调用 MyInheritedWidget 的以下方法。

```dart
static MyInheritedWidgetState of(BuildContext context) {
    return (context.inheritFromWidgetOfExactType(_MyInherited) as _MyInherited).data;
}
```

&emsp; 在内部，除了简单地返回 MyInheritedWidgetState 实例外，它还订阅消费者 widget 以便用于通知更改。

<br/>

&emsp; 在幕后，对这个静态方法的简单调用实际上做了 2 件事：

- 消费者 widget 被自动添加到订阅者列表中，从而当对 InheritedWidget（这里是 _MyInherited）应用修改时，该 widget 能够重建
- _MyInherited widget（又名 MyInheritedWidgetState）中引用的数据将返回给消费者

<br/><br/>

**流程**
由于 ‘Widget A’ 和 ‘Widget B’ 都使用 InheritedWidget 进行了订阅，因此如果对 _MyInherited 应用了修改，那么当点击 Widget A 的 RaisedButton 时，操作流程如下（简化版本）：

- 调用 MyInheritedWidgetState 的 addItem 方法

- _MyInheritedWidgetState.addItem 方法将新项目添加到列表中

- 调用 setState() 以重建 MyInheritedWidget

- 通过列表中的新内容创建 _MyInherited 新的实例

- _MyInherited 记录通过参数（data）传递的新 State

- 作为 InheritedWidget，它会检查是否需要通知消费者（答案是 true）

- 遍历整个消费者列表（这里是 Widget A 和 Widget B）并请求它们重建

- 由于 Wiget C 不是消费者，因此不会重建。

至此它能够有效工作！

<br/>

然而，Widget A 和 Widget B 都被重建了，但由于 Wiget A 没有任何改变，因此它没有重建的必要。那么应该如何防止此种情况发生呢？

在继续访问 Inherited Widget 的同时阻止某些 Widget 重建
Widget A 同时被重建的原因是由于它访问 MyInheritedWidgetState 的方式。

如前所述，调用 context.inheritFromWidgetOfExactType() 方法实际上会自动将 Widget 订阅到消费者列表中。

避免自动订阅，同时仍然允许 Widget A 访问 MyInheritedWidgetState 的解决方案是通过以下方式改造 MyInheritedWidget 的静态方法：

```
static MyInheritedWidgetState of([BuildContext context, bool rebuild = true]){
    return (rebuild ? context.inheritFromWidgetOfExactType(_MyInherited) as _MyInherited
                    : context.ancestorWidgetOfExactType(_MyInherited) as _MyInherited).data;
}
```

通过添加一个 boolean 类型的额外参数……

如果 rebuild 参数为 true（默认值），我们使用普通方法（并且将 Widget 添加到订阅者列表中）

如果 rebuild 参数为 false，我们仍然可以访问数据，但不使用 InheritedWidget 的内部实现

因此，要完成此方案，我们还需要稍微修改一下 Widget A 的代码，如下所示（我们添加值为 false 的额外参数）：

```dart
class WidgetA extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final MyInheritedWidgetState state = MyInheritedWidget.of(context, false);
    return new Container(
      child: new RaisedButton(
        child: new Text('Add Item'),
        onPressed: () {
          state.addItem('new item');
        },
      ),
    );
  }
}
```

就是这样，当我们按下 Widget A 时，它不会再重建了。

<br/><br/>

若是上面的代码看的不太懂，可以看下面的：

可以使用 `InheritedWidget` 来管理购物车的状态，并通过 `setState` 仅更新 `Widget B` 而不影响 `Widget C`。以下是优化后的代码实现：

**1.创建 `CartProvider`（继承 `InheritedWidget`）**

```dart
import 'package:flutter/material.dart';

class CartProvider extends InheritedWidget {
  final int itemCount;
  final VoidCallback increment;

  const CartProvider({
    Key? key,
    required Widget child,
    required this.itemCount,
    required this.increment,
  }) : super(key: key, child: child);

  static CartProvider? of(BuildContext context) {
    return context.dependOnInheritedWidgetOfExactType<CartProvider>();
  }

  @override
  bool updateShouldNotify(CartProvider oldWidget) {
    return oldWidget.itemCount != itemCount;
  }
}
```

<br/>

**2.创建 `CartState`（状态管理组件）**

```dart
class CartState extends StatefulWidget {
  final Widget child;

  const CartState({Key? key, required this.child}) : super(key: key);

  @override
  _CartStateState createState() => _CartStateState();

  static _CartStateState? of(BuildContext context) {
    final provider = context.dependOnInheritedWidgetOfExactType<CartProvider>();
    return provider?.child is CartState ? (provider!.child as CartState)._state : null;
  }
}

class _CartStateState extends State<CartState> {
  int _itemCount = 0;

  void _increment() {
    setState(() {
      _itemCount++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return CartProvider(
      itemCount: _itemCount,
      increment: _increment,
      child: widget.child,
    );
  }
}
```

<br/>

**3.组件 `Widget A`（添加到购物车按钮）**

```dart
class WidgetA extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final cartState = CartState.of(context);
    return ElevatedButton(
      onPressed: cartState?. _increment,
      child: Text("添加到购物车"),
    );
  }
}
```

<br/>

**4.组件 `Widget B`（显示购物车数量）**

```dart
class WidgetB extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final cartProvider = CartProvider.of(context);
    return Text(
      "购物车数量: ${cartProvider?.itemCount ?? 0}",
      style: TextStyle(fontSize: 20),
    );
  }
}
```

<br/>

**5.组件 `Widget C`（不会重建的文本）**

```dart
class WidgetC extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    debugPrint("Widget C 重建了");
    return Text("我是 Widget C", style: TextStyle(fontSize: 20, color: Colors.blue));
  }
}
```

<br/>

**6.组装主页面**

```dart
void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: Text("购物车示例")),
        body: CartState(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              WidgetA(),
              SizedBox(height: 20),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  WidgetB(),
                  SizedBox(width: 20),
                  WidgetC(),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

**优化点:**
1. **通过 InheritedWidget 传递购物车数据**：`CartProvider` 仅在 `itemCount` 变化时更新 `Widget B`，不会影响 `Widget C`。
2. **避免不必要的重建**：`Widget C` 没有订阅 `CartProvider`，因此不会因 `itemCount` 变化而重新构建。
3. **使用 `setState` 只更新 `CartProvider`**：`CartState` 仅管理 `itemCount`，并提供 `increment()` 方法供 `Widget A` 使用。




<br/><br/><br/>

***
<br/>
># <h1 id='Provider'>[Provider](https://juejin.cn/post/7067356022272163847)</h1>
[Flutter Provider状态管理---介绍、类图分析、基本使用](https://www.liujunmin.com/flutter/provider/introduction.html)
**[Provider](https://book.flutterchina.club/chapter7/provider.html#_7-3-1-通过事件同步状态)是Flutter官方出的状态管理包**

![z21](./../Pictures/z21.png)

&emsp; Flutter 实际上在一开始就为我们提供了一种状态管理方式，那就是 StatefulWidget。但是我们很快发现，它正是造成上述原因的罪魁祸首。

&emsp; 在 State 属于某一个特定的 Widget，在多个 Widget 之间进行交流的时候，虽然你可以使用 callback 解决，但是当嵌套足够深的话，我们会增加非常多的垃圾代码。

<br/>
&emsp; 这时候，我们便迫切的需要一个架构来帮助我们理清这些关系，状态管理框架应运而生。

下载[Provider](https://pub.flutter-io.cn/packages/provider/install)插件.

```dart
dependencies:
  provider: ^4.3.2+2
```

<br/>
Flutter中的Provider库实际上是对InheritedWidget的一种封装和扩展，它利用了InheritedWidget的特性来进行高效的状态管理和数据共享。

<br/>

**InheritedWidget与Provider的联系：**

- InheritedWidget是Flutter框架内置的一个机制，允许将数据和逻辑在整个Widget树中向下传递，而无需逐级手动传递。当InheritedWidget内部的数据发生变更时，所有依赖它的子Widget都能够感知到变化并自动重建（调用build方法）。
- Provider库构建在其之上，提供了一系列易于使用的Provider类，如**ChangeNotifierProvider**、**ValueListenableProvider**等，它们都是InheritedWidget的子类或者间接实现了InheritedWidget的工作机制。
- 使用Provider时，开发者无需直接处理InheritedWidget复杂的更新逻辑和依赖追踪，而是通过创建数据模型（通常是继承自ChangeNotifier的类），并在Widget树中放置一个Provider来包裹这些模型实例。当模型的数据发生变化时，Provider会自动通知依赖它的Widget进行更新。

<br/>

**Provider源码：**

```dart
Provider({
  Key? key,
  required Create<T> create,
  Dispose<T>? dispose,
  bool? lazy,
  TransitionBuilder? builder,
  Widget? child,
})...
```

<br/>

**简单Demo：**

**Model：**

```dart
class Person{
  String name = "Provider";
}
```

<br/>

**程序入口设置:**

```dart
return Provider<Person>(
  create: (ctx)=> Person(),
  child: const MaterialApp(
    home: ProviderDemo(),
  ),
);
```

<br/>

**View:**

```dart
class ProviderDemo extends StatelessWidget {
  const ProviderDemo({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Consumer<Person>( /// 在程序任何地方都可以拿到person对象，读取数据
            builder: (_,person,child){
              return Text(person.name);
            }
        ),
      ),
    );
  }
}
```

除了使用`create` 来创建新的对象模型时，也可以使用一个已经存在的对象实例。这里是模型不是狭义上的model，也可以是viewModel、工具类等。
如：

```dart
Provider.value(
  value: value, /// value是已经存在的模型对象
  child: ...
)
```

或

```dart
ChangeNotifierProvider.value(
  value: value, /// value是已经存在的模型对象
  child: ...
)
```

**注：使用 .value 是将已经存在的对象实例暴露出来，如果是新的模型对象，务必使用  create 。**

在使用provider 的 `create` 和 `update` 回调时，**回调函数默认是延迟调用的**。也就是说，变量被读取时，create 和 update 函数才会被调用。开发者也可以使用 lazy 参数来禁用这一行为：

```dart
Provider(
  create: (_) => Something(),
  lazy: false,
)
```

我们还注意到有个 dispose 的回调 ：

```dart
typedef Dispose<T> = void Function(BuildContext context, T value);
```
当 Provider 所在节点被移除的时候，它就会启动 Disposer<T>，然后我们便可以在这里释放对应的资源。

<br/><br/>

**总结：**
| **方式** | **适用场景** |
|---------|-----------|
| `ChangeNotifier` | 可通知 UI 更新的状态类 |
| `ChangeNotifierProvider` | 创建并提供 `ChangeNotifier`，适用于管理**全局或局部状态** |
| `Consumer<T>` | 订阅状态并更新 UI （**局部刷新 UI，优化性能** ）|
| `Provider.of<T>(context, listen: false)` | 获取 Provider 提供的状态（**仅获取数据，不触发重建** ）|
| `MultiProvider` | 提供**多个状态** |
| `FutureProvider` | **异步加载数据（API/数据库）** |
| `StreamProvider` | **监听数据流（WebSocket/数据库）** |

<br/>

**推荐用法：**
- UI 依赖状态时，使用 `Consumer<T>`，避免 `Provider.of<T>(context)`
- 只在 `onPressed` 里修改数据时，使用 `Provider.of<T>(context, listen: false)`


<br/><br/><br/>
> <h2 id="提供者">提供者</h2>
<br/>

> <h2 id='ChangeNotifier使用'>ChangeNotifier使用</h2>

监听模型对象的变化，而且当数据改变时，它也会重建Consumer，更新UI。

- 继承、混入ChangeNotifier
- 调用了notifyListeners()

它不会重复实例化模型，除非在个别场景下。如果该实例已经不会再被调用，ChangeNotifierProvider 也会自动调用模型的dispose()方法。

- ChangeNotifier

它类似于一个Observable，继承自Listenable，内部维护了一个
ObserverList  _listeners，提供添加和删除listener的方法，有一个notify方法，用来通知所有的观察者（在Provider或者称为消费者Consumer）。

<br/>
使用ChangeNotifierProvider管理简单计数器状态的例子：

**Model：**

```dart
import 'package:flutter/foundation.';

class CounterModel extends ChangeNotifier {
  int _count = 0;

  int get count => _count;

  void increment() {
    _count++;
    notifyListeners(); // 数据变化时触发通知
  }
}
```

<br/>
然后，在应用程序的合适位置（例如MaterialApp的子项）设置Provider：

```dart
import 'package:flutter/material.';
import 'package:provider/provider.';

void main() {
  runApp(
    MaterialApp(
      home: ChangeNotifierProvider<CounterModel>(
        create: (ctx) => CounterModel(), // 创建CounterModel实例
        child: HomePage(),
      ),
    ),
  );
}

class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
	          // Consumer 组件可以监听 ChangeNotifier，当数据变化时，仅重新构建 Consumer 里面的部分，而不是整个 build 方法。
            Consumer<CounterModel>( // 使用Consumer来消费提供的数据
              builder: (context, counter, child) {
                return Text('Count: ${counter.count}');
              },
            ),
            RaisedButton(
              onPressed: () {
                Provider.of<CounterModel>(context, listen: false).increment(); // 不监听的情况下更新计数器
              },
              child: Text('Increment'),
            ),
            
            // 拿到CounterModel对象，调用方法
            Consumer<CounterModel>(builder:(ctx, model, child){
	            return ElevatedButton(
		            onPresed:()=>
	            )
            })
          ],
        ),
      ),
    );
  }
}
```
**在这个例子中：**

- 我们创建了一个名为CounterModel的状态模型，它继承自ChangeNotifier并管理一个计数器的值。
- 在应用程序的根Widget层级，我们使用ChangeNotifierProvider包装HomePage，这样整个HomePage及其子Widget都可以访问到CounterModel实例。
- 在HomePage中，我们使用Consumer Widget来订阅CounterModel的变化，并在文本显示当前计数值。
- 当用户点击按钮时，我们通过Provider.of获取到上下文中的CounterModel实例并调用increment方法增加计数，由于ChangeNotifier会触发通知，所以依赖它的Consumer会自动重新构建，从而更新UI显示最新的计数。

<br/><br/>
><h3  id="`FutureProvider`（异步加载数据）">`FutureProvider`（异步加载数据）</h3>
`FutureProvider`有一个初始值，接收一个 `Future`，并在其进入 `complete` 状态时更新依赖它的组件。

- `FutureProvider`只会重建一次
- 默认显示初始值，Future进入 `complete` 状态时，会更新UI
- `FutureProvider`只会重建一次

适用于从网络或数据库加载数据：

**Model:**

```dart
class Person {
  String? name;
  Person({required this.name});
}
```

<br/>

**入口位置：**

```dart
return FutureProvider<Person>(
  initialData: Person(name: "初始值"),
  create: (ctx){
    /// 延迟2s后更新(相当于网络请求数据)
    return Future.delayed(const Duration(seconds:2), () => Person(name: "更新FutureProvider"));
  },
  child: const MaterialApp(
    home: FutureProviderDemo(),
  ),
);
```

<br/>

**View:**

```dart
class FutureProviderDemo extends StatelessWidget {
  const FutureProviderDemo({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("FutureProvider"),),
      body: Center(
        child:Consumer<Person>(builder: (ctx,person,child) =>Text(person.name!),),,
      ),
    );
  }
}
```

<br/><br/>
><h3  id="`StreamProvider`（监听数据流）">`StreamProvider`（监听数据流）</h3>
监听流，并暴露出当前的最新值，并多次触发重新构建UI。

适用于 WebSocket、数据库监听：

**Model：**

```dart
class Person {
  String? name;
  Person({required this.name});
}
```
<br/>

**入口：**

```dart
return StreamProvider<Person>(
  initialData: Person(name: "初始值"),
  create: (ctx) {
    /// 传入一个Stream，每间隔1s数据更新一次(相当于socket数据返回)
    return Stream<Person>.periodic(const Duration(seconds: 1),(value){
      return Person(name: "StreamProvider ---  $value");
    });
  },
  child: const MaterialApp(
    home: StreamProviderDemo(),
  ),
);
```

<br/>

**View:**

```dart
class StreamProviderDemo extends StatelessWidget {
  const StreamProviderDemo({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("FutureProvider"),),
      body: Center(
        child: Consumer<Person>(builder: (ctx,person,child) =>  Text(person.name!),),
      ),
    );
  }
}
```

建议开发者先行了解**StreamBuilder**。

结果 先显示默认值，每1s更新一次数据，刷新一次UI。

<br/><br/><br/>
> <h2 id='MultiProvider'>MultiProvider</h2>
上述中我们只使用了一种Provder，但在实际开发中，程序肯定存在多种Provder，如果我们还是用嵌套的方式来解决，但是这样无疑是混乱的，可读性级差。比如：

```dart
return ProvderA(
  child: ProvderB(
    child: ProvderC(
      child: ProvderD(
        ...
        child: MaterialApp()
      ) 
    ) 
  )
)
```
为了解决这样的嵌套地狱，MultiProvder应运而生。它实际上是多种Provder的集合，且仅仅是改变了代码的书写方式。

`示例：`
**Model：**

```dart
class Person1 with ChangeNotifier{
  String name = "MultiProvider ---  1";
  void changName(){
    name = "更新MultiProvider ---  1";
    notifyListeners();
  }
}
```

```dart
class Person2 with ChangeNotifier{
  String name = "MultiProvider ---  2";
  void changName(){
    name = "更新MultiProvider ---  2";
    notifyListeners();
  }
}
```

**入口：**
providers多个Provider的集合

```dart
return MultiProvider(
  providers: [
    ChangeNotifierProvider<Person1>(
      create: (ctx) => Person1(),
    ),
    ChangeNotifierProvider<Person2>(
      create: (ctx) => Person2(),
    )
  ],
  child: const MaterialApp(
    home: MultiProviderDemo(),
  ),
);
```

**View：**

```dart
class MultiProviderDemo extends StatelessWidget {
  const MultiProviderDemo({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            Consumer<Person1>(builder: (ctx,person1,child) => Text(person1.name)),
            Consumer<Person2>(builder: (_,person2,child) => Text(person2.name)),
            Consumer<Person1>( /// 拿到person1对象，调用方法，也可以修改person2
              builder: (ctx,person1,child){
                return ElevatedButton(
                  onPressed: (){
                    person1.changName();
                  },
                  child: const Text("点击修改"),
                );
              },
            ),
          ],
        ),
      ),
    );
  }
}
```

<br/><br/>
><h3  id="ProxyProvider">ProxyProvider</h3>
我们日常开发中会遇到一种模型嵌套另一种模型、或一种模型的参数用到另一种模型的值、或是需要几种模型的值组合成一个新的模型的情况，在这种情况下，就可以使用 ProxyProvider 。它能够将多个 provider 的值聚合为一个新对象，将结果传递给 Provider（注意是Provider而不是  ChangeNotifierProvider），这个新对象会在其依赖的任意一个 provider 更新后同步更新值。

```dart
ProxyProvider<T, R> /// R依赖T或用到T的值，T发生改变会通知R
```

> **注：** 同步更新不代表同步更新UI，也可能只是值更新了。是否同步更新UI取决了使用了哪一种依赖的provider，比如使用最基础的 Provider 值已经改变了（通过热更新或debug可知），但是不会更新UI；若使用 ChangeNotifierProvider更新值的同时会同步更新UI。

<br/>

**示例：**
**Model：**

```dart
class Person extends ChangeNotifier{
  String name = "小虎牙";

  void changName(){
    name = "更新的小虎牙";
    notifyListeners();
  }
}
```

EatModel 需要用到 Person 的 name 值，才知道到底是谁在吃饭：

```dart
class EatModel{
  EatModel({required this.name});

  final String name;

  String get whoEat => "$name正在吃饭";
}
```

<br/>

**入口设置:**

```dart
return MultiProvider(
  providers: [
    ChangeNotifierProvider<Person>(
      create: (ctx) => Person(),
    ),
    ProxyProvider<Person, EatModel>(
      update: (ctx, person, eatModel) => EatModel(name: person.name),
    )
  ],
  child: const MaterialApp(
    home: ProxyProviderDemo(),
  ),
);
```

**View:**

```dart
class ProxyProviderDemo extends StatelessWidget {
  const ProxyProviderDemo({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            Consumer<EatModel>(builder: (ctx,eatModel,child) => Text(eatModel.whoEat)),
            Consumer<Person>( // 拿到person对象，调用方法
              builder: (ctx,person,child){
                return ElevatedButton( /// 点击按钮更新Person的name，eatModel.whoEat会同步更新
                  onPressed: () => person.changName(),
                  child: const Text("点击修改"),
                );
              },
            ),
          ],
        ),
      ),
    );
  }
}
```

**结果 页面显示** `小虎牙正在吃饭`；点击按钮后：内容更新为更新的小虎牙正在吃饭。

`ProxyProvider`还有其他不同的形式：`ProxyProvider、ProxyProvider2、ProxyProvider3...ProxyProvider6 `。类名后的数字是 ProxyProvider 依赖的 provider 的数量。一般很难用到6个或以上的模型糅合一个新的模型，如果有，那么应该需要思考工程架构是否出了问题。

<br/><br/>
><h3 id="ChangNotifierProxyProvider">ChangNotifierProxyProvider</h3>
与 ProxyProvider 的相似，不同的是 `ChangeNotifierProxyProvider` 会将它的值传递给 `ChangeNotifierProvider` 而非 `Provider`。

官方的示例看起来有点繁复，我们简化下写个商品展示和收藏列表的示例。当然我们应该学习官发示例：尽量在Model中使用私有变量 _，减少耦合。这里为了简单明了就随意一点。

**示例：**

Model 一共有3个模型对象，分别是商品模型 ShopModel、商品列表模型 ListModel、收藏列表 CollectionListModel。

**分别为：**

**Model：**

```dart
class Shop{
  final int id;
  final String name;
  Shop(this.id, this.name);
}
```

```dart
class ListModel {
  // 商品列表
  final List <Shop> shops = [
    Shop(1, "Apple/苹果 14 英寸 MacBook"),
    Shop(2, "HUAWEI/华为Mate 40 RS "),
    Shop(3, "Apple/苹果 11 英寸 iPad Pro"),
    Shop(4, "Xiaomi 12Pro5g骁龙8"),
    Shop(5, "Apple/苹果 iPhone 13 Pro"),
    Shop(6, "华为/HUAWEI Mate X2"),
    Shop(7, "小米11 Ultra至尊5g手机"),
    Shop(8, "HUAWEI/华为P40 Pro+ 5G 徕卡"),
  ];
}
```

```dart
class CollectionListModel extends ChangeNotifier{
  
  // 依赖ListModel
  final ListModel _listModel;
  
  CollectionListModel(this._listModel);
  
  // 所有收藏的商品
  List<Shop> shops = [];
  
  // 添加收藏
  void add(Shop shop){
    shops.add(shop);
    notifyListeners();
  }
  // 移除收藏
  void remove(Shop shop){
    shops.remove(shop);
    notifyListeners();
  }
}
```

<br/>

**入口：**

```dart
return MultiProvider(
  providers: [
    Provider<ListModel>(
      create: (ctx) => ListModel(),
    ),
    ChangeNotifierProxyProvider<ListModel, CollectionListModel>(
      create: (ctx) => CollectionListModel(ListModel()),
      update: (ctx, listModel, collectionModel) => CollectionListModel(listModel),
    )
  ],
  child: MaterialApp(
    theme: ThemeData(
      primarySwatch: Colors.orange,
    ),
    debugShowCheckedModeBanner: false,
    home: const ChangeNotifierProxyProviderDemo(),
  ),
);
```

<br/>

**Widget:**

```dart
class ChangeNotifierProxyProviderDemo extends StatefulWidget {
  const ChangeNotifierProxyProviderDemo({Key? key}) : super(key: key);
  @override
  _ChangeNotifierProxyProviderDemoState createState() => _ChangeNotifierProxyProviderDemoState();
}

class _ChangeNotifierProxyProviderDemoState extends State<ChangeNotifierProxyProviderDemo> {
  int _selectedIndex = 0;
  final _pages = [const ListPage(), const CollectionPage()];
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _pages[_selectedIndex],
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _selectedIndex,
        onTap: (index) {
          setState(() {
            _selectedIndex = index;
          });
        },
        items: const [
          BottomNavigationBarItem(
              icon: Icon(Icons.list_alt_outlined),
              label: "商品列表"
          ),
          BottomNavigationBarItem(
              icon: Icon(Icons.favorite),
              label: "收藏列表"
          )
        ],
      ),
    );
  }
}
```

**商品列表：**

```dart
class ListPage extends StatelessWidget {
  const ListPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {

    ListModel listModel = Provider.of<ListModel>(context);
    List<Shop> shops = listModel.shops;
    return Scaffold(
      appBar: AppBar(title: const Text("商品列表"),),
      body: ListView.builder(
        itemCount: listModel.shops.length,
        itemBuilder: (ctx,index) => ShopItem(shop: shops[index],),
      ),
    );
  }
}
```

**收藏列表：**

```dart
class CollectionPage extends StatelessWidget {
  const CollectionPage({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    CollectionListModel collectionModel = Provider.of<CollectionListModel>(context);
    List<Shop> shops = collectionModel.shops;
    return Scaffold(
      appBar: AppBar(title: const Text("收藏列表"),),
      body: ListView.builder(
        itemCount: shops.length,
        itemBuilder: (ctx,index) => ShopItem(shop: shops[index],),
      ),
    );
  }
}
```

**商品Item：**

```dart
class ShopItem extends StatelessWidget {
  const ShopItem({Key? key,required this.shop}) : super(key: key);
  final Shop shop;
  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: CircleAvatar(
        child: Text("${shop.id}"),
      ),
      title: Text(shop.name,style: const TextStyle(fontSize: 17),),
      trailing: ShopCollectionButton(shop: shop,),
    );
  }
}
```

**商品收藏按钮：**

```dart
class ShopCollectionButton extends StatelessWidget {
  const ShopCollectionButton({Key? key,required this.shop}) : super(key: key);
  final Shop shop;
  @override
  Widget build(BuildContext context) {
   CollectionListModel collectionModel = Provider.of<CollectionListModel>(context);
   bool contains = collectionModel.shops.contains(shop);
   return InkWell(
     onTap: contains ? ()=> collectionModel.remove(shop) : ()=> collectionModel.add(shop),
     child:  SizedBox(
       width: 60,height: 60,
       child: contains ? const Icon(Icons.favorite,color: Colors.redAccent,) : const Icon(Icons.favorite_border),
     ),
   );
  }
}
```

> 这里使用了 Provider.of 来获取数据，官方示例中使用了 context.read、 context.read，文章后续会有详细的介绍。

效果：
![flutter0.0.4.webp](./../Pictures/flutter0.0.4.webp)


<br/><br/>
><h3  id="ListenableProvider">ListenableProvider</h3>
供可监听对象使用的特殊 provider。ListenableProvider 会监听对象，并在监听器被调用时更新依赖此对象的 widgets。类似于 ChangeNotifierProvider，是其父类。适用于任何的 Listenable。一般情况下使用 ChangeNotifierProvider，但如果是自己实现 Listenable 或使用动画的话，就可以使用 ListenableProvider。

且 ListenableProvider 提供（provide）的对象是继承了 Listenable 抽象类的子类。由于无法混入，所以通过继承来实现，同时必须实现其 addListener / removeListener 方法，手动管理收听者。显然这样太过复杂，所有通常情况下都不需要这样做。

```dart
class ChangeNotifier implements Listenable
```
混入了 ChangeNotifier 的类会自动帮我们实现了管理，所以 ListenableProvider 同样也可以接收混入了 ChangeNotifier 的类。

<br/><br/>
><h3  id="ListenableProxyProvider">ListenableProxyProvider</h3>

ListenableProxyProvider 是 ListenableProvider的一个变体，但是在使用上和ChangeNotifierProvider效果惊人的一致。即存在2种或多种模型相互依赖的情况。

这里就不写示例了，相信开发者通过 ListenableProvider 和 ChangeNotifierProvider 的讲解应该能够很好的运用。

<br/><br/>
><h3  id="ValueListenableProvider">ValueListenableProvider</h3>

监听 ValueListenable，并且只暴露出 ValueListenable.value。它实际上是专门用于处理只有一个单一变化数据的 ChangeNotifier。

```dart
class ValueNotifier<T> extends ChangeNotifier implements ValueListenable<T>
```

它也有两种方式 ：
`ValueListenableProvider() 和 ValueListenableProvider.value()`。两种方式几乎是相同的。


<br/><br/><br/>
> <h2 id="消费者">消费者</h2>
<br/>

><h3  id="Provider.of">Provider.of</h3>
如果状态是希望暴露出的，应当提供一个 “of” 静态方法来获取其对象，开发者便可直接通过该方法来获取。

```dart
static T of<T>(BuildContext context, {bool listen = true})
```

其中 listen：默认true监听状态变化，false为不监听状态改变。
Provider.of<T>(context) 是 Provider 为我们提供的静态方法，当我们

使用该方法去获取值的时候会返回查找到的最近的 T 类型的 provider 给我们，且也不会遍历整个组件树。

<br/><br/>
> <h3 id='Consumer组件使用'>Consumer组件使用</h3>
[状态管理指南篇-Provider(完整解读Consumer)](https://github.com/awesome-tips/Flutter-Tips/blob/master/articles/Flutter%20%20状态管理指南篇——Provider.md#consumer)

Provider 中使用比较频繁的消费者，查看源码：

```dart
Consumer({
  Key? key,
  required this.builder,
  Widget? child,
}) : super(key: key, child: child);

...

@override
Widget buildWithChild(BuildContext context, Widget? child) {
  return builder(
    context,
    Provider.of<T>(context),
    child,
  );
}
```
发现它就是通过 Provider.of<T>(context) 来实现的。而且实际开发中使用 Provider.of<T>(context) 比 Consumer 简单好用太多，那 Consumer有什么优势吗？

对比一下，我们发现 Consumer 有个 Widget? child，它非常重要，能够在复杂项目中，极大地缩小你的控件刷新范围。

<br/>

**下面举一个简单计数Demo:**

```dart
return Scaffold(
  body: Consumer(
    builder: (BuildContext context,CounterModel counterModel,Widget? child){
      return Column(
        children: [
          Text("${counterModel.count}"),
          ElevatedButton(
            onPressed: ()=> counterModel.increment(),
            child: const Text("点击加1"),
          ),
          Text("其他更多组件"),
          Text("其他更多组件"),
          Text("其他更多组件"),
          Text("其他更多组件"),
          Text("其他更多组件"),
        ],
      );
    },
  ),
);
```

在上述示例中，我们后面很多的 Text 组件没有用到模型数据且不需要更新状态的，但是因为被Consumer 包裹，导致每次数据改变都会重新构建！严重影响性能且不优雅！

解决以上问题，一方面我们可以尽可能调整 Consumer 的位置，在需要使用数据的组件包裹 Consumer ，但这也会存在一个问题，单独用大量 Consumer 包裹，也跟 Provider 诞生的理念背道而驰。这时候我们就可以使用到 Widget? child 了。我们针对上述示例优化一下：

```dart
return Scaffold(
  body: Consumer(
    builder: (BuildContext context,CounterModel counterModel,Widget? child){
      return Column(
        children: [
          Text("${counterModel.count}"),
          ElevatedButton(
            onPressed: ()=> counterModel.increment(),
            child: const Text("点击加1"),
          ),
          child!
        ],
      );
    },
    child: Column(
      children: [
        Text("其他更多组件"),
        Text("其他更多组件"),
        Text("其他更多组件"),
        Text("其他更多组件"),
        Text("其他更多组件"),
      ],
    ),
  ),
);
```

我们使用 Widget? child 将不需要更新状态的组件包裹起来，大大提升了性能。

<br/><br/>
> <h3 id='Selector'>Selector</h3x>
Selector 也是一个消费者。与 Consumer 类似，只是对build调用Widget方法时提供更精细的控制。 Consumer 是监听一个 Provider 中所有数据的变化，Selector 则是监听某一个/多个值的变化。

比如用户模型 Person：有姓名、性别、年龄、身高、体重等信息，但是我们可能只会更新下年龄，其他的信息我们不希望重建，就可以使用 Selector 实现这个功能。

示例：

**Model:**

```dart
class Person with ChangeNotifier {
  String name = "小虎牙";
  int age = 18;
  double height = 180.0;

  // 年龄改变
  void increaseAge() {
    age ++;
    notifyListeners();
  }
}
```

<br/>

**入口：**

```dart
return ChangeNotifierProvider(
  create: (ctx) => Person(),
  child: const MaterialApp(
    home: SelectorDemo(),
  ),
);
```

<br/>

**View:**

```dart
class SelectorDemo extends StatelessWidget {
  const SelectorDemo({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Selector"),),
      body: Center(
        child: Selector<Person,int>(
          selector: (ctx,person) => person.age,
          builder: (ctx,age,child) {
            return Column(
              children: [
                Text("年龄为：$age"),
                child!
              ],
            );
          },
          child: Padding(
            padding: const EdgeInsets.only(top: 50),
            child: ElevatedButton(
              onPressed: () => Provider.of<Person>(context,listen: false).increaseAge(),
              child: const Text("点击改变年龄"),
            ),
          ),
        )
      )
    );
  }
}
```

结果： 显示 `年龄为18，点击后年龄加1。`

这里也使用到了 Widget? child，同 Consumer 一样极大地缩小控件刷新范围。


<br/><br/>
> <h3 id='InheritedContext'>InheritedContext</h3> 

`InheritedContext` 实际上是在 `Provider` 内置扩展了 `BuildContext`。 有三种方式：

<br/><br/>
><h3 id="BuildContext.read">BuildContext.read</h3>
使用与 Provider.of 类似。用来获取数据的，不会触发刷新。

**示例：**
- **Model:**

```dart
class Person {
  String name = "小虎牙";
}
```

<br/>

**入口：**

```dart
return Provider(
  create: (ctx) => Person(),
  child: const MaterialApp(
    home: ReadDemo(),
  ),
);
```

<br/>

**View:**

```dart
class ReadDemo extends StatelessWidget {
  const ReadDemo({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("ReadDemo"),),
      body: Center(
        child: Text("姓名：${context.read<Person>().name.toString()}"),
      )
    );
  }
}
```

结果： 显示 `姓名：小虎牙`，使用方式同 Provider.of()相同。

<br/><br/>
><h3 id="BuildContext.watch">BuildContext.watch</h3>
顾名思义，观察，可读可写，改变依赖的数据会触发更新。效果与 Consumer 极度类似，使用更简单明了。区别是没有 Consumer 的 Widget? child 的 优化控件刷新的功能。

通过 `context.watch<Model>()` 获取模型对象，使用和刷新数据。

**Model：**

```dart
class Person with ChangeNotifier{
  String name = "小虎牙";

  changeName(){
    name = "刷新小虎牙";
    notifyListeners();
  }
}
```

<br/>

**入口：**

```dart
return ChangeNotifierProvider(
  create: (ctx) => Person(),
  child: const MaterialApp(
    home: WatchDemo(),
  ),
);
```

<br/>

**View:**

```dart
class WatchDemo extends StatelessWidget {
  const WatchDemo({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {

    /// 通过context获取模型对象
    final person = context.watch<Person>();

    return Scaffold(
      appBar: AppBar(title: const Text("Watch"),),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            Text("姓名：${person.name}"),
            Padding(
              padding: const EdgeInsets.only(top: 50),
              child: ElevatedButton(
                onPressed: () => person.changeName(),
                child: const Text("点击改变姓名"),
              ),
            ),
          ],
        )
      )
    );
  }
}
```

结果： 显示：`姓名：小虎牙` ，点击按钮：显示更新为 `姓名：刷新小虎牙`。

<br/><br/>
><h3 id="BuildContext.select">BuildContext.select</h3>
于前面提到的 Selector 类似，指定监听对象的部分属性，使用更简单明了。区别是没有 Selector 的 Widget? child 的 优化控件刷新的功能。

**Model:**

```dart
class Person with ChangeNotifier {
  String name = "小虎牙";
  int age = 18;
  double height = 180.0;
  
  void increaseAge() {
    age ++;
    notifyListeners();
  }
}
```
<br/>

**入口类：**

```dart
return ChangeNotifierProvider(
  create: (ctx) => Person(),
  child: const MaterialApp(
    home: SelectDemo(),
  ),
);
```
<br/>

**View：**

```dart
class SelectDemo extends StatelessWidget {
  const SelectDemo({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
  
    /// 通过context获取模型对象
    final age = context.select((Person person) => person.age);

    return Scaffold(
      appBar: AppBar(title: const Text("Watch"),),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            Text("年龄：$age"),
            Padding(
              padding: const EdgeInsets.only(top: 50),
              child: ElevatedButton(
                onPressed: () => Provider.of<Person>(context, listen: false)..increaseAge(),
                child: const Text("点击改变姓名"),
              ),
            ),
          ],
        )
      )
    );
  }
}
```

结果： 显示 `年龄为18`，点击后年龄加1。

<br/><br/>
> <h2 id='context获取widget树中state对象'>context获取widget树中state对象</h2>
**情景:**

&emsp; 由于 StatefulWidget 的具体逻辑都在其 State 中，所以很多时候，我们需要获取 StatefulWidget 对应的State 对象来调用一些方法，比如Scaffold组件对应的状态类ScaffoldState中就定义了打开 SnackBar（路由页底部提示条）的方法。我们有两种方法在子 widget 树中获取父级 StatefulWidget 的State 对象。

<br/>
- **1.通过Context获取**

&emsp; context对象有一个findAncestorStateOfType()方法，该方法可以从当前节点沿着 widget 树向上查找指定类型的 StatefulWidget 对应的 State 对象。下面是实现打开 SnackBar 的示例：

```dart
class GetStateObjectRoute extends StatefulWidget {
  const GetStateObjectRoute({Key? key}) : super(key: key);

  @override
  State<GetStateObjectRoute> createState() => _GetStateObjectRouteState();
}

class _GetStateObjectRouteState extends State<GetStateObjectRoute> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("子树中获取State对象"),
      ),
      body: Center(
        child: Column(
          children: [
            Builder(builder: (context) {
              return ElevatedButton(
                onPressed: () {
                  // 查找父级最近的Scaffold对应的ScaffoldState对象
                  ScaffoldState _state = context.findAncestorStateOfType<ScaffoldState>()!;
                  // 打开抽屉菜单
                  _state.openDrawer();
                },
                child: Text('打开抽屉菜单1'),
              );
            }),
          ],
        ),
      ),
      drawer: Drawer(),
    );
  }
}
```


默认父状态组件提供of方法,表明其是默认提供的公共暴露出提供state对象的方法;

&emsp; 一般来说，如果 StatefulWidget 的状态是私有的（不应该向外部暴露），那么我们代码中就不应该去直接获取其 State 对象；

&emsp; 如果StatefulWidget的状态是希望暴露出的（通常还有一些组件的操作方法），我们则可以去直接获取其State对象。但是通过 context.findAncestorStateOfType 获取 StatefulWidget 的状态的方法是通用的，我们并不能在语法层面指定 StatefulWidget 的状态是否私有，所以在 Flutter 开发中便有了一个默认的约定：如果 StatefulWidget 的状态是希望暴露出的，应当在 StatefulWidget 中提供一个of 静态方法来获取其 State 对象，开发者便可直接通过该方法来获取；

&emsp; 如果 State不希望暴露，则不提供of方法。这个约定在 Flutter SDK 里随处可见。所以，上面示例中的Scaffold也提供了一个of方法，我们其实是可以直接调用它的：

```dart
Builder(builder: (context) {
  return ElevatedButton(
    onPressed: () {
      // 直接通过of静态方法来获取ScaffoldState
      ScaffoldState _state=Scaffold.of(context);
      // 打开抽屉菜单
      _state.openDrawer();
    },
    child: Text('打开抽屉菜单2'),
  );
}),
```

<br/>
又比如我们想显示 snack bar 的话可以通过下面代码调用：

```dart
Builder(builder: (context) {
  return ElevatedButton(
    onPressed: () {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text("我是SnackBar")),
      );
    },
    child: Text('显示SnackBar'),
  );
}),
```


上面示例运行后，点击”显示SnackBar“，效果如下图所示:
![flutter1_80_3.png](./../Pictures/flutter1_80_3.png)

<br/><br/>
- **2.通过GlobalKey**

- Flutter还有一种通用的获取State对象的方法——通过GlobalKey来获取！ 步骤分两步：

	- 给目标StatefulWidget添加GlobalKey。

```dart
//定义一个globalKey, 由于GlobalKey要保持全局唯一性，我们使用静态变量存储
static GlobalKey<ScaffoldState> _globalKey= GlobalKey();
...
Scaffold(
    key: _globalKey , //设置key
    ...  
)
```


- 2.通过GlobalKey来获取State对象

```dart
_globalKey.currentState.openDrawer()
```

&emsp; GlobalKey 是 Flutter 提供的一种在整个 App 中引用 element 的机制。如果一个 widget 设置了GlobalKey，那么我们便可以通过globalKey.currentWidget获得该 widget 对象、globalKey.currentElement来获得 widget 对应的element对象，如果当前 widget 是StatefulWidget，则可以通过globalKey.currentState来获得该 widget 对应的state对象。

&emsp; **注意：**使用 GlobalKey 开销较大，如果有其他可选方案，应尽量避免使用它。另外，同一个 GlobalKey 在整个 widget 树中必须是唯一的，不能重复。


<br/><br/>
> <h3 id='builder'> Builder </h3>

介绍:调用闭包以获取其子小部件的小部件

基础用法：

```dart
Builder(
  builder: (BuildContext context){
    return Container();
  },
)
```
 
<br/><br/>
    
Builder中有一个builder，返回一个Widget即可，那和直接使用Container有什么区别吗？

答案肯定是有的，用处主要体现在context上。

- **1.使用场景一**

&emsp; 看下这个异常信息：Scaffold.of() called with a context that does not contain a Scaffold，这个异常学习Flutter的过程中会经常遇到，原因就是当前的context没有包含在Scaffold控件中，比如下面的写法就会出现此异常：

```dart
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('老孟'),
      ),
      body: Center(
        child: RaisedButton(
          color: Colors.pink,
          textColor: Colors.white,
          onPressed: _displaySnackBar(context),
          child: Text('show SnackBar'),
        ),
      ),
    );
  }
}

_displaySnackBar(BuildContext context) {
  final snackBar = SnackBar(content: Text('老孟'));
  Scaffold.of(context).showSnackBar(snackBar);
}
```


<br/>
   
使用Build解决此问题：

```dart
Scaffold(
    appBar: AppBar(
        title: Text('老孟'),
    ),
    body: Builder(
        builder: (context) => 
            Center(
            child: RaisedButton(
            color: Colors.pink,
            textColor: Colors.white,
            onPressed: () => _displaySnackBar(context),
            child: Text('老孟'),
            ),
        ),
    ),
);
```
    
    
<br/><br/>
- **2.使用场景二**

自定义事件分发，代码如下：

```dart
NotificationListener<CustomNotification>(
  onNotification: (CustomNotification notification) {
    print('介绍事件——2：${notification.value}');
    return false;
  },
  child: Center(
    child: RaisedButton(
      child: Text('发送'),
      onPressed: () {
        CustomNotification('自定义事件').dispatch(context);
      },
    ),
  ),
)
```
    
    
<br/><br/>
此时点击按钮并不会分发事件，修改如下：

```dart
NotificationListener<CustomNotification>(
  onNotification: (CustomNotification notification) {
    print('介绍事件——2：${notification.value}');
    return false;
  },
  child: Center(
    child: Builder(
      builder: (context) {
        return RaisedButton(
          child: Text('发送'),
          onPressed: () {
            CustomNotification('自定义事件').dispatch(context);
          },
        );
      },
    ),
  ),
)
```
    
只需在RaisedButton外面包裹Builder即可，为什么会出现此问题？

&emsp; 因为没有Builder的context表示当前整个控件的context，其上并没有NotificationListener监听，而加上Builder后，context表示Builder控件，其上有NotificationListener监听

<br/><br/>

`stateWidgets. 文件`

```dart
import 'package:flutter/cupertino.';
import 'package:flutter/material.';

class TapboxA extends StatefulWidget {
  TapboxA({Key key}): super(key: key);

  @override
  _TapboxAState createState() => new _TapboxAState();
}

class _TapboxAState extends State<TapboxA> {
  bool _active = false;

  void _handleTap() {
    setState(() {
      _active = !_active;
    });
  }

  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return new GestureDetector(
      onTap: _handleTap,
      child: new Container(
        child: new Center(
          child: new Text(
            _active ? "激活了" : "未激活",
            style: new TextStyle(
              fontSize: 32.0,
              color: Colors.white
            ),
          ),
        ),
        width: 200.0,
        height: 200.0,
        decoration: new BoxDecoration(
          color: _active ? Colors.lightGreen[700] : Colors.grey[600],
        ),
      ),
    );
  }

}
```

`main. 文件`

```dart
Widget build(BuildContext context) {

  return MaterialApp(
    title: 'Flutter Demo',
    theme: ThemeData(
      primarySwatch: Colors.cyan,
    ),
    home: TapboxA(),
  );
}
}
```

效果：

![flutter1_64.png](./../Pictures/flutter1_64.png)

<br/><br/><br/>
> <h2 id='按需rebuild（ValueListenableBuilder）'>按需rebuild（ValueListenableBuilder）</h2>

InheritedWidget 提供一种在 widget 树中从上到下共享数据的方式，但是也有很多场景数据流向并非从上到下，比如从下到上或者横向等。为了解决这个问题，Flutter 提供了一个 ValueListenableBuilder 组件，它的功能是监听一个数据源，如果数据源发生变化，则会重新执行其 builder，定义如下：


```dart
const ValueListenableBuilder({
  Key? key,
  required this.valueListenable, // 数据源，类型为ValueListenable<T>
  required this.builder, // builder
  this.child,
}

```

- `valueListenable：`类型为 ValueListenable<T>，表示一个可监听的数据源。
- `builder：`数据源发生变化通知时，会重新调用 builder 重新 build 子组件树。
- `child:` builder 中每次都会重新构建整个子组件树，如果子组件树中有一些不变的部分，可以传递给child，child 会作为builder的第三个参数传递给 builder，通过这种方式就可以实现组件缓存，原理和AnimatedBuilder 第三个 child 相同。

可以发现 ValueListenableBuilder 和数据流向是无关的，只要数据源发生变化它就会重新构建子组件树，因此可以实现任意流向的数据共享。

<br/><br/><br/>
> <h2 id='异步UI更新（FutureBuilder、StreamBuilder）'>异步UI更新（FutureBuilder、StreamBuilder）</h2>

[**看这里**](https://book.flutterchina.club/chapter7/futurebuilder_and_streambuilder.html)


很多时候我们会依赖一些异步数据来动态更新UI，比如在打开一个页面时我们需要先从互联网上获取数据，在获取数据的过程中我们显示一个加载框，等获取到数据时我们再渲染页面；又比如我们想展示Stream（比如文件流、互联网数据接收流）的进度。当然，通过 StatefulWidget 我们完全可以实现上述这些功能。但由于在实际开发中依赖异步数据更新UI的这种场景非常常见，因此Flutter专门提供了 **FutureBuilder** 和 **StreamBuilder** 两个组件来快速实现这种功能。

<br/><br/><br/>
> <h2 id='FutureBuilder'>FutureBuilder</h2>

FutureBuilder会依赖一个Future，它会根据所依赖的Future的状态来动态构建自身。我们看一下FutureBuilder构造函数：

```dart
FutureBuilder({
  this.future,
  this.initialData,
  required this.builder,
})

```
- **future：** FutureBuilder依赖的Future，通常是一个异步耗时任务。

- **initialData：** 初始数据，用户设置默认数据。

- **builder：** Widget构建器；该构建器会在Future执行的不同阶段被多次调用，构建器签名如下：


<br/>

```dart
Function (BuildContext context, AsyncSnapshot snapshot)
``` 

snapshot会包含当前异步任务的状态信息及结果信息 ，比如我们可以通过snapshot.connectionState获取异步任务的状态信息、通过snapshot.hasError判断异步任务是否有错误等等，完整的定义读者可以查看AsyncSnapshot类定义。

另外，FutureBuilder的builder函数签名和StreamBuilder的builder是相同的。

<br/><br/><br/>
> <h2 id='StreamBuilder'>StreamBuilder</h2>
在中Stream 也是用于接收异步事件数据，和Future 不同的是，它可以接收多个异步操作的结果，它常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。StreamBuilder正是用于配合Stream来展示流上事件（数据）变化的UI组件。下面看一下StreamBuilder的默认构造函数：

```dart
StreamBuilder({
  this.initialData,
  Stream<T> stream,
  required this.builder,
}) 
```

可以看到和FutureBuilder的构造函数只有一点不同：前者需要一个future，而后者需要一个stream

<br/>

**Stream**

Stream 是中的一个类，代表一个异步的事件流。Stream 可以用于处理异步的数据序列，例如网络请求的响应、用户输入事件等。

在StreamBuilder中，stream参数需要传入一个Stream实例，StreamBuilder会监听这个Stream并在数据变化时进行UI更新。例如：

```dart
Stream<int> counterStream = Stream.periodic(Duration(seconds: 1), (count) => count);

```
这个counterStream每秒会发出一个递增的整数。

<br/>

**builder**

builder 是一个回调函数，用于构建StreamBuilder的子Widget。每当Stream发出新数据时，builder函数就会被调用。builder函数接收两个参数：

- `BuildContext context`：当前的构建上下文。
- `AsyncSnapshot<T> snapshot：`包含了Stream的最新数据以及连接状态。

builder的返回值是一个Widget，这个Widget会显示在UI上。

builder函数的签名如下：

```dart
Widget Function(BuildContext context, AsyncSnapshot<T> snapshot)

```


<br/><br/><br/>
> <h2 id='详解AsyncSnapshot'>详解AsyncSnapshot</h2>

AsyncSnapshot 是一个包含了Stream最新数据和连接状态的对象。它有几个重要的属性：

- `connectionState`：表示与Stream的连接状态，可以是 none、waiting、active 或 done。
- `data：`最新的Stream数据。
- `error：`如果Stream发生错误，error属性会包含错误信息。
- `hasData：`如果snapshot包含数据，则返回 true。
- `hasError：`如果snapshot包含错误信息，则返回 true。

<br/><br/><br/>

**案例：**

我们创建一个计时器的示例：每隔1秒，计数加1。这里，我们使用Stream来实现每隔一秒生成一个数字:

```dart
Stream<int> counter() {
  return Stream.periodic(Duration(seconds: 1), (i) {
    return i;
  });
}
```

StreamBuilder使用代码如下：

```dart
Widget build(BuildContext context) {
    return StreamBuilder<int>(
      stream: counter(), //
      //initialData: ,// a Stream<int> or null
      builder: (BuildContext context, AsyncSnapshot<int> snapshot) {
        if (snapshot.hasError)
          return Text('Error: ${snapshot.error}');
        switch (snapshot.connectionState) {
          case ConnectionState.none:
            return Text('没有Stream');
          case ConnectionState.waiting:
            return Text('等待数据...');
          case ConnectionState.active:
            return Text('active: ${snapshot.data}');
          case ConnectionState.done:
            return Text('Stream 已关闭');
        }
        return null; // unreachable
      },
    );
 }
```


<BR/>

***
<BR/><BR/><BR/>

> <H1 ID='事件处理与通知'>事件处理与通知</H1>


在移动端，各个平台或UI系统的原始指针事件模型基本都是一致，即：一次完整的事件分为三个阶段：手指按下、手指移动、和手指抬起，而更高级别的手势（如点击、双击、拖动等）都是基于这些原始事件的。

当指针按下时，Flutter会对应用程序执行命中测试(Hit Test)，以确定指针与屏幕接触的位置存在哪些组件（widget）， 指针按下事件（以及该指针的后续事件）然后被分发到由命中测试发现的最内部的组件，然后从那里开始，事件会在组件树中向上冒泡，这些事件会从最内部的组件被分发到组件树根的路径上的所有组件，这和Web开发中浏览器的事件冒泡机制相似， 但是Flutter中没有机制取消或停止“冒泡”过程，而浏览器的冒泡是可以停止的。注意，只有通过命中测试的组件才能触发事件，我们会在下一节中深入介绍命中测试过程。

<BR/><BR/><BR/>
> <H2 ID='Listener组件'>Listener组件</H2>

Flutter中可以使用Listener来监听原始触摸事件，按照本书对组件的分类，则Listener也是一个功能性组件。下面是Listener的构造函数定义：

```dart
Listener({
  Key key,
  this.onPointerDown, //手指按下回调
  this.onPointerMove, //手指移动回调
  this.onPointerUp,//手指抬起回调
  this.onPointerCancel,//触摸事件取消回调
  this.behavior = HitTestBehavior.deferToChild, //先忽略此参数，后面小节会专门介绍
  Widget child
})
```


<BR/><BR/><BR/>
> <H2 ID='Flutter事件机制'>Flutter事件机制</H2>


[**Flutter 事件处理流程**](https://book.flutterchina.club/chapter8/hittest.html#_8-3-1-flutter-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B)

Flutter 事件处理流程主要分两步，为了聚焦核心流程，我们以用户触摸事件为例来说明：

- **命中测试：** 当手指按下时，触发 PointerDownEvent 事件，按照深度优先遍历当前渲染（render object）树，对每一个渲染对象进行“命中测试”（hit test），如果命中测试通过，则该渲染对象会被添加到一个 HitTestResult 列表当中。

- **事件分发：** 命中测试完毕后，会遍历 HitTestResult 列表，调用每一个渲染对象的事件处理方法（handleEvent）来处理 PointerDownEvent 事件，该过程称为“事件分发”（event dispatch）。随后当手指移动时，便会分发 PointerMoveEvent 事件。

- **事件清理：** 当手指抬（ PointerUpEvent ）起或事件取消时（PointerCancelEvent），会先对相应的事件进行分发，分发完毕后会清空 HitTestResult 列表。

<br/>

**需要注意：**

命中测试是在 PointerDownEvent 事件触发时进行的，一个完成的事件流是 `down > move > up (cancle)。`

如果父子组件都监听了同一个事件，则子组件会比父组件先响应事件。这是因为命中测试过程是按照深度优先规则遍历的，所以子渲染对象会比父渲染对象先加入 HitTestResult 列表，又因为在事件分发时是从前到后遍历 HitTestResult 列表的，所以子组件比父组件会更先被调用 handleEvent 。


<br/><br/>

***
<br/><br/><br/><br/>

> <h1 id='系统方法调用顺序'>系统方法调用顺序</h1>


<br/>
> <h2 id='状态setState方法调用'>状态 setState方法调用</h2>
- **触发组件的 build 方法**
	- 对子、父小部件的影响：
	- 子控件的build方法会被执行，如果key不同，则initState方法也会被执行；
	- 父控件不执行build和initState；


<br/><br/>

> <h2 id='导航Navigation'>导航 Navigation</h2>

- 弹框pop：
	- initState和build都不会被执行；

- 页面pop：
	- pop回来之后,build 方法会被执行；

- 页面push：
	- push的时候,build 方法会被执行；

- 列表滚动：
	- 列表新item的build和initState方法都会被执行；
	- 当列表所在页面setState的时候，如果item的key没变化，则item只执行build方法，如果item的key有变化则执行build和initState；




<br/>

***
<br/><br/><br/>

> <h1 id='路由管理'>路由管理</h1>


打开一个简单的路由Controller

```dart
//创建一个点击按钮
FlatButton(
  child: Text("打开新路由"),
  textColor: Colors.blue,
  onPressed: (){
    //导航到新路由
    Navigator.push(context, MaterialPageRoute(builder: (context) {
      return NewRoute();
    }));
  },
)



//路由controller
class NewRoute extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    //Scaffold 是 Material 库中提供的页面脚手架，
    //它提供了默认的导航栏、标题和包含主屏幕widget树（后同“组件树”或“部件树”）的body属性，组件树可以很复杂。
    return Scaffold(
      appBar: AppBar(
        title: Text("👋首页"),
      ),
      body: Center(
        child: Text("这是新的路由"),
      ),
    );
    
  }
}
```

效果图：
![flutter1_65.png](./../Pictures/flutter1_65.png)

&emsp; `MaterialPageRoute`继承自`PageRoute`类，`PageRoute`类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。
&emsp; `MaterialPageRoute` 是`Material组件库提供的组件`，它可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画。

<br/>

&emsp; `MaterialPageRoute` 构造函数的各个参数的意义：

```dart
  MaterialPageRoute({
    WidgetBuilder builder,
    RouteSettings settings,
    bool maintainState = true,
    bool fullscreenDialog = false,
  })
```

- `builder` 是一个WidgetBuilder类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个widget。我们通常要实现此回调，返回新路由的实例。
- `settings` 包含路由的配置信息，如路由名称、是否初始路由（首页）。
- `maintainState`：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置maintainState为false。
- `fullscreenDialog` 表示新的路由页面是否是一个全屏的模态对话框，在iOS中，如果fullscreenDialog为true，新页面将会从屏幕底部滑入（而不是水平方向）。


<br/><br/><br/>
> <h2 id='详解WidgetBuilder'>详解WidgetBuilder</h2>

```dart
Navigator.of(context).push(
  MaterialPageRoute(builder: (context) => MyPage()),
);
```

**WidgetBuilder是什么？其回掉函数里的buildContext是当前上下文吗？**

**定义：**

```dart
typedef WidgetBuilder = Widget Function(BuildContext context);
```

`MaterialPageRoute(builder: (context) => MyPage())`中的context是回调中的参数，具体来源于Flutter框架在构建新页面的过程中自动生成并传递给builder函数的BuildContext。这个BuildContext代表了新页面的构建上下文，与初始调用`Navigator.of(context).push(...)`时的context是不同的。



<br/><br/><br/>
> <h2 id='路由导航'>路由导航</h2>

&emsp; [**MaterialApp**](https://docs.flutter.io/flutter/material/MaterialApp-class.html) 是我们app开发中常用的符合MaterialApp Design设计理念的入口Widget，从源码可以看出该widget的构造方法中有多个参数，但是基本上大多数参数是可以省略的。


```dart
MaterialApp({
  Key key,
  this.title = '', // 设备用于为用户识别应用程序的单行描述
  this.home, // 应用程序默认路由的小部件,用来定义当前应用打开的时候，所显示的界面
  this.color, // 在操作系统界面中应用程序使用的主色。
  this.theme, // 应用程序小部件使用的颜色。
  this.routes = const <String, WidgetBuilder>{}, // 应用程序的顶级路由表
  this.navigatorKey, // 在构建导航器时使用的键。
  this.initialRoute, // 如果构建了导航器，则显示的第一个路由的名称
  this.onGenerateRoute, // 应用程序导航到指定路由时使用的路由生成器回调
  this.onUnknownRoute, // 当 onGenerateRoute 无法生成路由(initialRoute除外)时调用
  this.navigatorObservers = const <NavigatorObserver>[], // 为该应用程序创建的导航器的观察者列表
  this.builder, // 用于在导航器上面插入小部件，但在由WidgetsApp小部件创建的其他小部件下面插入小部件，或用于完全替换导航器
  this.onGenerateTitle, // 如果非空，则调用此回调函数来生成应用程序的标题字符串，否则使用标题。
  this.locale, // 此应用程序本地化小部件的初始区域设置基于此值。
  this.localizationsDelegates, // 这个应用程序本地化小部件的委托。
  this.localeListResolutionCallback, // 这个回调负责在应用程序启动时以及用户更改设备的区域设置时选择应用程序的区域设置。
  this.localeResolutionCallback, // 
  this.supportedLocales = const <Locale>[Locale('en', 'US')], // 此应用程序已本地化的地区列表 
  this.debugShowMaterialGrid = false, // 打开绘制基线网格材质应用程序的网格纸覆盖
  this.showPerformanceOverlay = false, // 打开性能叠加
  this.checkerboardRasterCacheImages = false, // 打开栅格缓存图像的棋盘格
  this.checkerboardOffscreenLayers = false, // 打开渲染到屏幕外位图的图层的棋盘格
  this.showSemanticsDebugger = false, // 打开显示框架报告的可访问性信息的覆盖
  this.debugShowCheckedModeBanner = true, // 在选中模式下打开一个小的“DEBUG”横幅，表示应用程序处于选中模式
}) 
```


<br/>

**`main. `** Code

```dart
import 'package:flutter/material.';
import 'package:flutter_navigaiton/tool/tool.';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {

  @override
  Widget build(BuildContext context) {
    //MaterialApp 是我们app开发中常用的符合MaterialApp Design设计理念的入口Widget
    return MaterialApp(
      title: 'Flutter 路由导航', //设备用于为用户识别应用程序的单行描述
      theme: ThemeData( //// 应用程序小部件使用的颜色
        primarySwatch: Colors.blue,
      ),
      home: NamedRouter.initApp(),  // 应用程序默认路由的小部件,用来定义当前应用打开的时候，所显示的界面
    );
  }
}



class NamedRouter {
  static Map<String, WidgetBuilder> routes;
//初始化App
  static Widget initApp() {
    return MaterialApp(
      initialRoute: '/',
      routes: NamedRouter.initRoutes(),// 应用程序的顶级路由表
    );
  }

//初始化路由
  static initRoutes() {
    routes = {
      '/': (context) => FirstScreen(),
      '/second': (context) => SecondScreen(),
      '/toolWidget': (context) => toolWidget()
    };
    return routes;
  }


}

class FirstScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('First Screen'),
      ),
      body: Center(
        child: RaisedButton(
          child: Text('Launch screen'),
          onPressed: () {
            // Navigate to the second screen using a named route
            Navigator.pushNamed(context, '/second');
          },
        ),
      ),
    );
  }
}

class SecondScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("Second Screen"),
      ),
      body: Center(
        child: RaisedButton(
          onPressed: () {
            // Navigate back to the first screen by popping the current route
            // off the stack
            // Navigator.pop(context);
            Navigator.pushNamed(context, "/toolWidget");
          },
          child: Text('push to toolWidget 组件'),
        ),
      ),
    );
  }
}

```

<br/>

**tool.** Code

```dart
import 'package:flutter/cupertino.';
import 'package:flutter/material.';

class toolWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("toolWidget"),
      ),
      body: Center(
        child: RaisedButton(
          onPressed: () {
            // Navigate back to the first screen by popping the current route
            // off the stack
            Navigator.pop(context);
          },
          child: Text('Go back!'),
        ),
      ),
    );
  }
}

```

<br/>

效果：

![flutter1_45.png](./../Pictures/flutter1_45.png)

<br/>

***
<br/><br/>

> <h1 id='Stream'>Stream</h1>

<br/>
> <h2 id=' 分类'> 分类</h2>

-  **`Single-subscriptio`** :  单订阅流;
- **`broadcast`**:   广播式的流（可多订阅）;
- 如果一个流是单订阅模式 却想多次订阅，可以通过`asBroadcastStrea()`方法来修改。

&emsp;  单订阅流只能被订阅一次，重复订阅会报错， 直到设置listen 后才会发送。单订阅流通常用于流式数据块较大的连续数据，如文件I/O;

&emsp;  广播式的流可以订阅多次，在listen之前的数据会丢失。

<br/>

&emsp;  为了方操作 Stream ，官方提供了StreamController.

&emsp; 如下图所示，StreamSink来添加流(入口），同时提供 stream 属性用于对外的监听和变换。 

&emsp;  stream.listen的返回一个StreamSubscription，可以通过它的`pause(), resume(), cancel()`等方法来操作流的订阅。


![flutter1_46.png](./../Pictures/flutter1_46.png)

<br/><br/>
> <h3 id='StreamController'>StreamController</h3>

```dart
// 创建一个单订阅流
StreamController controller = StreamController<String>(); 
// 创建一个广播式的订阅流
StreamController controller = StreamController.broadcast(); 
```


<br/><br/>
> <h3 id='listen'>listen</h3>

 **listen ：** 用来设置监听， 它的返回值是 StreamSubscribe。

-  **`StreamSubscribe`**
	- ` pause()` ： 暂停监听（是立即暂停），暂停后的事件流不会丢失，会在resume后一起回调;
	- `resume()`： 唤醒pause的流
	- `cancel()`： 取消



<br/><br/>
> <h2 id='单订阅'>单订阅</h2>

```dart
 ///定义一个Controller
  StreamController<List<String>> _dataController = StreamController<List<String>>();
  ///获取 StreamSink 做 add 入口
  StreamSink<List<String>> _dataSink = _dataController.sink;
  ///获取 Stream 用于监听
  Stream<List<String>> _dataStream =  _dataController.stream;
  ///事件订阅对象
  StreamSubscription _dataSubscription = _dataStream.listen((value){
    ///do change
    print('监听值为：${value}');
  });
  ///改变事件
  _dataSink.add(["first", "second", "three", "more"]);
```

打印：

![flutter1_47.png](./../Pictures/flutter1_47.png)

`其他的`

<br/>

```dart
StreamController controller = StreamController<String>();
StreamSink sink = controller.sink;
Stream stream = controller.stream;

stream.transform(StreamTransformer<String, String>.fromHandlers(handleData: (String data, EventSink<String> sink) {
if (!data.contains('数据2')) {
  sink.add(data);
}
})).listen((event) {
print('接受到的数据是： ${event}');
});
sink.add('3秒后才设置监听。');
```

打印：

```dart
flutter: 接受到的数据是： 3秒后才设置监听。
```

<br/>

```dart
StreamController controller = StreamController<String>();
StreamSink sink = controller.sink;
Stream stream = controller.stream;


StreamSubscription subscription = controller.stream.transform(StreamTransformer<String, String>.fromHandlers(handleData: (String data, EventSink<String> sink){
print('transform');
if (!data.contains('数据3')) {
  sink.add(data);
}
})).listen((event) {
print('接受到的数据是： ${event}');
}); 
sink.add('我是一条新的消息');

```

打印：

```
flutter: 接受到的数据是： 我是一条新的消息
```

<br/><br/>
> <h2 id='多订阅流'>多订阅流</h2>


```dart
// 初始化一个int类型的广播Stream controller
final StreamController<int> ctrl = StreamController<int>.broadcast();

// 初始化一个监听，同时通过transform对数据进行简单处理
final StreamSubscription subscription = ctrl.stream
                      .where((value) => (value % 2 == 0))
                      .listen((value) => print('监听：$value'));

// 往Stream中添加数据
for(int i=1; i<11; i++){
ctrl.sink.add(i);
}

// StreamController用完后需要释放
ctrl.close();
```

打印：

![flutter1_48.png](./../Pictures/flutter1_48.png)

<br/>

***
<br/><br/>

> <h1 id='异常抛出'>异常抛出</h1>

<br/><br/>
> <h2 id='Throw'>Throw</h2>

- 抛出一个已知异常

```dart
//执行
print('<<<<<<<<<<<<<抛出异常前');
//执行
throw new FormatException('抛出异常！！！');
//或者：  throw '抛出异常！！！';
//不执行
print('抛出异常前>>>>>>>>>>>>');
```

打印效果：

![flutter1_49.png](./../Pictures/flutter1_49.png)



从打印结果来看，一旦发生异常后面的逻辑就不会执行了。


<br/><br/>
> <h2 id='Catch'>Catch</h2>

- 普通捕获

```dart
print('<<<<<<<<<<<<<抛出异常前');
var initArray = [10, 20, 30, 40, 50];
try {
  
  print('========= ${initArray[5]}');
  
} catch (e) {
  print('try 异常错误 !' + e.toString());
}
print('>>>>>>>>>>>> try 异常捕获结束 !');
           
```


![flutter1_50.png](./../Pictures/flutter1_50.png)


&emsp;  用try 包含异常的代码，然后进行捕获。捕获后进行输出错误的代码提示，但是后面的代码依然执行。

<br/><br/>
> <h3 id='关键字On'>关键字On</h3>

```dart
print('<<<<<<<<<<<<<抛出异常前');
var initArray = [10, 20, 30, 40, 50];

try {
print('========= ${initArray[5]}');

} on RangeError {
print('====== on ${initArray[4]}');
} on FormatException {
print('FormatException');
} catch (e) {
print('try 异常错误提示 !' + e.toString());
}
print('>>>>>>>>>>>> try 异常捕获结束 !');
```

![flutter1_51.png](./../Pictures/flutter1_51.png)

&emsp;  我们看到详细的错误信息没有打印，因为代码逻辑走到 on RangeError 分支，而输出的详细错误信息是作为默认异常处理才被执行的。


<br/><br/>
> <h3 id='再次抛出异常rethrow'>再次抛出异常rethrow</h3>

```dart
print('<<<<<<<<<<<<<抛出异常前');
var initArray = [10, 20, 30, 40, 50];

try {
  print('========= ${initArray[5]}');
  
} on RangeError {
  print('====== on ${initArray[4]}');
  rethrow;
} on FormatException {
  print('FormatException');
} catch (e) {
  print('try 异常错误提示 !' + e.toString());
}
print('>>>>>>>>>>>> try 异常捕获结束 !');

```

效果：

![flutter1_52.png](./../Pictures/flutter1_52.png)


&emsp; 我们看到当我们使用了 rethrow 后，我们的代码并没有对后面的逻辑进行执行，尤其是 catch 中的捕获，仅仅是给出了错误的原因。


<br/><br/>
> <h2 id='Finally'>Finally</h2>

```dart
print('<<<<<<<<<<<<<抛出异常前');

var initArray = [10, 20, 30, 40, 50];

try {
  print('========= ${initArray[5]}');
  
} on RangeError {
  print('====== on ${initArray[4]}');
  rethrow;
} on FormatException {
  print('FormatException');
} catch (e) {
  print('try 异常错误提示 !' + e.toString());
} finally {
  print('程序运行结束');
}
print('>>>>>>>>>>>> try 异常捕获结束 !');
```

![flutter1_53.png](./../Pictures/flutter1_53.png)



<br/><br/>


***
<br/>

># <h1 id='行、列布局'>行、列布局</h1>

>**`MainAxisAlignment（主轴）`**:  就是与当前控件方向一致的轴;
**`CrossAxisAlignment（交叉轴）`**:  就是与当前控件方向垂直的轴;

**`MyApp 类`**

```dart
import 'package:flutter/material.';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        primarySwatch: Colors.purple,
      ),
      home: MyHomePage(title: 'Flutter 布局组件练习'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  MyHomePage({Key key, this.title}) : super(key: key);
  final String title;

  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }


  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body:
          Center(
            //行布局调用
            child: ShadeSquare.testLayoutOfROw(),
            //···
           // ···
           //···
          ),
    );
  }
}
```


<br/>

**`渐变正方形 ShadeSquare 类`**

```dart
//渐变颜色正方形
class ShadeSquare extends StatelessWidget {
  String index;
  double squareSize = 100;

  ShadeSquare(String index) {
    this.index = index;
  }
    
  //行布局
  static Container testLayoutOfROw() {
    /*Container:
    * . 是一个结合了绘制（painting）、定位（positioning）以及尺寸（sizing）widget的widget
    * . 参考资料：https://www.jianshu.com/p/366b2446eaab
    * */
    return Container(
      width: double.infinity,//强制在宽度上撑满，不设置，则根据child和父节点两者一起布局
      height: 800,
      margin: EdgeInsets.all(20),
      /*decoration:
      * . 绘制在child后面的装饰
      * . 设置了decoration的话，就不能设置color属性，否则会报错，此时应该在decoration中进行颜色的设置
      * */
      decoration: BoxDecoration(
        border: Border.all(
          color: Colors.red,
          width: 6,
        ),
        color: Colors.white,//设置container背景色
        borderRadius: new BorderRadius.all(new Radius.circular(20.0)),
      ),
      child: Row(  //container中的内容widget
        /*MainAxisAlignment:  (主轴)就是与当前控件方向一致的轴
        * .start:  将子控件放在主轴的开始位置
        * .end:    将子控件放在主轴的开始位置
        * .center: 将子控件放在主轴的中间位置
        * .spaceBetween:  将主轴空白位置进行均分，排列子元素，手尾没有空隙
        * .spaceAround:   将主轴空白区域均分，使中间各个子控件间距相等，首尾子控件间距为中间子控件间距的一半
        * .spaceEvenly:   将主轴空白区域均分，使各个子控件间距相等
        */
        mainAxisAlignment: MainAxisAlignment.center,
        //crossAxisAlignment: 子组件在纵轴方向的对齐方式
        /*CrossAxisAlignment
          * Row（水平排列）控件中，CrossAxisAlignment的方向就是垂直的;
          * Column（垂直排列）控件中，CrossAxisAlignment的方向就是水平的;
          * .start:     将子控件放在交叉轴的起始位置
          * .end:       将子控件放在交叉轴的结束位置
          * .center:    将子控件放在交叉轴的中间位置
          * .stretch:   使子控件填满交叉轴
          * .baseline:  将子控件放在交叉轴的上，并且与基线相匹配（不常用）
          * */
        crossAxisAlignment: CrossAxisAlignment.start,
        children: <Widget>[
          ShadeSquare("1"),
          ShadeSquare("2"),
          ShadeSquare("3"),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {

    return Container(
      width: squareSize,
      height: squareSize,
      alignment: Alignment.center,
      decoration: BoxDecoration(
        gradient: LinearGradient(
            colors: [Colors.cyanAccent, Colors.cyan, Colors.deepPurpleAccent]
        ),
      ),

      child: Text(
        index,
        style: TextStyle(
          color: Colors.red,
          fontSize: 20,
          fontWeight: FontWeight.bold,
        ),

      ),
    );
  }
}
```  
效果图：

![行布局效果图](./../Pictures/flutter1_0.png)

<br/><br/>

- **`textDirection`**:  就是用来控制水平方向的起始位置和排列方向;
- **`verticalDirection`**:  就是用来控制垂直方向的起始位置和排列方向;


**`ShadeSquare 添加下述方法，并在 MyApp 类调用`**

```dart
  //列布局
  static Column testLayoutOfColumn() {
    return Column(
      /*CrossAxisAlignment: 子组件在纵轴方向的对齐方式
      * Row（水平排列）控件中，CrossAxisAlignment的方向就是垂直的;
      * Column（垂直排列）控件中，CrossAxisAlignment的方向就是水平的;
      * .start:     将子控件放在交叉轴的起始位置
      * .end:       将子控件放在交叉轴的结束位置
      * .center:    将子控件放在交叉轴的中间位置
      * .stretch:   使子控件填满交叉轴
      * .baseline:  将子控件放在交叉轴的上，并且与基线相匹配（不常用）
      * */
      crossAxisAlignment: CrossAxisAlignment.stretch,
      /*MainAxisAlignment:  (主轴)就是与当前控件方向一致的轴
      * .start:  将子控件放在主轴的开始位置
      * .end:    将子控件放在主轴的开始位置
      * .center: 将子控件放在主轴的中间位置
      * .spaceBetween:  将主轴空白位置进行均分，排列子元素，手尾没有空隙
      * .spaceAround:   将主轴空白区域均分，使中间各个子控件间距相等，首尾子控件间距为中间子控件间距的一半
      * .spaceEvenly:   将主轴空白区域均分，使各个子控件间距相等
      * */
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: <Widget>[
        ShadeSquare("1"),
        ShadeSquare("2"),
        ShadeSquare("3"),
      ],
    );
  }
```

<br/>

效果图：

![flutter1_66.png](./../Pictures/flutter1_66.png)

<br/>

***
<br/><br/><br/>

> <h1 id="iOS项目嵌入Flutter模块">iOS项目嵌入Flutter模块</h1>
[iOS原生项目中混编flutter代码调试时实现热重载Hot Reload）（掘金）](https://juejin.cn/post/7054435845293473805)

[flutter项目调试 ios14 flutter module ios（51CTO这个更全）](https://blog.51cto.com/u_16099249/6832188)

- 主工程要运行起来，且要跳转到Flutter页面（防止FlutterEgine没有初始化）

- 切换到Flutter模块，终端输入：

```dart
flutter attach
```

或者

```dart
//查看设备
flutter devices

flutter attach -d 设备id号
```

成功如下：

![Flutter0.0.0.png](./../Pictures/Flutter0.0.0.png)

<br/><br/>
> <h2 id="构建FlutterModule到原生">构建FlutterModule到原生</h2>

配置：

![flutter0.0.2.png](./../Pictures/flutter0.0.2.png)

```dart
NSBonjourServices 
	_observatory._tcp
	
NSLocalNetworkUsageDescription      请求授权以便确认您的网络环境信息，信息将用于确认您在安全可信的环境下使用我们的产品
```

<br/><br/>
- **添加Build Phase来构建代码**

```dart
"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh" build
"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh" embed
```

![ios_oc0.0.0.webp](./../Pictures/ios_oc0.0.0.webp)

<br/>

***
<br/><br/>

> <h1 id="OC中调用FlutterModule的2种方式">OC中调用FlutterModule的2种方式</h1>

- **在OC中调用Flutter Module有两种方式：**

- 直接使用FlutterViewController的方式；

- 使用FlutterEngine的方式。


<br/><br/><br/>

> <h2 id="直接使用FlutterViewController">直接使用FlutterViewController</h2>

```dart
#import "GeneratedPluginRegistrant.h"


/ //iOS+flutter module混编断点调试 https://juejin.cn/post/7327353593891504179
//官方资料：https://docs.flutter.cn/add-to-app/ios/project-setup#option-c-embed-application-and-plugin-frameworks-in-xcode-and-flutter-framework-with-cocoapods
//热重载VM解决（说的有点不懂）：https://juejin.cn/post/7175493950856232997
// 在你的方法中初始化FlutterViewController并注册插件
FlutterEngine *flutterEngine = [[FlutterEngine alloc] initWithName:@"my_engine"];
[flutterEngine runWithEntrypoint:nil initialRoute:@"my_engine://myApp"];
[GeneratedPluginRegistrant registerWithRegistry:flutterEngine];

FlutterViewController *flutterViewController = [[FlutterViewController alloc] initWithEngine:flutterEngine nibName:nil bundle:nil];
flutterViewController.view.backgroundColor = [UIColor whiteColor];
[[HGRouteHandle currentController].navigationController pushViewController:flutterViewController animated:YES];     
```

通过上面的代码，我们可以看到setInitialRoute方法传递了参数“myApp”，该参数用于告诉代码显示哪个Flutter视图。在Flutter Module的main.文件中，需要通过window.defaultRouteName来获取Native指定要显示的路由名，以确定要创建哪个窗口小部件并传递给runApp：

```dart
void main() => runApp();

@override
Widget build(BuildContext context) {
// 获取初始路由
final String initialRoute = WidgetsBinding.instance.window.defaultRouteName;
print("🍎 路由：$initialRoute");

if (initialRoute.startsWith("my_engine://")) {
  return MaterialApp(
    initialRoute: initialRoute,
    routes: {
      '/': (context) => TestMainPage(),
      'my_engine://myApp': (context) => TestSimplePage(data: "myApp"),
      // 可以根据需要添加更多的路由
    },
  );
} else {
  return FlutterBoostApp(
    routeFactory,
    appBuilder: appBuilder,
  );
}
}
```

<br/><br/>使用FlutterEngine的方式<br/>
> <h2 id="使用FlutterEngine的方式">使用FlutterEngine的方式</h2>

- **需要AppDelegate继承自FlutterAppDelegate**

```c
//AppDelegate.h
#import <UIKit/UIKit.h>
#import <Flutter/Flutter.h>

@interface AppDelegate : FlutterAppDelegate

@property (strong, nonatomic) FlutterEngine *flutterEngine;

@end

//AppDelegate.m
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    //FlutterEngine初始化
    self.flutterEngine = [[FlutterEngine alloc] initWithName:@"io.flutter" project:nil];
    [self.flutterEngine runWithEntrypoint:nil];
    [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine];  //有插件
    //设置RootVC
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    UIViewController *vc = [[ViewController alloc] init];
    UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:vc];
    self.window.rootViewController = nav;
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];
    return [super application:application didFinishLaunchingWithOptions:launchOptions];
}
```

<br/>

- **通过FlutterEngine来初始化FlutterViewController**

```dart
FlutterEngine *flutterEngine = [(AppDelegate *)[[UIApplication sharedApplication] delegate] flutterEngine];
FlutterViewController *flutterViewController = [[FlutterViewController alloc] initWithEngine:flutterEngine nibName:nil bundle:nil];
[self.navigationController pushViewController:flutterViewController animated:YES];
```

因为在AppDelegate中，我们已经提前初始化了FlutterEngine，所以这种方式打开一个Flutter模块的速度，比第一种方式要快一些。

【注意】：使用FlutterEngine方式，调用 setInitialRoute 方法会无效，在Flutter端拿到的永远是“I”，这是Flutter SDK的一个BUG，因此如果必须依赖 setInitialRoute 参数，那么只能使用方式一进行赋值。

<br/><br/><br/>
># <h2 id="Flutter与iOS通信开发">[Flutter与iOS通信开发]()</h2>

消息使用Channel(平台通道)在Flutter和Native之间传递，如下图所示：

![flutter0.0.0.webp](./../Pictures/flutter0.0.0.webp)

平台所支持的数据类型如下表所示：

![flutter0.0.1.webp](./../Pictures/flutter0.0.1.webp)


Flutter定义了三种不同类型的Channel：

- **BasicMessageChannel：** 用于传递字符串和半结构化的信息，持续通信，收到消息后可以回复此次消息。例如：Native将遍历到的文件信息陆续传递到；Flutter将服务端获取的数据交给Native加工，Native处理完之后返回。
- **MethodChannel：** 用于传递方法调用，一次性通信。例如：Flutter调用Native拍照。
- **EventChannel：** 用于数据流的通信，持续通信，收到消息后无法回复此次消息，通常用于Native向的通信。例如：手机电量变化，网络连接变化，陀螺仪，传感器等。

<br/>

这三种类型的Channel都是全双工通信，即A <=> B，可以主动发送消息到Native端，并且Native接收消息后可以做出回应。同样地，Native端也可以主动发送消息到端，端接受消息后返回给Native端。

3种通信请看这里[**如何与iOS和Android通信**](./Flutter知识点.md#如何与iOS和Android通信)


