<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReactiveSwift(下)</title>
    <style type="text/css" media="all">
      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif;
        font-size: 14px;
        line-height: 20px;
        color: #777;
        background-color: white;
      }
      .container {
        width: 700px;
        margin-right: auto;
        margin-left: auto;
      }

      .post {
        font-family: Georgia, "Times New Roman", Times, "SimSun", serif;
        position: relative;
        padding: 70px;
        bottom: 0;
        overflow-y: auto;
        font-size: 16px;
        font-weight: normal;
        line-height: 25px;
        color: #515151;
      }

      .post h1{
        font-size: 50px;
        font-weight: 500;
        line-height: 60px;
        margin-bottom: 40px;
        color: inherit;
      }

      .post p {
        margin: 0 0 35px 0;
      }

      .post img {
        border: 1px solid #D9D9D9;
      }

      .post a {
        color: #28A1C5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="post">
        <h1 class="title">ReactiveSwift(下)</h1>
        <div class="show-content">
          <h1><b>SignalProducer</b></h1><p>SignalProducer是ReactiveSwift中冷信号的实现, 是第二种发送事件的途径.</p><p>        热信号是活动着的事件发生器, 相对应的, 冷信号则是休眠中的事件发生器. 也就是说冷信号需要一个唤醒操作, 然后才能发送事件, 而这个唤醒操作就是订阅它. 因为订阅后才发送事件, 显然, 冷信号不存在时机早晚的问题. 仍以春晚举例:</p><p>        冷信号相当于春晚的视频文件而不是现场直播, 正常情况下, 视频文件肯定是不会自动播放的, 但你只要一双击, 它就被启动播放然后输出节目了.</p><blockquote>
<p>//1. 通过SignalProducer.init(startHandler: (Observer, Lifetime) -&gt; Void)创建SignalProducer</p>
<p>let producer = SignalProducer { (innerObserver, lifetime) in</p>
<p>lifetime.observeEnded({</p>
<p>print("信号无效了 你可以在这里进行一些清理工作")</p>
<p>})</p>
<p>//2. 向外界发送事件</p>
<p>innerObserver.send(value: 1)</p>
<p>innerObserver.send(value: 2)</p>
<p>innerObserver.sendCompleted()</p>
<p>}</p>
<p>//3. 创建一个观察者封装事件处理逻辑</p>
<p>let outerObserver = Signal.Observer(value: { (value) in</p>
<p>print("did received value: (value)")</p>
<p>})</p>
<p>//4. 添加观察者到SignalProducer</p>
<p>producer.start(outerObserver)</p>
<p>输出: did received value: 1</p>
<p>did received value: 2</p>
<p>信号无效了 你可以在这里进行一些清理工作</p>
<p><br></p>
</blockquote><blockquote>
<p>typealias Producer = ReactiveSwift.SignalProducer</p>
<p>let producer = Producer { (innerObserver, _) in</p>
<p>//没什么想清理的</p>
<p>innerObserver.send(value: 1)</p>
<p>innerObserver.send(value: 2)</p>
<p>innerObserver.sendCompleted()</p>
<p>}</p>
<p>producer.startWithValues { (value) in</p>
<p>print("did received value: (value)")</p>
<p>}</p>
<p>producer.startWithFailed(action: )</p>
<p>producer.startWithResult(action: )</p>
<p>producer.startWithXXX...各种便利函数</p>
</blockquote><p>和Signal的订阅方式如出一辙, 只是名字换了一下, Signal.observeXXX换成了SignalProducer.startXXX.</p><p><br></p><p>            都是事件发生器, 所以API方面Signal和SignalProducer都是一样的,<b>上面的map, on, merge, comblinelast...等等, SignalProducer也有一份, 作用也都一样</b>, 我就不多说了, 这里简单给两段代码说说可能遇到的坑</p><blockquote>
<p>func fetchData(completionHandler: (Int, Error?) -&gt; ()) {</p>
<p>print("发起网络请求")</p>
<p>completionHandler(1, nil)</p>
<p>}</p>
<p>let producer = Producer {[unowned self] (innerObserver, _) in</p>
<p>self.fetchData(completionHandler: { (data, error) in</p>
<p>innerObserver.send(value: data)</p>
<p>innerObserver.sendCompleted()</p>
<p>})</p>
<p>}</p>
<p>producer.startWithValues { (value) in</p>
<p>print("did received value: (value)")</p>
<p>}</p>
<p>producer.startWithValues { (value) in</p>
<p>print("did received value: (value)")</p>
<p>}</p>
<p>输出: 发起网络请求</p>
<p>did received value: 1</p>
<p>发起网络请求</p>
<p>did received value: 1</p>
<p><br></p>
</blockquote><p>也许你只是想两个观察者共享一次网络请求带回的Event, 但事实上这里会发生两次网络请求, 但这不是一个bug, 这是一个feature.</p><p><b>SignalProducer的一个特性是, 每次被订阅就会执行一次初始化时保存的闭包.</b></p><p><b>所以如果你有类似一次执行, 多处订阅的需求, 你应该选择Signal而不是SignalProducer. 所以, 符合需求的代码可能是这样:<br></b></p><p><b><br></b></p><blockquote>
<p>let signalTuple = NSignal.pipe()</p>
<p>signalTuple.output.observeValues { (value) in</p>
<p>print("did received value: (value)")</p>
<p>}</p>
<p>signalTuple.output.observeValues { (value) in</p>
<p>print("did received value: (value)")</p>
<p>}</p>
<p>self.fetchData { (data, error) in</p>
<p>signalTuple.input.send(value: data)</p>
<p>signalTuple.input.sendCompleted()</p>
<p>}</p>
<p>输出: 发起网络请求</p>
<p>did received value: 1</p>
<p>did received value: 1</p>
</blockquote><p>            到目前为止, 示例代码中给到的都是NoError类型的信号, 在实际开发中, 这显然是不可能的, 毕竟错误是不可避免的. 通常我们的项目会声明一个类似APIError的错误类型来表示这些错误, 所以你可能会有这样的声明:    </p><blockquote>
<p>structAPIError: Swift.Error {</p>
<p>let code: Int</p>
<p>var reason =""</p>
<p>}</p>
<p>typealias NSignal = ReactiveSwift.Signaltypealias </p>
<p> APISignal = ReactiveSwift.Signaltypealias</p>
<p> Producer = ReactiveSwift.SignalProducertypealias</p>
<p> APIProducer = ReactiveSwift.SignalProducer</p>
</blockquote><p>这样的声明很好, 能让ReactiveSwift写起来像RXSwift一样"简洁". 但这里需要加上下面的代码才能更好的工作:</p><blockquote>
<p>extension SignalProducer where Error == APIError {</p>
<p>@discardableResult</p>
<p>func startWithValues(_ action: @escaping (Value) -&gt; Void) -&gt; Disposable {</p>
<p>returnstart(Signal.Observer(value: action))</p>
<p>}</p>
<p>}</p>
</blockquote><p>        这是因为默认的SignalProducer是没有startWithValues函数的, ReactiveSwift会在Extension里给它加上startWithValues函数, 但是这只对NoError有效, 所以当你在自定义Error时, 请记得加上类似的代码.    </p>
        </div>
      </div>
    </div>
  </body>
</html>
